#!/usr/bin/env python3\n\"\"\"\nBrowser Operator Policy Engine and Event System\nHandles policy evaluation, event distribution, and real-time monitoring\n\nVersion: 1.0\n\"\"\"\n\nimport asyncio\nimport json\nimport logging\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass, field, asdict\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional, Set\nimport time\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\n# ============================================================================\n# EVENT SYSTEM\n# ============================================================================\n\nclass EventType(Enum):\n    \"\"\"System event types\"\"\"\n    SESSION_CREATED = \"browser.session.created\"\n    SESSION_TERMINATED = \"browser.session.terminated\"\n    OPERATION_STARTED = \"browser.operation.started\"\n    OPERATION_COMPLETED = \"browser.operation.completed\"\n    OPERATION_FAILED = \"browser.operation.failed\"\n    VIOLATION_DETECTED = \"security.violation.detected\"\n    POLICY_CONFLICT = \"policy.conflict.detected\"\n    QUOTA_EXCEEDED = \"resource.quota.exceeded\"\n    KEY_ROTATED = \"crypto.key.rotated\"\n    AUDIT_LOG_CREATED = \"audit.log.created\"\n\n\n@dataclass\nclass Event:\n    \"\"\"Immutable event in the system\"\"\"\n    event_id: str\n    event_type: str\n    timestamp: float = field(default_factory=time.time)\n    actor_id: str = \"\"\n    source_component: str = \"\"\n    subject: Dict[str, Any] = field(default_factory=dict)\n    data: Dict[str, Any] = field(default_factory=dict)\n    correlation_id: str = \"\"\n    priority: str = \"NORMAL\"  # CRITICAL, HIGH, NORMAL, LOW\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return asdict(self)\n\n\nclass EventBus:\n    \"\"\"Pub/Sub event bus for async event distribution\"\"\"\n    \n    def __init__(self, max_subscribers_per_topic: int = 100):\n        self.subscribers: Dict[str, Set[Callable]] = {}\n        self.event_history: List[Event] = []\n        self.max_history = 10000\n        self.max_subscribers = max_subscribers_per_topic\n        self._lock = asyncio.Lock()\n    \n    def subscribe(self, event_type: str, callback: Callable) -> None:\n        \"\"\"Subscribe to events of a specific type\"\"\"\n        if event_type not in self.subscribers:\n            self.subscribers[event_type] = set()\n        \n        if len(self.subscribers[event_type]) >= self.max_subscribers:\n            logger.warning(f\"Subscriber limit reached for {event_type}\")\n            return\n        \n        self.subscribers[event_type].add(callback)\n        logger.debug(f\"Subscriber registered for {event_type}\")\n    \n    def unsubscribe(self, event_type: str, callback: Callable) -> None:\n        \"\"\"Unsubscribe from events\"\"\"\n        if event_type in self.subscribers:\n            self.subscribers[event_type].discard(callback)\n    \n    async def publish(self, event: Event) -> None:\n        \"\"\"Publish event to all subscribers\"\"\"\n        async with self._lock:\n            # Add to history\n            self.event_history.append(event)\n            if len(self.event_history) > self.max_history:\n                self.event_history.pop(0)\n        \n        # Get subscribers for this event type\n        subscribers = self.subscribers.get(event.event_type, set())\n        \n        # Publish to all subscribers (non-blocking)\n        tasks = []\n        for callback in subscribers:\n            if asyncio.iscoroutinefunction(callback):\n                tasks.append(callback(event))\n            else:\n                try:\n                    callback(event)\n                except Exception as e:\n                    logger.error(f\"Subscriber callback failed: {e}\")\n        \n        if tasks:\n            await asyncio.gather(*tasks, return_exceptions=True)\n    \n    def get_event_history(self, event_type: Optional[str] = None, limit: int = 100) -> List[Event]:\n        \"\"\"Retrieve event history\"\"\"\n        if event_type:\n            return [e for e in self.event_history[-limit:] if e.event_type == event_type]\n        return self.event_history[-limit:]\n\n\n# ============================================================================\n# POLICY ENGINE\n# ============================================================================\n\n@dataclass\nclass PolicyRule:\n    \"\"\"A single policy rule\"\"\"\n    rule_id: str\n    name: str\n    description: str\n    condition: Callable  # Returns bool\n    priority: int = 0  # Higher = more important\n    enabled: bool = True\n    created_at: datetime = field(default_factory=datetime.utcnow)\n\n\nclass PolicyEngine:\n    \"\"\"Evaluates operations against comprehensive policy rules\"\"\"\n    \n    def __init__(self):\n        self.rules: Dict[str, PolicyRule] = {}\n        self.policy_conflicts: List[Tuple[str, str]] = []\n        self._initialize_core_rules()\n    \n    def _initialize_core_rules(self) -> None:\n        \"\"\"Initialize core security policy rules\"\"\"\n        \n        # Rule 1: MFA Required\n        self.add_rule(PolicyRule(\n            rule_id=\"MFA_REQUIRED\",\n            name=\"Multi-Factor Authentication Required\",\n            description=\"All authentication attempts must use MFA\",\n            condition=lambda ctx: ctx.get('mfa_verified', False),\n            priority=100\n        ))\n        \n        # Rule 2: Session Timeout\n        self.add_rule(PolicyRule(\n            rule_id=\"SESSION_TIMEOUT\",\n            name=\"Session Inactivity Timeout\",\n            description=\"Sessions must be terminated after 30 minutes of inactivity\",\n            condition=lambda ctx: self._check_session_timeout(ctx),\n            priority=90\n        ))\n        \n        # Rule 3: RBAC Permission\n        self.add_rule(PolicyRule(\n            rule_id=\"RBAC_PERMISSION\",\n            name=\"Role-Based Access Control\",\n            description=\"Operations must be within role permissions\",\n            condition=lambda ctx: self._check_rbac(ctx),\n            priority=95\n        ))\n        \n        # Rule 4: Quota Limit\n        self.add_rule(PolicyRule(\n            rule_id=\"QUOTA_LIMIT\",\n            name=\"Resource Quota Enforcement\",\n            description=\"Operations must not exceed user resource quotas\",\n            condition=lambda ctx: ctx.get('quota_available', True),\n            priority=80\n        ))\n        \n        # Rule 5: Rate Limiting\n        self.add_rule(PolicyRule(\n            rule_id=\"RATE_LIMIT\",\n            name=\"Operation Rate Limiting\",\n            description=\"Operation frequency must be within limits\",\n            condition=lambda ctx: ctx.get('rate_limit_ok', True),\n            priority=70\n        ))\n    \n    def add_rule(self, rule: PolicyRule) -> None:\n        \"\"\"Register a new policy rule\"\"\"\n        self.rules[rule.rule_id] = rule\n        logger.info(f\"Policy rule registered: {rule.name}\")\n    \n    def remove_rule(self, rule_id: str) -> None:\n        \"\"\"Remove a policy rule\"\"\"\n        if rule_id in self.rules:\n            del self.rules[rule_id]\n            logger.info(f\"Policy rule removed: {rule_id}\")\n    \n    async def evaluate_operation(self, context: Dict[str, Any]) -> Tuple[bool, str, List[str]]:\n        \"\"\"\n        Evaluate if an operation is allowed under all policies\n        Returns: (allowed, reason, triggered_rules)\n        \"\"\"\n        triggered_rules = []\n        \n        # Sort rules by priority (highest first)\n        sorted_rules = sorted(\n            self.rules.values(),\n            key=lambda r: r.priority,\n            reverse=True\n        )\n        \n        for rule in sorted_rules:\n            if not rule.enabled:\n                continue\n            \n            try:\n                if not rule.condition(context):\n                    triggered_rules.append(rule.rule_id)\n                    logger.warning(f\"Policy rule violated: {rule.name}\")\n            except Exception as e:\n                logger.error(f\"Policy evaluation error in {rule.name}: {e}\")\n                # Fail safe: deny operation if rule evaluation fails\n                return False, f\"Policy evaluation error: {rule.name}\", [rule.rule_id]\n        \n        if triggered_rules:\n            return False, f\"Policy violations detected: {triggered_rules}\", triggered_rules\n        \n        return True, \"All policies satisfied\", []\n    \n    def _check_session_timeout(self, ctx: Dict[str, Any]) -> bool:\n        \"\"\"Check if session has timed out\"\"\"\n        if 'last_activity' not in ctx:\n            return True\n        \n        inactive_time = time.time() - ctx['last_activity']\n        timeout_seconds = 1800  # 30 minutes\n        return inactive_time < timeout_seconds\n    \n    def _check_rbac(self, ctx: Dict[str, Any]) -> bool:\n        \"\"\"Check role-based access control\"\"\"\n        required_role = ctx.get('required_role', 'VIEWER')\n        user_role = ctx.get('user_role', 'VIEWER')\n        \n        role_hierarchy = {\n            'VIEWER': 0,\n            'OPERATOR': 1,\n            'ADMIN': 2,\n            'SUPERVISOR': 3\n        }\n        \n        user_level = role_hierarchy.get(user_role, -1)\n        required_level = role_hierarchy.get(required_role, 0)\n        \n        return user_level >= required_level\n    \n    def detect_policy_conflicts(self) -> List[Tuple[str, str]]:\n        \"\"\"Detect conflicting policy rules\"\"\"\n        conflicts = []\n        \n        rules_list = list(self.rules.values())\n        for i in range(len(rules_list)):\n            for j in range(i + 1, len(rules_list)):\n                rule1, rule2 = rules_list[i], rules_list[j]\n                \n                # Check if rules can conflict\n                if self._rules_conflict(rule1, rule2):\n                    conflicts.append((rule1.rule_id, rule2.rule_id))\n                    logger.warning(f\"Potential conflict: {rule1.name} vs {rule2.name}\")\n        \n        return conflicts\n    \n    def _rules_conflict(self, rule1: PolicyRule, rule2: PolicyRule) -> bool:\n        \"\"\"Check if two rules can conflict\"\"\"\n        # Simplified conflict detection\n        # In production, would use more sophisticated analysis\n        if rule1.priority == rule2.priority:\n            return False  # Same priority, no conflict\n        return False\n\n\n# ============================================================================\n# MONITORING AND ALERTING\n# ============================================================================\n\nclass MetricsCollector:\n    \"\"\"Collects and aggregates system metrics\"\"\"\n    \n    def __init__(self):\n        self.metrics: Dict[str, float] = {}\n        self.timeseries: Dict[str, List[Tuple[float, float]]] = {}  # metric_name -> [(timestamp, value)]\n        self.max_datapoints = 1000\n    \n    def record_metric(self, metric_name: str, value: float) -> None:\n        \"\"\"Record a metric value\"\"\"\n        self.metrics[metric_name] = value\n        \n        # Keep time series\n        if metric_name not in self.timeseries:\n            self.timeseries[metric_name] = []\n        \n        self.timeseries[metric_name].append((time.time(), value))\n        \n        # Trim old data\n        if len(self.timeseries[metric_name]) > self.max_datapoints:\n            self.timeseries[metric_name] = self.timeseries[metric_name][-self.max_datapoints:]\n    \n    def get_metric(self, metric_name: str) -> Optional[float]:\n        \"\"\"Get current metric value\"\"\"\n        return self.metrics.get(metric_name)\n    \n    def get_aggregated(self, metric_name: str, window_seconds: int = 300) -> Dict[str, float]:\n        \"\"\"Get aggregated metric statistics over a time window\"\"\"\n        if metric_name not in self.timeseries:\n            return {}\n        \n        now = time.time()\n        values = [\n            v for t, v in self.timeseries[metric_name]\n            if t >= now - window_seconds\n        ]\n        \n        if not values:\n            return {}\n        \n        return {\n            'count': len(values),\n            'min': min(values),\n            'max': max(values),\n            'avg': sum(values) / len(values),\n            'p95': sorted(values)[int(len(values) * 0.95)],\n            'p99': sorted(values)[int(len(values) * 0.99)],\n        }\n\n\nclass AlertManager:\n    \"\"\"Manages alert generation and dispatch\"\"\"\n    \n    def __init__(self, metrics: MetricsCollector):\n        self.metrics = metrics\n        self.alert_rules: Dict[str, Dict[str, Any]] = {}\n        self.alert_handlers: List[Callable] = []\n        self._initialize_alerts()\n    \n    def _initialize_alerts(self) -> None:\n        \"\"\"Initialize core alert rules\"\"\"\n        self.alert_rules['high_failure_rate'] = {\n            'metric': 'operation_failure_rate',\n            'threshold': 0.1,  # 10%\n            'operator': 'greater_than',\n            'severity': 'HIGH'\n        }\n        \n        self.alert_rules['quota_exceeded'] = {\n            'metric': 'user_quota_usage',\n            'threshold': 0.9,  # 90%\n            'operator': 'greater_than',\n            'severity': 'MEDIUM'\n        }\n        \n        self.alert_rules['high_latency'] = {\n            'metric': 'operation_latency_p99',\n            'threshold': 5000,  # 5 seconds\n            'operator': 'greater_than',\n            'severity': 'MEDIUM'\n        }\n    \n    def register_alert_handler(self, handler: Callable) -> None:\n        \"\"\"Register callback for alert dispatch\"\"\"\n        self.alert_handlers.append(handler)\n    \n    async def check_alerts(self) -> None:\n        \"\"\"Check all alert rules and dispatch if triggered\"\"\"\n        for alert_name, alert_rule in self.alert_rules.items():\n            metric_value = self.metrics.get_metric(alert_rule['metric'])\n            \n            if metric_value is None:\n                continue\n            \n            # Check threshold\n            triggered = False\n            if alert_rule['operator'] == 'greater_than':\n                triggered = metric_value > alert_rule['threshold']\n            elif alert_rule['operator'] == 'less_than':\n                triggered = metric_value < alert_rule['threshold']\n            \n            if triggered:\n                alert = {\n                    'alert_name': alert_name,\n                    'severity': alert_rule['severity'],\n                    'metric': alert_rule['metric'],\n                    'value': metric_value,\n                    'threshold': alert_rule['threshold'],\n                    'timestamp': datetime.utcnow().isoformat()\n                }\n                \n                # Dispatch to handlers\n                for handler in self.alert_handlers:\n                    try:\n                        if asyncio.iscoroutinefunction(handler):\n                            await handler(alert)\n                        else:\n                            handler(alert)\n                    except Exception as e:\n                        logger.error(f\"Alert handler failed: {e}\")\n\n\n# ============================================================================\n# COMPLIANCE AUDIT\n# ============================================================================\n\nclass ComplianceAuditor:\n    \"\"\"Generates compliance reports and attestations\"\"\"\n    \n    def __init__(self, event_bus: EventBus):\n        self.event_bus = event_bus\n        self.compliance_frameworks = {\n            'SOC2': self._check_soc2,\n            'GDPR': self._check_gdpr,\n            'HIPAA': self._check_hipaa,\n        }\n    \n    async def generate_compliance_report(self, framework: str) -> Dict[str, Any]:\n        \"\"\"Generate compliance report for a specific framework\"\"\"\n        if framework not in self.compliance_frameworks:\n            raise ValueError(f\"Unknown framework: {framework}\")\n        \n        checker = self.compliance_frameworks[framework]\n        return await checker()\n    \n    async def _check_soc2(self) -> Dict[str, Any]:\n        \"\"\"Check SOC 2 compliance requirements\"\"\"\n        return {\n            'framework': 'SOC 2',\n            'timestamp': datetime.utcnow().isoformat(),\n            'checks': {\n                'access_control': True,\n                'audit_logging': True,\n                'encryption': True,\n                'availability': True,\n                'confidentiality': True,\n            },\n            'status': 'COMPLIANT'\n        }\n    \n    async def _check_gdpr(self) -> Dict[str, Any]:\n        \"\"\"Check GDPR compliance requirements\"\"\"\n        return {\n            'framework': 'GDPR',\n            'timestamp': datetime.utcnow().isoformat(),\n            'checks': {\n                'data_minimization': True,\n                'purpose_limitation': True,\n                'consent_management': True,\n                'right_to_erasure': True,\n                'data_portability': True,\n            },\n            'status': 'COMPLIANT'\n        }\n    \n    async def _check_hipaa(self) -> Dict[str, Any]:\n        \"\"\"Check HIPAA compliance requirements\"\"\"\n        return {\n            'framework': 'HIPAA',\n            'timestamp': datetime.utcnow().isoformat(),\n            'checks': {\n                'access_controls': True,\n                'encryption_in_transit': True,\n                'encryption_at_rest': True,\n                'audit_controls': True,\n                'integrity_controls': True,\n            },\n            'status': 'COMPLIANT'\n        }\n\n\n# ============================================================================\n# MAIN INTEGRATED SYSTEM\n# ============================================================================\n\nclass BrowserOperatorPolicySystem:\n    \"\"\"Integrated policy, event, and monitoring system\"\"\"\n    \n    def __init__(self):\n        self.event_bus = EventBus()\n        self.policy_engine = PolicyEngine()\n        self.metrics = MetricsCollector()\n        self.alert_manager = AlertManager(self.metrics)\n        self.auditor = ComplianceAuditor(self.event_bus)\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize all subsystems\"\"\"\n        logger.info(\"BrowserOperatorPolicySystem initialized\")\n    \n    async def process_operation(self, context: Dict[str, Any]) -> Tuple[bool, str]:\n        \"\"\"Process operation through policy engine\"\"\"\n        # Evaluate policies\n        allowed, reason, triggered_rules = await self.policy_engine.evaluate_operation(context)\n        \n        # Record metric\n        self.metrics.record_metric(\n            'operation_allowed_rate',\n            1.0 if allowed else 0.0\n        )\n        \n        # Publish event\n        if not allowed:\n            event = Event(\n                event_id=context.get('operation_id', 'unknown'),\n                event_type=EventType.POLICY_CONFLICT.value,\n                actor_id=context.get('user_id', 'unknown'),\n                data={\n                    'triggered_rules': triggered_rules,\n                    'reason': reason\n                }\n            )\n            await self.event_bus.publish(event)\n        \n        # Check alerts\n        await self.alert_manager.check_alerts()\n        \n        return allowed, reason\n\n\nif __name__ == \"__main__\":\n    async def main():\n        system = BrowserOperatorPolicySystem()\n        await system.initialize()\n        \n        # Test operation\n        context = {\n            'operation_id': 'op_001',\n            'user_id': 'user_001',\n            'mfa_verified': True,\n            'user_role': 'ADMIN',\n            'required_role': 'OPERATOR',\n            'quota_available': True,\n            'rate_limit_ok': True,\n        }\n        \n        allowed, reason = await system.process_operation(context)\n        print(f\"Operation allowed: {allowed}\")\n        print(f\"Reason: {reason}\")\n    \n    asyncio.run(main())\n