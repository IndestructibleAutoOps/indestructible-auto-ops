# @GL-governed
# @GL-layer: CI/CD
# @GL-semantic: workflow-validation
# @GL-audit-trail: ../../engine/governance/GL_SEMANTIC_ANCHOR.json
#
# GL Unified Charter Activated
# @GL-governed
# @GL-layer: CI/CD
# @GL-semantic: workflow-validation
# @GL-audit-trail: ../../engine/governance/GL_SEMANTIC_ANCHOR.json
#
# GL Unified Charter Activated
# =============================================================================
# GL Artifacts Generator Workflow
# Automatically generates governance artifacts from templates
# =============================================================================
name: GL Artifacts Generator

permissions:
  contents: read

on:
  workflow_dispatch:
    inputs:
      layer:
        description: 'Target GL layer (e.g., GL00-09, GL10-29)'
        required: true
        type: choice
        options:
          - GL00-09
          - GL10-29
          - GL30-49
          - GL50-59
          - GL60-80
          - GL81-83
          - GL90-99
      artifact_type:
        description: 'Artifact type to generate'
        required: true
        type: string
      artifact_name:
        description: 'Name for the new artifact'
        required: true
        type: string
      owner:
        description: 'Owner of the artifact'
        required: false
        default: 'governance-team'
      create_pr:
        description: 'Create a PR with the generated artifact'
        required: false
        default: true
        type: boolean
        
  repository_dispatch:
    types: [generate-artifact]

env:
  PYTHON_VERSION: '3.11'
  TEMPLATES_PATH: 'workspace/governance/meta-spec/GL-ARTIFACTS-TEMPLATES.yaml'
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ==========================================================================
  # Job 1: Generate Artifact
  # ==========================================================================
  generate-artifact:
    name: Generate GL Artifact
    runs-on: ubuntu-latest
    outputs:
      artifact_path: ${{ steps.generate.outputs.artifact_path }}
      
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          
      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          
      - name: Install Dependencies
        run: |
          pip install pyyaml jinja2
          
      - name: Create Generator Script
        run: |
          mkdir -p scripts/gl-engine
          cat > scripts/gl-engine/artifact_generator.py << 'GENERATOR_EOF'
          #!/usr/bin/env python3
          """GL Artifact Generator - Creates governance artifacts from templates."""
          
          import os
          import sys
          import yaml
          import argparse
          from datetime import datetime
          from pathlib import Path
          from typing import Dict, Any, Optional
          
          class GLArtifactGenerator:
              """Generates GL artifacts from templates."""
              
              # Layer to directory mapping
              LAYER_DIRECTORIES = {
                  'GL00-09': 'workspace/governance/strategic',
                  'GL10-29': 'workspace/governance/operational',
                  'GL30-49': 'workspace/governance/execution',
                  'GL50-59': 'workspace/governance/observability',
                  'GL60-80': 'workspace/governance/feedback',
                  'GL81-83': 'workspace/governance/extended',
                  'GL90-99': 'workspace/governance/meta-spec',
              }
              
              # Artifact type to kind mapping
              ARTIFACT_KINDS = {
                  'vision_statement': 'VisionStatement',
                  'strategic_objectives': 'StrategicObjectives',
                  'governance_charter': 'GovernanceCharter',
                  'risk_register': 'RiskRegister',
                  'operational_plan': 'OperationalPlan',
                  'sop': 'StandardOperatingProcedure',
                  'resource_allocation': 'ResourceAllocation',
                  'project_plan': 'ProjectPlan',
                  'test_report': 'TestReport',
                  'deployment_record': 'DeploymentRecord',
                  'metrics_definition': 'MetricsDefinition',
                  'alert_rules': 'AlertRules',
                  'slo_report': 'SLOReport',
                  'ab_test_design': 'ABTestDesign',
                  'model_retraining_log': 'ModelRetrainingLog',
                  'innovation_experiment': 'InnovationExperiment',
                  'meta_specification': 'MetaSpecification',
                  'validation_report': 'ValidationReport',
              }
              
              def __init__(self, templates_path: str):
                  self.templates_path = Path(templates_path)
                  self.templates = self._load_templates()
                  
              def _load_templates(self) -> Dict[str, Any]:
                  """Load templates from YAML file."""
                  if not self.templates_path.exists():
                      print(f"Warning: Templates file not found at {self.templates_path}")
                      return {}
                      
                  with open(self.templates_path, 'r', encoding='utf-8') as f:
                      return yaml.safe_load(f) or {}
                      
              def generate_artifact(
                  self,
                  layer: str,
                  artifact_type: str,
                  name: str,
                  owner: str = 'governance-team',
                  additional_data: Optional[Dict] = None
              ) -> Dict[str, Any]:
                  """Generate a new artifact from template."""
                  
                  kind = self.ARTIFACT_KINDS.get(artifact_type, artifact_type)
                  now = datetime.utcnow().isoformat() + 'Z'
                  
                  # Create base artifact structure
                  artifact = {
                      'apiVersion': 'governance.machinenativeops.io/v2',
                      'kind': kind,
                      'metadata': {
                          'name': name,
                          'version': '1.0.0',
                          'created_at': now,
                          'updated_at': now,
                          'owner': owner,
                          'layer': layer,
                          'tags': [layer.lower(), artifact_type],
                          'annotations': {
                              'generator': 'gl-artifacts-generator',
                              'generated_at': now,
                          }
                      },
                      'spec': self._generate_spec(layer, artifact_type, additional_data),
                      'status': {
                          'phase': 'draft',
                          'conditions': []
                      }
                  }
                  
                  return artifact
                  
              def _generate_spec(
                  self,
                  layer: str,
                  artifact_type: str,
                  additional_data: Optional[Dict] = None
              ) -> Dict[str, Any]:
                  """Generate spec section based on artifact type."""
                  
                  # Default specs for different artifact types
                  default_specs = {
                      'vision_statement': {
                          'vision': {
                              'statement': '# TODO: Define vision statement',
                              'horizon': '5 years'
                          },
                          'mission': {
                              'statement': '# TODO: Define mission statement',
                              'purpose': '# TODO: Define purpose'
                          },
                          'values': [
                              {
                                  'name': 'Excellence',
                                  'description': '# TODO: Define value',
                                  'behaviors': ['# TODO: Define behaviors']
                              }
                          ],
                          'strategic_pillars': [
                              {
                                  'name': '# TODO: Define pillar',
                                  'description': '# TODO: Define description',
                                  'objectives': ['# TODO: Define objectives']
                              }
                          ]
                      },
                      'strategic_objectives': {
                          'objectives': [
                              {
                                  'id': 'OBJ-001',
                                  'title': '# TODO: Define objective',
                                  'description': '# TODO: Define description',
                                  'owner': '# TODO: Assign owner',
                                  'priority': 1,
                                  'key_results': [
                                      {
                                          'id': 'KR-001',
                                          'description': '# TODO: Define key result',
                                          'metric': '# TODO: Define metric',
                                          'baseline': 0,
                                          'target': 100,
                                          'current': 0,
                                          'unit': '%'
                                      }
                                  ],
                                  'timeline': {
                                      'start_date': '# TODO: Set start date',
                                      'end_date': '# TODO: Set end date'
                                  }
                              }
                          ],
                          'dependencies': [],
                          'resources': {
                              'budget': 0,
                              'headcount': 0,
                              'tools': []
                          }
                      },
                      'operational_plan': {
                          'alignment': {
                              'strategic_objectives': []
                          },
                          'initiatives': [
                              {
                                  'id': 'INIT-001',
                                  'name': '# TODO: Define initiative',
                                  'description': '# TODO: Define description',
                                  'owner': '# TODO: Assign owner',
                                  'department': '# TODO: Assign department',
                                  'priority': 1,
                                  'deliverables': [],
                                  'resources': {
                                      'budget': 0,
                                      'headcount': 0
                                  },
                                  'timeline': {
                                      'start_date': '# TODO: Set start date',
                                      'end_date': '# TODO: Set end date'
                                  },
                                  'kpis': [],
                                  'risks': []
                              }
                          ],
                          'resource_allocation': {
                              'total_budget': 0,
                              'by_department': []
                          },
                          'governance': {
                              'review_cadence': 'monthly',
                              'escalation_criteria': []
                          }
                      },
                      'metrics_definition': {
                          'metrics': [
                              {
                                  'name': '# TODO: Define metric name',
                                  'type': 'gauge',
                                  'description': '# TODO: Define description',
                                  'unit': '# TODO: Define unit',
                                  'labels': [],
                                  'collection': {
                                      'source': '# TODO: Define source',
                                      'interval': '1m',
                                      'aggregation': 'avg'
                                  },
                                  'thresholds': {
                                      'warning': 80,
                                      'critical': 95
                                  }
                              }
                          ],
                          'dashboards': []
                      },
                      'alert_rules': {
                          'rules': [
                              {
                                  'name': '# TODO: Define alert name',
                                  'description': '# TODO: Define description',
                                  'severity': 'warning',
                                  'condition': {
                                      'metric': '# TODO: Define metric',
                                      'operator': '>',
                                      'threshold': 80,
                                      'duration': '5m'
                                  },
                                  'labels': {},
                                  'annotations': {
                                      'summary': '# TODO: Define summary',
                                      'description': '# TODO: Define description',
                                      'runbook': '# TODO: Link to runbook'
                                  },
                                  'notification': {
                                      'channels': ['slack'],
                                      'escalation': []
                                  }
                              }
                          ]
                      },
                      'project_plan': {
                          'overview': {
                              'title': '# TODO: Define project title',
                              'description': '# TODO: Define description',
                              'objectives': [],
                              'success_criteria': []
                          },
                          'team': {
                              'project_manager': '# TODO: Assign PM',
                              'tech_lead': '# TODO: Assign tech lead',
                              'members': []
                          },
                          'timeline': {
                              'start_date': '# TODO: Set start date',
                              'end_date': '# TODO: Set end date',
                              'phases': []
                          },
                          'work_breakdown': [],
                          'risks': [],
                          'communication': {
                              'stakeholders': [],
                              'meetings': []
                          }
                      }
                  }
                  
                  # Get default spec or create empty one
                  spec = default_specs.get(artifact_type, {
                      'description': '# TODO: Define specification',
                      'configuration': {}
                  })
                  
                  # Merge with additional data if provided
                  if additional_data:
                      spec.update(additional_data)
                      
                  return spec
                  
              def save_artifact(self, artifact: Dict[str, Any], layer: str, name: str) -> str:
                  """Save artifact to appropriate directory."""
                  
                  # Get directory for layer
                  base_dir = Path(self.LAYER_DIRECTORIES.get(layer, 'workspace/governance/other'))
                  base_dir.mkdir(parents=True, exist_ok=True)
                  
                  # Create filename
                  filename = f"{name.lower().replace(' ', '-').replace('_', '-')}.yaml"
                  file_path = base_dir / filename
                  
                  # Save artifact
                  with open(file_path, 'w', encoding='utf-8') as f:
                      yaml.dump(artifact, f, default_flow_style=False, allow_unicode=True, sort_keys=False)
                      
                  return str(file_path)
          
          def main():
              parser = argparse.ArgumentParser(description='Generate GL artifacts')
              parser.add_argument('--layer', required=True, help='Target GL layer')
              parser.add_argument('--type', required=True, dest='artifact_type', help='Artifact type')
              parser.add_argument('--name', required=True, help='Artifact name')
              parser.add_argument('--owner', default='governance-team', help='Artifact owner')
              parser.add_argument('--templates', default='workspace/governance/meta-spec/GL-ARTIFACTS-TEMPLATES.yaml',
                                  help='Path to templates file')
              parser.add_argument('--output', help='Output file path (optional)')
              
              args = parser.parse_args()
              
              generator = GLArtifactGenerator(args.templates)
              
              # Generate artifact
              artifact = generator.generate_artifact(
                  layer=args.layer,
                  artifact_type=args.artifact_type,
                  name=args.name,
                  owner=args.owner
              )
              
              # Save artifact
              if args.output:
                  output_path = args.output
                  Path(output_path).parent.mkdir(parents=True, exist_ok=True)
                  with open(output_path, 'w', encoding='utf-8') as f:
                      yaml.dump(artifact, f, default_flow_style=False, allow_unicode=True, sort_keys=False)
              else:
                  output_path = generator.save_artifact(artifact, args.layer, args.name)
                  
              print(f"Generated artifact: {output_path}")
              # Write artifact path to GitHub Actions output
              with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                  fh.write(f"artifact_path={output_path}\n")
              
              # Print artifact content
              print("\n--- Generated Artifact ---")
              print(yaml.dump(artifact, default_flow_style=False, allow_unicode=True, sort_keys=False))
              
          if __name__ == '__main__':
              main()
          GENERATOR_EOF
          chmod +x scripts/gl-engine/artifact_generator.py
          
      - name: Generate Artifact
        id: generate
        run: |
          python scripts/gl-engine/artifact_generator.py \
            --layer "${{ github.event.inputs.layer }}" \
            --type "${{ github.event.inputs.artifact_type }}" \
            --name "${{ github.event.inputs.artifact_name }}" \
            --owner "${{ github.event.inputs.owner }}"
            
      - name: Upload Generated Artifact
        uses: actions/upload-artifact@v6
        with:
          name: generated-artifact
          path: workspace/governance/
          retention-days: 30

  # ==========================================================================
  # Job 2: Create Pull Request
  # ==========================================================================
  create-pr:
    name: Create Pull Request
    permissions:
      contents: write
      pull-requests: write
      issues: write
    runs-on: ubuntu-latest
    needs: generate-artifact
    if: github.event.inputs.create_pr == 'true'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          
      - name: Download Generated Artifact
        uses: actions/download-artifact@v7
        with:
          name: generated-artifact
          path: workspace/governance/
          
      - name: Setup Git
        run: |
          git config --global user.name "GL Artifacts Generator"
          git config --global user.email "governance-bot@machinenativeops.io"
          
      - name: Create Branch and Stage Changes
        id: branch
        run: |
          BRANCH_NAME="gl-artifact/${{ github.event.inputs.layer }}/${{ github.event.inputs.artifact_name }}"
          BRANCH_NAME=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g')
          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          git checkout -b "$BRANCH_NAME"
          git add workspace/governance/
          
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: OpenCommit â€” improve commits with AI ðŸ§™
        uses: di-sukharev/opencommit@github-action-v1.0.4
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GL_TOKEN }}
      - name: Push Branch
        run: |
          git push origin "${{ steps.branch.outputs.branch_name }}"
          
      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v8
        with:
          commit-message: |
            feat(governance): Add ${{ github.event.inputs.artifact_type }} artifact for ${{ github.event.inputs.layer }}
            
            - Generated: ${{ github.event.inputs.artifact_name }}
            - Layer: ${{ github.event.inputs.layer }}
            - Type: ${{ github.event.inputs.artifact_type }}
            - Owner: ${{ github.event.inputs.owner }}
            
            Generated by GL Artifacts Generator workflow
          branch: ${{ steps.branch.outputs.name }}
          delete-branch: true
          title: 'feat(governance): Add ${{ github.event.inputs.artifact_type }} for ${{ github.event.inputs.layer }}'
          body: |
            ## GL Artifact Generation
            
            This PR was automatically generated by the GL Artifacts Generator workflow.
            
            ### Details
            - **Layer**: ${{ github.event.inputs.layer }}
            - **Artifact Type**: ${{ github.event.inputs.artifact_type }}
            - **Artifact Name**: ${{ github.event.inputs.artifact_name }}
            - **Owner**: ${{ github.event.inputs.owner }}
            
            ### Checklist
            - [ ] Review generated artifact structure
            - [ ] Fill in TODO placeholders
            - [ ] Validate against GL specifications
            - [ ] Update related artifacts if needed
            
            ### Next Steps
            1. Review the generated artifact
            2. Complete the TODO sections
            3. Run GL validation workflow
            4. Merge when ready
            
            ---
            *Generated by GL Artifacts Generator*
          labels: |
            governance
            auto-generated
            ${{ github.event.inputs.layer }}
          committer: GL Artifacts Generator <governance-bot@machinenativeops.io>
          author: GL Artifacts Generator <governance-bot@machinenativeops.io>

  # ==========================================================================
  # Job 3: Validate Generated Artifact
  # ==========================================================================
  validate-artifact:
    name: Validate Generated Artifact
    runs-on: ubuntu-latest
    needs: generate-artifact
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v6
        
      - name: Download Generated Artifact
        uses: actions/download-artifact@v7
        with:
          name: generated-artifact
          path: workspace/governance/
          
      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'
          
      - name: Install Dependencies
        run: pip install pyyaml
        
      - name: Validate Artifact
        run: |
          cat > validate.py << 'EOF'
          import yaml
          import sys
          from pathlib import Path
          
          def validate_artifact(file_path):
              with open(file_path, 'r') as f:
                  artifact = yaml.safe_load(f)
                  
              errors = []
              
              # Check required fields
              if 'apiVersion' not in artifact:
                  errors.append("Missing apiVersion")
              if 'kind' not in artifact:
                  errors.append("Missing kind")
              if 'metadata' not in artifact:
                  errors.append("Missing metadata")
              else:
                  required_metadata = ['name', 'version', 'created_at', 'owner', 'layer']
                  for field in required_metadata:
                      if field not in artifact['metadata']:
                          errors.append(f"Missing metadata.{field}")
              if 'spec' not in artifact:
                  errors.append("Missing spec")
                  
              return errors
              
          # Find and validate all YAML files
          governance_path = Path('workspace/governance')
          all_errors = []
          
          for yaml_file in governance_path.rglob('*.yaml'):
              try:
                  errors = validate_artifact(yaml_file)
                  if errors:
                      all_errors.append((str(yaml_file), errors))
              except Exception as e:
                  all_errors.append((str(yaml_file), [str(e)]))
                  
          if all_errors:
              print("Validation errors found:")
              for file_path, errors in all_errors:
                  print(f"\n{file_path}:")
                  for error in errors:
                      print(f"  - {error}")
              sys.exit(1)
          else:
              print("All artifacts validated successfully!")
          EOF
          
          python validate.py
