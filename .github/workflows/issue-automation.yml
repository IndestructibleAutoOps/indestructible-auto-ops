name: ü§ñ Issue Automation

# This workflow provides comprehensive issue automation including:
# - Auto-labeling based on content
# - Welcome messages for new contributors
# - Status transitions
# - Slash commands (/priority, /status, /assign, /label, /close, /reopen, /help)
# Note: This workflow coexists with automated-issue-carrier.yml which handles
# issue carrying functionality using a third-party action.

on:
  issues:
    types: [opened, edited, labeled, unlabeled, assigned, unassigned, closed, reopened]
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================
  # Auto-label new issues based on content
  # ============================================
  auto-label:
    name: Auto Label Issues
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited'

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Auto-label based on title and body
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const content = title + ' ' + body;

            const labelsToAdd = [];

            // Component detection
            if (content.includes('engine') || content.includes('aep')) {
              labelsToAdd.push('component:engine');
            }
            if (content.includes('gl-gate') || content.includes('gate')) {
              labelsToAdd.push('component:gl-gate');
            }
            if (content.includes('governance') || content.includes('charter')) {
              labelsToAdd.push('component:governance');
            }
            if (content.includes('web') || content.includes('ui') || content.includes('frontend')) {
              labelsToAdd.push('component:web-app');
            }
            if (content.includes('cli') || content.includes('command line')) {
              labelsToAdd.push('component:cli');
            }

            // Type detection from title prefix
            if (title.startsWith('[bug]') || title.includes('bug:') || content.includes('error') || content.includes('crash') || content.includes('broken')) {
              labelsToAdd.push('type:bug');
            }
            if (title.startsWith('[feature]') || title.includes('feature:') || content.includes('feature request')) {
              labelsToAdd.push('type:feature');
            }
            if (title.startsWith('[security]') || content.includes('security') || content.includes('vulnerability') || content.includes('cve')) {
              labelsToAdd.push('type:security');
              labelsToAdd.push('priority:critical');
            }
            if (content.includes('refactor') || content.includes('cleanup') || content.includes('technical debt')) {
              labelsToAdd.push('type:refactor');
            }
            if (content.includes('test') || content.includes('coverage') || content.includes('jest')) {
              labelsToAdd.push('type:test');
            }
            if (content.includes('ci/cd') || content.includes('workflow') || content.includes('pipeline') || content.includes('github actions')) {
              labelsToAdd.push('type:ci-cd');
            }

            // GL compliance detection
            if (content.includes('@gl-governed') || content.includes('gl marker') || content.includes('gl compliance')) {
              labelsToAdd.push('gl:compliance');
            }
            if (content.includes('charter') || content.includes('unified charter')) {
              labelsToAdd.push('gl:charter');
            }
            if (content.includes('audit') || content.includes('gl audit')) {
              labelsToAdd.push('gl:audit');
            }

            // Priority detection from content
            if (content.includes('critical') || content.includes('urgent') || content.includes('asap') || content.includes('production down')) {
              labelsToAdd.push('priority:critical');
            } else if (content.includes('high priority') || content.includes('important')) {
              labelsToAdd.push('priority:high');
            }

            // Documentation
            if (content.includes('documentation') || content.includes('readme') || content.includes('docs')) {
              labelsToAdd.push('documentation');
            }

            // Add labels if any detected
            if (labelsToAdd.length > 0) {
              const uniqueLabels = [...new Set(labelsToAdd)];

              // Fetch existing labels on the issue to avoid attempting to add duplicates
              const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
              });

              const existingLabelNames = new Set(existingLabels.map(label => label.name));
              const labelsToApply = uniqueLabels.filter(label => !existingLabelNames.has(label));

              if (labelsToApply.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: labelsToApply,
                });
                console.log(`Added labels: ${labelsToApply.join(', ')}`);
              } else {
                console.log('No new labels to add; all detected labels are already present on the issue.');
              }
            }

  # ============================================
  # Welcome new contributors
  # ============================================
  welcome:
    name: Welcome New Contributors
    runs-on: ubuntu-latest
    if: github.event.action == 'opened'

    steps:
      - name: Check if first issue
        id: check
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const creator = issue.user.login;
            const currentIssueNumber = issue.number;

            // Use pagination to handle users with 100+ issues
            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                creator: creator,
                state: 'all',
                per_page: 100
              }
            );

            // Filter out pull requests; we only care about actual issues
            const issueItems = issues ? issues.filter((item) => !item.pull_request) : [];

            if (!issueItems || issueItems.length === 0) {
              return false;
            }

            const earliestIssue = issueItems.reduce((earliest, candidate) => {
              return new Date(candidate.created_at) < new Date(earliest.created_at)
                ? candidate
                : earliest;
            }, issueItems[0]);

            // Treat as first issue only if the current issue is the earliest by creation date
            return earliestIssue.number === currentIssueNumber;
          result-encoding: string

      - name: Welcome message
        if: steps.check.outputs.result == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const welcomeMessage = [
              '## üëã Welcome to Machine Native Ops!',
              '',
              `Thank you for opening your first issue, @${issue.user.login}! We appreciate your contribution.`,
              '',
              '**GL Unified Charter Activated** üèõÔ∏è',
              '',
              '### What happens next?',
              '1. üè∑Ô∏è Our automation will label and categorize this issue',
              '2. üëÄ A maintainer will review and triage within 48 hours',
              '3. üìã The issue will be prioritized and assigned',
              '',
              '### While you wait',
              '- üìö Check our [documentation](https://github.com/MachineNativeOps/machine-native-ops/tree/main/docs)',
              '- üí¨ Join the [discussion](https://github.com/MachineNativeOps/machine-native-ops/discussions)',
              '- üîç Review our [contribution guidelines](https://github.com/MachineNativeOps/machine-native-ops/blob/main/CONTRIBUTING.md)',
              '',
              'Thank you for helping improve Machine Native Ops! üöÄ'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: welcomeMessage
            });

  # ============================================
  # Auto-assign based on component
  # ============================================
  auto-assign:
    name: Auto Assign Issues
    runs-on: ubuntu-latest
    if: github.event.action == 'labeled'

    steps:
      - name: Assign based on component label
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const label = context.payload.label;

            // Skip if already assigned
            if (issue.assignees && issue.assignees.length > 0) {
              console.log('Issue already assigned, skipping');
              return;
            }

            // Component to team mapping (customize as needed)
            const componentAssignees = {
              'component:engine': [],
              'component:gl-gate': [],
              'component:governance': [],
              'component:web-app': [],
              'component:cli': [],
              'type:security': [],
              'priority:critical': []
            };

            const assignees = componentAssignees[label.name];
            if (assignees && assignees.length > 0) {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                assignees: assignees
              });
              console.log(`Assigned to: ${assignees.join(', ')}`);
            }

  # ============================================
  # Stale issue management
  # ============================================
  stale-check:
    name: Check Stale Issues
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'reopened'

    steps:
      - name: Remove stale label if present
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name);

            if (labels.includes('stale')) {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                name: 'stale'
              });
              console.log('Removed stale label');
            }

  # ============================================
  # Status transitions
  # ============================================
  status-transition:
    name: Status Transitions
    runs-on: ubuntu-latest
    if: github.event.action == 'assigned' || github.event.action == 'closed' || github.event.action == 'reopened'

    steps:
      - name: Update status labels
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;
            const action = context.payload.action;

            const statusLabels = [
              'status:triage',
              'status:ready',
              'status:in-progress',
              'status:review',
              'status:blocked'
            ];

            // Remove existing status labels
            for (const label of issue.labels) {
              if (statusLabels.includes(label.name)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label.name
                  });
                } catch (e) {
                  console.log(`Could not remove label ${label.name}: ${e?.message || e}`);
                }
              }
            }

            // Add new status label based on action
            let newStatus = null;
            if (action === 'assigned') {
              newStatus = 'status:in-progress';
            } else if (action === 'reopened') {
              newStatus = 'status:triage';
            }

            if (newStatus) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: [newStatus]
              });
              console.log(`Added status: ${newStatus}`);
            }

  # ============================================
  # Close issue comment
  # ============================================
  close-comment:
    name: Close Issue Comment
    runs-on: ubuntu-latest
    if: github.event.action == 'closed'

    steps:
      - name: Add closing comment
        uses: actions/github-script@v8
        with:
          script: |
            const issue = context.payload.issue;

            // Check if a closing comment has already been added
            const comments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                per_page: 100
              }
            );

            // Check if we've already posted a closing comment
            const hasClosingComment = comments.some(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('## ‚úÖ Issue Closed')
            );

            if (hasClosingComment) {
              console.log('Closing comment already exists, skipping');
              return;
            }

            // Check if closed by PR
            const closedByPR = issue.state_reason === 'completed';

            let message = `## ‚úÖ Issue Closed\n\n`;

            if (closedByPR) {
              message += `This issue has been resolved and closed.\n\n`;
            } else {
              message += `This issue has been closed.\n\n`;
            }

            message += `**GL Unified Charter Activated** üèõÔ∏è\n\n`;
            message += `If you believe this issue should be reopened, please comment with additional details.\n\n`;
            message += `Thank you for your contribution to Machine Native Ops! üöÄ`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: message
            });

  # ============================================
  # Command handler for issue comments
  # ============================================
  command-handler:
    name: Handle Issue Commands
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && github.event.action == 'created'

    steps:
      - name: Process commands
        uses: actions/github-script@v8
        with:
          script: |
            const comment = context.payload.comment;
            const issue = context.payload.issue;
            const body = comment.body.trim();

            // Check if comment starts with /
            if (!body.startsWith('/')) {
              return;
            }

            const command = body.split(' ')[0].toLowerCase();
            const args = body.split(' ').slice(1).join(' ');

            console.log(`Processing command: ${command} with args: ${args}`);

            switch (command) {
              case '/priority':
                const validPriorities = ['critical', 'high', 'medium', 'low'];
                const priority = args.toLowerCase();
                if (validPriorities.includes(priority)) {
                  // Remove existing priority labels
                  for (const p of validPriorities) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        name: `priority:${p}`
                      });
                    } catch (e) {
                      console.log(`Could not remove priority label priority:${p}: ${e?.message || e}`);
                    }
                  }
                  // Add new priority
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [`priority:${priority}`]
                  });
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `‚úÖ Priority set to **${priority}**`
                  });
                }
                break;

              case '/status':
                const validStatuses = ['triage', 'ready', 'in-progress', 'review', 'blocked'];
                const status = args.toLowerCase();
                if (validStatuses.includes(status)) {
                  // Remove existing status labels
                  for (const s of validStatuses) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        name: `status:${s}`
                      });
                    } catch (e) {
                      console.log(`Could not remove status label status:${s}: ${e?.message || e}`);
                    }
                  }
                  // Add new status
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: [`status:${status}`]
                  });
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `‚úÖ Status set to **${status}**`
                  });
                }
                break;

              case '/assign':
                if (args) {
                  try {
                    const assignee = args.replace('@', '');
                    await github.rest.issues.addAssignees({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      assignees: [assignee]
                    });
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `‚úÖ Assigned to @${assignee}`
                    });
                  } catch (error) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `‚ùå Failed to assign @${args.replace('@', '')}: ${error?.message || error}`
                    });
                  }
                }
                break;

              case '/label':
                if (args) {
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: [args]
                    });
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `‚úÖ Added label: **${args}**`
                    });
                  } catch (error) {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      body: `‚ùå Failed to add label **${args}**: ${error?.message || error}`
                    });
                  }
                }
                break;

              case '/close':
                try {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'closed',
                    state_reason: args === 'not-planned' ? 'not_planned' : 'completed'
                  });
                } catch (error) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `‚ùå Failed to close issue: ${error?.message || error}`
                  });
                }
                break;

              case '/reopen':
                try {
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    state: 'open'
                  });
                } catch (error) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: `‚ùå Failed to reopen issue: ${error?.message || error}`
                  });
                }
                break;

              case '/help':
                const helpMessage = `## ü§ñ Available Commands\n\n| Command | Description | Example |\n|---------|-------------|---------|\n| \`/priority <level>\` | Set priority (critical, high, medium, low) | \`/priority high\` |\n| \`/status <status>\` | Set status (triage, ready, in-progress, review, blocked) | \`/status in-progress\` |\n| \`/assign <user>\` | Assign issue to user | \`/assign @username\` |\n| \`/label <label>\` | Add a label | \`/label type:bug\` |\n| \`/close [not-planned]\` | Close the issue | \`/close\` |\n| \`/reopen\` | Reopen the issue | \`/reopen\` |\n| \`/help\` | Show this help message | \`/help\` |\n\n**GL Unified Charter Activated** üèõÔ∏è`;

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: helpMessage
                });
                break;

              default:
                console.log(`Unrecognized command: ${command} with args: ${args}`);
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: `‚ùì Unrecognized command: \`${command}\`.\n\nType \`/help\` for a list of available commands.`
                });
                break;
            }
