name: "[L1-CI] Full CI Pipeline with Evidence Collection"

# @GL-governed
# @GL-layer: GL10-29
# @GL-semantic: full-ci-pipeline
# @GL-audit-trail: ../../governance/GL_SEMANTIC_ANCHOR.json

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: read
  security-events: write
  pull-requests: write
  packages: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Metadata collection job
  metadata:
    name: Collect Pipeline Metadata
    runs-on: ubuntu-latest
    outputs:
      metadata: ${{ steps.collect.outputs.metadata }}
      trigger: ${{ steps.collect.outputs.trigger }}
      pipeline-id: ${{ steps.collect.outputs.pipeline-id }}
      timestamp: ${{ steps.collect.outputs.timestamp }}
    
    steps:
      - name: Collect metadata
        id: collect
        run: |
          METADATA=$(jq -n \
            --arg run_id "${{ github.run_id }}" \
            --arg run_number "${{ github.run_number }}" \
            --arg sha "${{ github.sha }}" \
            --arg ref "${{ github.ref }}" \
            --arg ref_name "${{ github.ref_name }}" \
            --arg event "${{ github.event_name }}" \
            --arg actor "${{ github.actor }}" \
            --arg repository "${{ github.repository }}" \
            --arg base_ref "${{ github.base_ref }}" \
            --arg head_ref "${{ github.head_ref }}" \
            --arg pr_number "${{ github.event.pull_request.number }}" \
            '{
              pipeline: {
                id: $run_id,
                number: $run_number,
                sha: $sha,
                ref: $ref,
                ref_name: $ref_name,
                trigger: $event,
                actor: $actor,
                repository: $repository,
                timestamp: (now | todate)
              },
              trigger: {
                type: $event,
                base_ref: $base_ref,
                head_ref: $head_ref,
                pr_number: $pr_number
              }
            }')
          
          echo "metadata=$METADATA" >> $GITHUB_OUTPUT
          echo "trigger=${{ github.event_name }}" >> $GITHUB_OUTPUT
          echo "pipeline-id=${{ github.run_id }}" >> $GITHUB_OUTPUT
          echo "timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
          
          echo "$METADATA" > metadata.json

      - name: Upload metadata artifact
        uses: actions/upload-artifact@v3.1.2
        with:
          name: pipeline-metadata-${{ github.run_id }}
          path: metadata.json
          retention-days: 90

  # Stage 1: Quality Checks
  quality:
    name: Quality Checks
    needs: metadata
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.quality.outputs.status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608
        with:
          fetch-depth: 0

      - name: Download metadata
        uses: actions/download-artifact@v3.0.2
        with:
          name: pipeline-metadata-${{ github.run_id }}

      - name: Run linting
        id: lint
        run: |
          echo "Running linters..."
          
          # Python linting
          pip install -q ruff mypy
          ruff check . --output-format json > ruff-report.json || true
          mypy apps/ --json-report mypy-report || true
          
          # JavaScript linting
          npm ci
          npm run lint -- --format json --output-file eslint-report.json || true
          
          # YAML linting
          yamllint -f parsable . > yamllint-report.txt 2>&1 || true
          
          echo "lint_status=$?" >> $GITHUB_OUTPUT

      - name: Run tests
        id: test
        run: |
          echo "Running tests..."
          
          # Python tests
          pytest apps/ --json-report --json-report-file=pytest-report.json || true
          
          # JavaScript tests
          npm test -- --json --outputFile=test-report.json || true
          
          echo "test_status=$?" >> $GITHUB_OUTPUT

      - name: Generate quality report
        id: quality
        run: |
          REPORT=$(jq -n \
            --arg lint_status "${{ steps.lint.outputs.lint_status }}" \
            --arg test_status "${{ steps.test.outputs.test_status }}" \
            '{
              lint: { status: ($lint_status | tonumber == 0) },
              tests: { status: ($test_status | tonumber == 0) },
              overall: ($lint_status | tonumber == 0) and ($test_status | tonumber == 0)
            }')
          
          echo "$REPORT" > quality-report.json
          echo "status=$(echo "$REPORT" | jq -r '.overall')" >> $GITHUB_OUTPUT

      - name: Upload quality artifacts
        if: always()
        uses: actions/upload-artifact@v3.1.2
        with:
          name: quality-artifacts-${{ github.run_id }}
          path: |
            ruff-report.json
            mypy-report/
            eslint-report.json
            yamllint-report.txt
            pytest-report.json
            test-report.json
            quality-report.json
          retention-days: 30

  # Stage 2: Security Scanning
  security:
    name: Security Scanning
    needs: metadata
    runs-on: ubuntu-latest
    outputs:
      critical: ${{ steps.security.outputs.critical }}
      high: ${{ steps.security.outputs.high }}
      status: ${{ steps.security.outputs.status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608

      - name: Download metadata
        uses: actions/download-artifact@v3.0.2
        with:
          name: pipeline-metadata-${{ github.run_id }}

      - name: Run Trivy scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'json'
          output: 'trivy-report.json'
          severity: 'CRITICAL,HIGH'

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}
        with:
          report-path: gitleaks-report.json
          format: json

      - name: Parse security findings
        id: security
        run: |
          CRITICAL=$(jq '.Results | length' trivy-report.json 2>/dev/null || echo 0)
          HIGH=$(jq '.Results | length' trivy-report.json 2>/dev/null || echo 0)
          
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "high=$HIGH" >> $GITHUB_OUTPUT
          echo "status=$(($CRITICAL + HIGH > 0 ? 'failed' : 'passed'))" >> $GITHUB_OUTPUT

      - name: Upload security artifacts
        if: always()
        uses: actions/upload-artifact@v3.1.2
        with:
          name: security-artifacts-${{ github.run_id }}
          path: |
            trivy-report.json
            gitleaks-report.json
          retention-days: 30

      - name: Fail on critical findings
        if: steps.security.outputs.critical != '0'
        run: |
          echo "âŒ Critical security findings detected"
          exit 1

  # Stage 3: Build and SBOM Generation
  build:
    name: Build and SBOM
    needs: [metadata, quality, security]
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
      sbom-path: ${{ steps.sbom.outputs.path }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608

      - name: Download metadata
        uses: actions/download-artifact@v3.0.2
        with:
          name: pipeline-metadata-${{ github.run_id }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2.10.0

      - name: Build Docker images
        id: build
        run: |
          IMAGE_TAG="${{ github.sha }}"
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          docker build -t ghcr.io/${{ github.repository }}:$IMAGE_TAG .
          docker build -t ghcr.io/${{ github.repository }}:latest .

      - name: Generate SBOM
        id: sbom
        uses: anchore/sbom-action@v0.14.3
        with:
          image: ghcr.io/${{ github.repository }}:${{ github.sha }}
          format: spdx-json
          output-file: sbom.json
          upload-artifact: true

      - name: Sign SBOM with Cosign
        uses: sigstore/cosign-installer@v3.1.1

      - name: Sign image
        run: |
          cosign sign \
            --yes \
            ghcr.io/${{ github.repository }}:${{ github.sha }}

      - name: Generate SLSA provenance
        uses: slsa-framework/slsa-github-generator@v1.9.0
        with:
          image: ghcr.io/${{ github.repository }}:${{ github.sha }}
          base64-slsa-provenance: ${{ steps.build.outputs.image-tag }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3.1.2
        with:
          name: build-artifacts-${{ github.run_id }}
          path: |
            sbom.json
            *.attestation
          retention-days: 90

  # Stage 4: Integration Tests
  integration:
    name: Integration Tests
    needs: [metadata, build]
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.integration.outputs.status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@8ade135a41bc03ea155e62e844d188df1ea18608

      - name: Download artifacts
        uses: actions/download-artifact@v3.0.2
        with:
          path: artifacts

      - name: Run integration tests
        id: integration
        run: |
          echo "Running integration tests..."
          pytest tests/integration/ \
            --junitxml=integration-test-results.xml \
            --html=integration-test-report.html || true
          
          echo "status=$?" >> $GITHUB_OUTPUT

      - name: Upload integration test artifacts
        if: always()
        uses: actions/upload-artifact@v3.1.2
        with:
          name: integration-artifacts-${{ github.run_id }}
          path: |
            integration-test-results.xml
            integration-test-report.html
          retention-days: 30

  # Evidence collection and audit log
  evidence:
    name: Collect Evidence and Audit Log
    needs: [metadata, quality, security, build, integration]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v3.0.2
        with:
          path: all-artifacts

      - name: Generate evidence output
        id: evidence
        run: |
          EVIDENCE=$(jq -n \
            --argjson metadata "$(cat all-artifacts/pipeline-metadata-${{ github.run_id }}/metadata.json)" \
            --argjson quality "$(cat all-artifacts/quality-artifacts-${{ github.run_id }}/quality-report.json)" \
            --arg image_tag "${{ needs.build.outputs.image-tag }}" \
            --arg sbom_path "${{ needs.build.outputs.sbom-path }}" \
            --arg integration_status "${{ needs.integration.outputs.status }}" \
            '{
              pipeline: $metadata.pipeline,
              quality: $quality,
              build: {
                image_tag: $image_tag,
                sbom_path: $sbom_path
              },
              integration: {
                status: $integration_status
              },
              evidence_collected: (now | todate)
            }')
          
          echo "$EVIDENCE" > evidence-output.json
          echo "path=evidence-output.json" >> $GITHUB_OUTPUT

      - name: Generate audit log
        id: audit
        run: |
          AUDIT_LOG=$(jq -n \
            --arg pipeline_id "${{ github.run_id }}" \
            --arg timestamp "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
            --arg actor "${{ github.actor }}" \
            --arg repository "${{ github.repository }}" \
            --arg ref "${{ github.ref }}" \
            --arg quality_status "${{ needs.quality.outputs.status }}" \
            --arg security_status "${{ needs.security.outputs.status }}" \
            --arg integration_status "${{ needs.integration.outputs.status }}" \
            '{
              pipeline_id: $pipeline_id,
              timestamp: $timestamp,
              actor: $actor,
              repository: $repository,
              ref: $ref,
              stages: {
                quality: { status: $quality_status },
                security: { status: $security_status },
                integration: { status: $integration_status }
              },
              artifacts: {
                evidence: "evidence-output.json",
                sbom: $sbom_path,
                provenance: "*.attestation"
              }
            }')
          
          echo "$AUDIT_LOG" > audit-log.json
          echo "path=audit-log.json" >> $GITHUB_OUTPUT

      - name: Upload evidence and audit log
        uses: actions/upload-artifact@v3.1.2
        with:
          name: evidence-audit-${{ github.run_id }}
          path: |
            evidence-output.json
            audit-log.json
          retention-days: 365

      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const quality = '${{ needs.quality.outputs.status }}';
            const security = '${{ needs.security.outputs.status }}';
            const integration = '${{ needs.integration.outputs.status }}';
            
            let comment = `## ğŸš€ CI Pipeline Results\n\n`;
            comment += `| Stage | Status |\n`;
            comment += `|-------|--------|\n`;
            comment += `| Quality | ${quality === 'true' ? 'âœ…' : 'âŒ'} |\n`;
            comment += `| Security | ${security === 'passed' ? 'âœ…' : 'âŒ'} |\n`;
            comment += `| Integration | ${integration === '0' ? 'âœ…' : 'âŒ'} |\n\n`;
            comment += `### ğŸ”— Evidence\n\n`;
            comment += `- [Evidence Output](artifacts/evidence-audit-${{ github.run_id }}/evidence-output.json)\n`;
            comment += `- [Audit Log](artifacts/evidence-audit-${{ github.run_id }}/audit-log.json)\n`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Fail action on any stage failure
  fail-on-error:
    name: Fail on Any Stage Failure
    needs: [metadata, quality, security, integration]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Check all stages
        run: |
          if [ "${{ needs.quality.outputs.status }}" != "true" ] || \
             [ "${{ needs.security.outputs.status }}" == "failed" ] || \
             [ "${{ needs.integration.outputs.status }}" != "0" ]; then
            echo "âŒ Pipeline failed - one or more stages failed"
            exit 1
          else
            echo "âœ… All stages passed successfully"
          fi