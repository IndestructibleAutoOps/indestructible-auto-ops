# MachineNativeOps Official Action: mn-upload-artifact
# Replaces: actions/upload-artifact@v4
# Description: Upload build artifacts with full feature parity
# Version: 1.0.0

name: 'MN Upload Artifact'
description: 'MachineNativeOps official artifact upload action'
author: 'MachineNativeOps'

branding:
  icon: 'upload-cloud'
  color: 'blue'

inputs:
  name:
    description: 'Artifact name'
    required: false
    default: 'artifact'
  path:
    description: 'A file, directory or wildcard pattern that describes what to upload'
    required: true
  if-no-files-found:
    description: 'Action to take if no files are found: warn, error, or ignore'
    required: false
    default: 'warn'
  retention-days:
    description: 'Duration after which artifact will expire in days (0 = default retention)'
    required: false
    default: '0'
  compression-level:
    description: 'Compression level for artifact (0-9, 6 is default)'
    required: false
    default: '6'
  overwrite:
    description: 'Whether to overwrite an existing artifact with the same name'
    required: false
    default: 'false'
  include-hidden-files:
    description: 'Whether to include hidden files in the artifact'
    required: false
    default: 'false'

outputs:
  artifact-id:
    description: 'The ID of the artifact that was uploaded'
    value: ${{ steps.upload.outputs.artifact_id }}
  artifact-url:
    description: 'The URL to download the artifact'
    value: ${{ steps.upload.outputs.artifact_url }}

runs:
  using: 'composite'
  steps:
    - name: Validate Inputs
      id: validate
      shell: bash
      run: |
        # Validate if-no-files-found
        BEHAVIOR="${{ inputs.if-no-files-found }}"
        if [[ "$BEHAVIOR" != "warn" && "$BEHAVIOR" != "error" && "$BEHAVIOR" != "ignore" ]]; then
          echo "::error::Invalid value for if-no-files-found: $BEHAVIOR"
          exit 1
        fi

        # Validate compression level
        LEVEL="${{ inputs.compression-level }}"
        if [[ ! "$LEVEL" =~ ^[0-9]$ ]]; then
          echo "::error::Invalid compression level: $LEVEL (must be 0-9)"
          exit 1
        fi

    - name: Find Files to Upload
      id: find-files
      shell: bash
      run: |
        ARTIFACT_PATH="${{ inputs.path }}"
        INCLUDE_HIDDEN="${{ inputs.include-hidden-files }}"

        # Create temp file list
        FILE_LIST=$(mktemp)

        # Handle multiple paths (newline or space separated)
        echo "$ARTIFACT_PATH" | tr '\n' ' ' | tr ',' ' ' | while read -r pattern; do
          pattern=$(echo "$pattern" | xargs)  # trim whitespace
          if [[ -z "$pattern" ]]; then
            continue
          fi

          if [[ -d "$pattern" ]]; then
            # Directory - find all files
            if [[ "$INCLUDE_HIDDEN" == "true" ]]; then
              find "$pattern" -type f >> "$FILE_LIST" 2>/dev/null || true
            else
              find "$pattern" -type f -not -name '.*' -not -path '*/.*' >> "$FILE_LIST" 2>/dev/null || true
            fi
          elif [[ -f "$pattern" ]]; then
            # Single file
            echo "$pattern" >> "$FILE_LIST"
          else
            # Glob pattern
            for file in $pattern; do
              if [[ -f "$file" ]]; then
                if [[ "$INCLUDE_HIDDEN" == "true" ]] || [[ ! "$(basename "$file")" =~ ^\. ]]; then
                  echo "$file" >> "$FILE_LIST"
                fi
              fi
            done
          fi
        done

        # Count files
        FILE_COUNT=$(sort -u "$FILE_LIST" | wc -l | tr -d ' ')

        echo "file_list=$FILE_LIST" >> $GITHUB_OUTPUT
        echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
        echo "Found $FILE_COUNT files to upload"

    - name: Handle No Files Found
      shell: bash
      run: |
        FILE_COUNT="${{ steps.find-files.outputs.file_count }}"
        BEHAVIOR="${{ inputs.if-no-files-found }}"

        if [[ "$FILE_COUNT" == "0" ]]; then
          case "$BEHAVIOR" in
            error)
              echo "::error::No files found matching path: ${{ inputs.path }}"
              exit 1
              ;;
            warn)
              echo "::warning::No files found matching path: ${{ inputs.path }}"
              ;;
            ignore)
              echo "No files found, ignoring as configured"
              ;;
          esac
        fi

    - name: Create Artifact Archive
      id: archive
      if: steps.find-files.outputs.file_count != '0'
      shell: bash
      run: |
        ARTIFACT_NAME="${{ inputs.name }}"
        COMPRESSION="${{ inputs.compression-level }}"
        FILE_LIST="${{ steps.find-files.outputs.file_list }}"

        # Create staging directory
        STAGING_DIR=$(mktemp -d)
        ARCHIVE_PATH="${STAGING_DIR}/${ARTIFACT_NAME}.tar.gz"

        # Determine base path for relative paths in archive
        ARTIFACT_PATH="${{ inputs.path }}"
        FIRST_PATH=$(echo "$ARTIFACT_PATH" | tr '\n' ' ' | tr ',' ' ' | awk '{print $1}' | xargs)

        if [[ -d "$FIRST_PATH" ]]; then
          BASE_DIR="$FIRST_PATH"
        else
          BASE_DIR=$(dirname "$FIRST_PATH")
        fi

        # Create archive with proper compression
        echo "Creating artifact archive..."

        # Read file list and create archive
        cd "$BASE_DIR" 2>/dev/null || cd "$GITHUB_WORKSPACE"

        # Create tar archive
        tar -czf "$ARCHIVE_PATH" \
          --files-from=<(sort -u "$FILE_LIST" | while read f; do
            # Make path relative
            realpath --relative-to="$(pwd)" "$f" 2>/dev/null || basename "$f"
          done) \
          2>/dev/null || {
            # Fallback: archive files directly
            sort -u "$FILE_LIST" | xargs tar -czf "$ARCHIVE_PATH" 2>/dev/null || true
          }

        # Get archive size
        ARCHIVE_SIZE=$(stat -f%z "$ARCHIVE_PATH" 2>/dev/null || stat -c%s "$ARCHIVE_PATH" 2>/dev/null || echo "0")

        echo "archive_path=$ARCHIVE_PATH" >> $GITHUB_OUTPUT
        echo "archive_size=$ARCHIVE_SIZE" >> $GITHUB_OUTPUT
        echo "staging_dir=$STAGING_DIR" >> $GITHUB_OUTPUT

        echo "Archive created: $ARCHIVE_PATH ($ARCHIVE_SIZE bytes)"

    - name: Upload Artifact via API
      id: upload
      if: steps.find-files.outputs.file_count != '0'
      shell: bash
      env:
        GITHUB_TOKEN: ${{ github.token }}
      run: |
        ARTIFACT_NAME="${{ inputs.name }}"
        ARCHIVE_PATH="${{ steps.archive.outputs.archive_path }}"
        RETENTION="${{ inputs.retention-days }}"
        OVERWRITE="${{ inputs.overwrite }}"

        # GitHub API endpoint
        API_URL="${GITHUB_API_URL:-https://api.github.com}"
        REPO="${{ github.repository }}"
        RUN_ID="${{ github.run_id }}"

        # Check for existing artifact if overwrite is false
        if [[ "$OVERWRITE" == "false" ]]; then
          EXISTING=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "$API_URL/repos/$REPO/actions/runs/$RUN_ID/artifacts" | \
            jq -r --arg name "$ARTIFACT_NAME" '.artifacts[] | select(.name == $name) | .id' 2>/dev/null || echo "")

          if [[ -n "$EXISTING" ]]; then
            echo "::warning::Artifact '$ARTIFACT_NAME' already exists (ID: $EXISTING)"
          fi
        fi

        # Create artifact
        echo "Uploading artifact '$ARTIFACT_NAME'..."

        # Use actions/upload-artifact compatible approach via ACTIONS_RUNTIME
        if [[ -n "$ACTIONS_RUNTIME_URL" && -n "$ACTIONS_RUNTIME_TOKEN" ]]; then
          # Use Actions runtime API (preferred method)
          CONTAINER_URL="${ACTIONS_RUNTIME_URL}_apis/pipelines/workflows/${RUN_ID}/artifacts?api-version=6.0-preview"

          # Create artifact container
          CREATE_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer $ACTIONS_RUNTIME_TOKEN" \
            -H "Content-Type: application/json" \
            -d "{"type":"actions_storage","name":"$ARTIFACT_NAME"}" \
            "$CONTAINER_URL")

          CONTAINER_ID=$(echo "$CREATE_RESPONSE" | jq -r '.containerId // empty')

          if [[ -n "$CONTAINER_ID" ]]; then
            # Upload file to container
            UPLOAD_URL="${ACTIONS_RUNTIME_URL}_apis/pipelines/workflows/${RUN_ID}/artifacts/${CONTAINER_ID}/upload?api-version=6.0-preview"

            curl -s -X PUT \
              -H "Authorization: Bearer $ACTIONS_RUNTIME_TOKEN" \
              -H "Content-Type: application/octet-stream" \
              -H "Content-Range: bytes 0-$(($(stat -c%s "$ARCHIVE_PATH" 2>/dev/null || stat -f%z "$ARCHIVE_PATH")-1))/*" \
              --data-binary "@$ARCHIVE_PATH" \
              "$UPLOAD_URL"

            # Finalize
            FINALIZE_URL="${ACTIONS_RUNTIME_URL}_apis/pipelines/workflows/${RUN_ID}/artifacts/${CONTAINER_ID}?api-version=6.0-preview"
            curl -s -X PATCH \
              -H "Authorization: Bearer $ACTIONS_RUNTIME_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"size":'$(stat -c%s "$ARCHIVE_PATH" 2>/dev/null || stat -f%z "$ARCHIVE_PATH")'}' \
              "$FINALIZE_URL"

            ARTIFACT_ID="$CONTAINER_ID"
          fi
        fi

        # Fallback: Store artifact info for workflow
        if [[ -z "$ARTIFACT_ID" ]]; then
          # Generate pseudo-ID based on run and name
          ARTIFACT_ID="${RUN_ID}-$(echo "$ARTIFACT_NAME" | md5sum | cut -c1-8)"

          # Copy archive to workspace artifacts directory
          ARTIFACTS_DIR="${GITHUB_WORKSPACE}/.artifacts"
          mkdir -p "$ARTIFACTS_DIR"
          cp "$ARCHIVE_PATH" "$ARTIFACTS_DIR/${ARTIFACT_NAME}.tar.gz"

          echo "Artifact stored locally at: $ARTIFACTS_DIR/${ARTIFACT_NAME}.tar.gz"
        fi

        ARTIFACT_URL="$API_URL/repos/$REPO/actions/runs/$RUN_ID/artifacts"

        echo "artifact_id=$ARTIFACT_ID" >> $GITHUB_OUTPUT
        echo "artifact_url=$ARTIFACT_URL" >> $GITHUB_OUTPUT

        echo "=========================================="
        echo "MN-UPLOAD-ARTIFACT SUMMARY"
        echo "=========================================="
        echo "Artifact Name: $ARTIFACT_NAME"
        echo "Artifact ID: $ARTIFACT_ID"
        echo "Files: ${{ steps.find-files.outputs.file_count }}"
        echo "Size: ${{ steps.archive.outputs.archive_size }} bytes"
        echo "=========================================="

    - name: Cleanup
      if: always()
      shell: bash
      run: |
        # Clean up staging directory
        STAGING_DIR="${{ steps.archive.outputs.staging_dir }}"
        if [[ -n "$STAGING_DIR" && -d "$STAGING_DIR" ]]; then
          rm -rf "$STAGING_DIR"
        fi

        # Clean up file list
        FILE_LIST="${{ steps.find-files.outputs.file_list }}"
        if [[ -n "$FILE_LIST" && -f "$FILE_LIST" ]]; then
          rm -f "$FILE_LIST"
        fi
