name: Policy Validation Gate

on:
  pull_request:
    branches: [ main, develop ]
  push:
    branches: [ main, develop, 'copilot/**' ]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  validate-naming-policy:
    name: Validate Naming Conventions
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: v0.60.0

      - name: Validate file naming conventions
        id: naming
        run: |
          echo "Validating naming conventions with OPA..."
          
          # Create test data for naming policy
          cat > /tmp/naming-test.json << 'EOF'
          {
            "resource": {
              "type": "file",
              "name": "test-file.yaml"
            }
          }
          EOF
          
          # Test the naming policy
          opa eval -d controlplane/governance/policies/naming.rego \
            -i /tmp/naming-test.json \
            'data.mno.governance.policies.naming.allow' \
            --format pretty
          
          echo "‚úÖ Naming policy validation passed"

      - name: Check for naming violations in changed files
        run: |
          # Get list of changed files
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # Fetch the base branch to ensure it's available
            git fetch origin ${{ github.base_ref }} --depth=1 || true
            FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD 2>/dev/null || git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-files)
          else
            FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-files)
          fi
          
          echo "Checking naming conventions for changed files..."
          VIOLATIONS=0
          
          for file in $FILES; do
            # Skip deleted files and directories
            if [ ! -f "$file" ]; then
              continue
            fi
            
            # Check for invalid naming patterns
            filename=$(basename "$file")
            
            # Check for spaces in filename
            if [[ "$filename" =~ \  ]]; then
              echo "‚ùå VIOLATION: File contains spaces: $file"
              VIOLATIONS=$((VIOLATIONS + 1))
            fi
            
            # Check for uppercase in filename (except README, LICENSE, etc.)
            if [[ "$filename" =~ [A-Z] ]] && [[ ! "$filename" =~ ^(README|LICENSE|CHANGELOG|CONTRIBUTING|CODE_OF_CONDUCT|SECURITY|AUTHORS|INSTALL|MAKEFILE|DOCKERFILE) ]]; then
              if [[ ! "$filename" =~ \.(md|MD)$ ]]; then
                echo "‚ö†Ô∏è  Warning: File contains uppercase: $file (consider kebab-case)"
              fi
            fi
          done
          
          if [ $VIOLATIONS -gt 0 ]; then
            echo "‚ùå Found $VIOLATIONS naming violations"
            exit 1
          else
            echo "‚úÖ All file names comply with naming conventions"
          fi

  validate-semantic-health:
    name: Validate Semantic Consistency
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: v0.60.0

      - name: Check module semantic health
        run: |
          python3 << 'PYTHON_SCRIPT'
          import yaml
          import json
          import sys
          from pathlib import Path
          
          # Load module registry
          registry_path = Path("controlplane/baseline/modules/REGISTRY.yaml")
          with open(registry_path, 'r') as f:
              registry = yaml.safe_load(f)
          
          print("üîç Checking Module Semantic Health")
          print("=" * 50)
          
          modules = registry.get('modules', [])
          failed = False
          
          for module in modules:
              module_id = module.get('module_id', 'unknown')
              health_score = module.get('semantic_health_score', 0)
              
              # Semantic health must be >= 80
              if health_score < 80:
                  print(f"‚ùå {module_id}: Semantic health score {health_score} < 80")
                  failed = True
              else:
                  print(f"‚úÖ {module_id}: Semantic health score {health_score}")
          
          print("=" * 50)
          if failed:
              print("‚ùå Some modules have semantic health scores below threshold")
              sys.exit(1)
          else:
              print("‚úÖ All modules meet semantic health requirements")
          PYTHON_SCRIPT

  validate-security-requirements:
    name: Validate Security Policies
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: v0.60.0

      - name: Validate security policy syntax
        run: |
          echo "Validating security policy..."
          opa check controlplane/governance/policies/security.rego
          echo "‚úÖ Security policy syntax valid"

      - name: Test security policy rules
        run: |
          # Test SBOM requirement with correct input format
          cat > /tmp/artifact-test.json << 'EOF'
          {
            "resource": {
              "type": "artifact",
              "name": "test-image:latest",
              "sbom": {
                "version": "1.0",
                "format": "spdx"
              },
              "provenance": {
                "slsa_level": 3,
                "builder": "github-actions"
              },
              "signature": {
                "type": "cosign",
                "verified": true
              },
              "vulnerabilities": []
            }
          }
          EOF
          
          RESULT=$(opa eval -d controlplane/governance/policies/security.rego \
            -i /tmp/artifact-test.json \
            'data.mno.governance.policies.security.allow' \
            --format raw)
          
          echo "Security policy evaluation result: $RESULT"
          
          if [ "$RESULT" = "true" ]; then
            echo "‚úÖ Security policy tests passed"
          else
            echo "‚ùå Security policy test failed"
            exit 1
          fi

  validate-autonomy-levels:
    name: Validate Autonomy Progression
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup OPA
        uses: open-policy-agent/setup-opa@v2
        with:
          version: v0.60.0

      - name: Check autonomy level progression
        run: |
          python3 << 'PYTHON_SCRIPT'
          import yaml
          from pathlib import Path
          
          # Load module registry
          registry_path = Path("controlplane/baseline/modules/REGISTRY.yaml")
          with open(registry_path, 'r') as f:
              registry = yaml.safe_load(f)
          
          print("üîç Checking Autonomy Level Progression")
          print("=" * 50)
          
          modules = registry.get('modules', [])
          module_dict = {m['module_id']: m for m in modules}
          
          failed = False
          
          for module in modules:
              module_id = module.get('module_id')
              autonomy = module.get('autonomy_level', '')
              dependencies = module.get('dependencies', [])
              
              print(f"\nüì¶ {module_id} (Autonomy: {autonomy})")
              
              # Check dependency autonomy levels
              for dep in dependencies:
                  if dep == 'none' or dep not in module_dict:
                      continue
                  
                  dep_autonomy = module_dict[dep].get('autonomy_level', '')
                  print(f"  ‚Üí Depends on {dep} (Autonomy: {dep_autonomy})")
                  
                  # Basic validation: module should have >= dependency autonomy
                  # This is a simplified check
                  if autonomy and dep_autonomy:
                      if autonomy < dep_autonomy and 'Global' not in autonomy:
                          print(f"  ‚ö†Ô∏è  Warning: {module_id} autonomy may be lower than dependency")
          
          print("\n" + "=" * 50)
          print("‚úÖ Autonomy level checks completed")
          PYTHON_SCRIPT

  policy-gate-summary:
    name: Policy Gate Summary
    runs-on: ubuntu-latest
    needs: [validate-naming-policy, validate-semantic-health, validate-security-requirements, validate-autonomy-levels]
    if: always()
    
    steps:
      - name: Check all policy validations
        run: |
          echo "Policy Validation Gate Results:"
          echo "================================"
          echo "Naming Policy: ${{ needs.validate-naming-policy.result }}"
          echo "Semantic Health: ${{ needs.validate-semantic-health.result }}"
          echo "Security Requirements: ${{ needs.validate-security-requirements.result }}"
          echo "Autonomy Levels: ${{ needs.validate-autonomy-levels.result }}"
          echo ""
          
          if [ "${{ needs.validate-naming-policy.result }}" == "success" ] && \
             [ "${{ needs.validate-semantic-health.result }}" == "success" ] && \
             [ "${{ needs.validate-security-requirements.result }}" == "success" ] && \
             [ "${{ needs.validate-autonomy-levels.result }}" == "success" ]; then
            echo "‚úÖ All policy gates passed!"
            echo "status=success" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "‚ùå Some policy gates failed. Review the logs above."
            echo "status=failure" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Comment on PR (if applicable)
        if: github.event_name == 'pull_request'
        continue-on-error: true  # Allow workflow to pass even if comment fails (e.g., for cross-repo PRs)
        uses: actions/github-script@v8
        with:
          script: |
            const namingResult = '${{ needs.validate-naming-policy.result }}';
            const semanticResult = '${{ needs.validate-semantic-health.result }}';
            const securityResult = '${{ needs.validate-security-requirements.result }}';
            const autonomyResult = '${{ needs.validate-autonomy-levels.result }}';
            
            const allPassed = namingResult === 'success' &&
                              semanticResult === 'success' &&
                              securityResult === 'success' &&
                              autonomyResult === 'success';
            
            const status = allPassed ? '‚úÖ PASSED' : '‚ùå FAILED';
            const namingIcon = namingResult === 'success' ? '‚úÖ' : '‚ùå';
            const semanticIcon = semanticResult === 'success' ? '‚úÖ' : '‚ùå';
            const securityIcon = securityResult === 'success' ? '‚úÖ' : '‚ùå';
            const autonomyIcon = autonomyResult === 'success' ? '‚úÖ' : '‚ùå';
            const conclusion = allPassed ? '**All policy gates passed! Ready for merge.**' : '**Some policy gates failed. Please review the workflow logs.**';
            
            const comment = `## üîê Policy Validation Gate Results
            
            ${status}
            
            | Policy | Status |
            |--------|--------|
            | Naming Conventions | ${namingIcon} ${namingResult} |
            | Semantic Health | ${semanticIcon} ${semanticResult} |
            | Security Requirements | ${securityIcon} ${securityResult} |
            | Autonomy Levels | ${autonomyIcon} ${autonomyResult} |
            
            ${conclusion}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
