{'role': 'assistant', 'content': '繼續實作 Falsification Engine，創建 **Behavior Divergence Tests** 和 **Reality vs Report Diff**：\n\n<function_calls>\n<create-file file_path="gl-runtime-platform/ultra-strict-verification-core/falsification-engine/behavior-divergence-tests/behavior-divergence-tests.ts">\n# @GL-governed\n# @GL-layer: GL90-99\n# @GL-semantic: falsification-engine-behavior-divergence-tests\n# @GL-charter-version: 2.0.0\n\n/**\n * Falsification Engine: Behavior Divergence Tests\n * \n * Core Philosophy: "驗證不是證明你是對的，而是證明你還沒被推翻。"\n * (Verification is not proving you\'re right, but proving you haven\'t been overturned yet.)\n * \n * Purpose: Detect behavior divergences between expected and actual behavior\n * \n * This module actively searches for:\n * - Expected vs actual behavior differences\n * - Side effect divergences\n * - Performance divergences\n * - State management divergences\n * - Error handling divergences\n */\n\nimport { \n  BehaviorDivergenceResult,\n  VerificationSeverity,\n  VerificationFinding \n} from \'../../types\';\n\nexport class BehaviorDivergenceTests {\n  private findings: VerificationFinding[] = [];\n\n  /**\n   * Test behavior divergences in a component\n   */\n  async testBehaviorDivergence(component: string): Promise<BehaviorDivergenceResult> {\n    this.findings = [];\n    \n    // Scan component for behavior divergences\n    await this.scanComponent(component);\n    \n    return {\n      diverged: this.findings.length > 0,\n      divergences: this.extractDivergences()\n    };\n  }\n\n  /**\n   * Scan component for behavior divergences\n   */\n  private async scanComponent(component: string): Promise<void> {\n    // 1. Detect side effect divergences\n    await this.detectSideEffectDivergences(component);\n    \n    // 2. Detect error handling divergences\n    await this.detectErrorHandlingDivergences(component);\n    \n    // 3. Detect state management divergences\n    await this.detectStateManagementDivergences(component);\n    \n    // 4. Detect async behavior divergences\n    await this.detectAsyncBehaviorDivergences(component);\n  }\n\n  /**\n   * Detect side effect divergences\n   */\n  private async detectSideEffectDivergences(component: string): Promise<void> {\n    const componentPath = this.getComponentPath(component);\n    const files = await this.getTsFiles(componentPath);\n\n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // Find pure function declarations (should have no side effects)\n      const pureFunctionMatches = content.matchAll(\n        /\\/\\/\\s*@\\s*pure\\s*\\n\\s*(?:function|const\\s+\\w+\\s*=\\s*)\\s*(\\w+)\\s*\\([^)]*\\)\\s*{([^}]+)}/gs\n      );\n      \n      for (const match of pureFunctionMatches) {\n        const functionName = match[1];\n        const functionBody = match[2];\n        \n        // Check for side effects\n        const sideEffects = this.detectSideEffects(functionBody);\n        \n        if (sideEffects.length > 0) {\n          this.findings.push({\n            id: this.generateId(),\n            type: \'BEHAVIOR_DIVERGENCE\',\n            severity: VerificationSeverity.HIGH,\n            component: file,\n            location: {\n              file,\n              line: this.getLineNumber(content, match.index!),\n              module: component\n            },\n            title: \'Pure Function Side Effect Divergence\',\n            description: `Function \'${functionName}\' is marked as pure but has side effects: ${sideEffects.join(\', \')}`,\n            evidence: [{\n              type: \'code\',\n              source: file,\n              content: functionBody.substring(0, 100),\n              timestamp: new Date(),\n              verified: true\n            }],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Detect error handling divergences\n   */\n  private async detectErrorHandlingDivergences(component: string): Promise<void> {\n    const componentPath = this.getComponentPath(component);\n    const files = await this.getTsFiles(componentPath);\n\n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // Find functions that should throw but don\'t\n      const shouldThrowMatches = content.matchAll(\n        /function\\s+(\\w+)\\s*\\([^)]*\\)\\s*{([^}]*(?:if\\s*\\([^)]*\\)\\s*{[^}]*}))?[^}]*}/gs\n      );\n      \n      for (const match of shouldThrowMatches) {\n        const functionName = match[1];\n        const functionBody = match[2];\n        \n        // Check for potential error scenarios\n        if (this.shouldHaveErrorHandling(functionName, functionBody)) {\n          if (!functionBody.includes(\'throw\') && !functionBody.includes(\'Error\')) {\n            this.findings.push({\n              id: this.generateId(),\n              type: \'BEHAVIOR_DIVERGENCE\',\n              severity: VerificationSeverity.MEDIUM,\n              component: file,\n              location: {\n                file,\n                line: this.getLineNumber(content, match.index!),\n                module: component\n              },\n              title: \'Error Handling Divergence\',\n              description: `Function \'${functionName}\' should have error handling but doesn\'t throw errors`,\n              evidence: [{\n                type: \'code\',\n                source: file,\n                content: functionBody.substring(0, 100),\n                timestamp: new Date(),\n                verified: true\n              }],\n              timestamp: new Date(),\n              verified: false,\n              falsifiable: true\n            });\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Detect state management divergences\n   */\n  private async detectStateManagementDivergences(component: string): Promise<void> {\n    const componentPath = this.getComponentPath(component);\n    const files = await this.getTsFiles(componentPath);\n\n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // Find state mutations\n      const stateMutationMatches = content.matchAll(\n        /(\\w+)\\s*\\.\\s*(\\w+)\\s*=/g\n      );\n      \n      for (const match of stateMutationMatches) {\n        const objectName = match[1];\n        const propertyName = match[2];\n        \n        // Check if state should be immutable\n        if (objectName.toLowerCase().includes(\'state\') || \n            objectName.toLowerCase().includes(\'store\')) {\n          \n          const line = this.getLineNumber(content, match.index!);\n          \n          this.findings.push({\n            id: this.generateId(),\n            type: \'BEHAVIOR_DIVERGENCE\',\n            severity: VerificationSeverity.MEDIUM,\n            component: file,\n            location: {\n              file,\n              line,\n              module: component\n            },\n            title: \'State Mutation Divergence\',\n            description: `Direct mutation of state object \'${objectName}.${propertyName}\' detected - should use immutable updates`,\n            evidence: [{\n              type: \'code\',\n              source: file,\n              content: match[0],\n              timestamp: new Date(),\n              verified: true\n            }],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Detect async behavior divergences\n   */\n  private async detectAsyncBehaviorDivergences(component: string): Promise<void> {\n    const componentPath = this.getComponentPath(component);\n    const files = await this.getTsFiles(componentPath);\n\n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // Find async functions without proper error handling\n      const asyncMatches = content.matchAll(\n        /async\\s+function\\s+(\\w+)\\s*\\(([^)]*)\\)\\s*{([^}]+)}/gs\n      );\n      \n      for (const match of asyncMatches) {\n        const functionName = match[1];\n        const functionBody = match[2];\n        \n        // Check for await without try-catch\n        if (functionBody.includes(\'await\') && \n            !functionBody.includes(\'try\') && \n            !functionBody.includes(\'.catch\')) {\n          \n          this.findings.push({\n            id: this.generateId(),\n            type: \'BEHAVIOR_DIVERGENCE\',\n            severity: VerificationSeverity.HIGH,\n            component: file,\n            location: {\n              file,\n              line: this.getLineNumber(content, match.index!),\n              module: component\n            },\n            title: \'Async Error Handling Divergence\',\n            description: `Async function \'${functionName}\' has await but no try-catch or .catch`,\n            evidence: [{\n              type: \'code\',\n              source: file,\n              content: functionBody.substring(0, 100),\n              timestamp: new Date(),\n              verified: true\n            }],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Detect side effects in function body\n   */\n  private detectSideEffects(functionBody: string): string[] {\n    const sideEffects: string[] = [];\n    \n    if (functionBody.includes(\'console.\')) {\n      sideEffects.push(\'console logging\');\n    }\n    \n    if (functionBody.includes(\'.push(\') || functionBody.includes(\'.pop(\')) {\n      sideEffects.push(\'array mutation\');\n    }\n    \n    if (functionBody.includes(\'.delete(\') || functionBody.includes(\'.set(\')) {\n      sideEffects.push(\'map mutation\');\n    }\n    \n    if (functionBody.includes(\'fetch(\') || functionBody.includes(\'axios.\')) {\n      sideEffects.push(\'network request\');\n    }\n    \n    if (functionBody.includes(\'fs.\') || functionBody.includes(\'readFile\') || functionBody.includes(\'writeFile\')) {\n      sideEffects.push(\'file system operation\');\n    }\n    \n    if (/=\\s*\\w+\\./.test(functionBody)) {\n      sideEffects.push(\'object mutation\');\n    }\n    \n    return sideEffects;\n  }\n\n  /**\n   * Check if function should have error handling\n   */\n  private shouldHaveErrorHandling(functionName: string, functionBody: string): boolean {\n    const nameLower = functionName.toLowerCase();\n    \n    // Functions that should handle errors\n    const errorHandlingFunctions = [\n      \'parse\', \'decode\', \'decrypt\', \'validate\', \'check\', \'verify\',\n      \'fetch\', \'request\', \'get\', \'post\', \'put\', \'delete\',\n      \'connect\', \'open\', \'close\', \'read\', \'write\'\n    ];\n    \n    return errorHandlingFunctions.some(fn => nameLower.includes(fn));\n  }\n\n  /**\n   * Extract divergences from findings\n   */\n  private extractDivergences() {\n    return this.findings.map(finding => ({\n      scenario: finding.title,\n      expectedBehavior: \'Expected behavior as documented\',\n      actualBehavior: finding.description,\n      divergence: finding.type,\n      severity: finding.severity\n    }));\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  private getComponentPath(component: string): string {\n    return `/workspace/gl-runtime-platform/${component}`;\n  }\n\n  private async getTsFiles(path: string): Promise<string[]> {\n    const { exec } = require(\'child_process\');\n    return new Promise((resolve, reject) => {\n      exec(`find ${path} -type f -name "*.ts"`, (error, stdout) => {\n        if (error) reject(error);\n        else resolve(stdout.trim().split(\'\\n\').filter(f => f));\n      });\n    });\n  }\n\n  private async readFileContent(filePath: string): Promise<string> {\n    const fs = require(\'fs\').promises;\n    return fs.readFile(filePath, \'utf-8\');\n  }\n\n  private getLineNumber(content: string, index: number): number {\n    return content.substring(0, index).split(\'\\n\').length;\n  }\n\n  private generateId(): string {\n    return `behavior-divergence-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n</create-file>\n</function_calls>'}