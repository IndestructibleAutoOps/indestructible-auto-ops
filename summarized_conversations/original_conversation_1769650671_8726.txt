{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="gl-runtime-platform/unified-intelligence-fabric/fabric-algo/index.ts">\n// @GL-governed\n// @GL-layer: GL90-99\n// @GL-semantic: runtime-fabric-algo\n// @GL-charter-version: 4.0.0\n// @GL-audit-trail: ../../engine/governance/GL_SEMANTIC_ANCHOR.json\n\n/**\n * GL Unified Intelligence Fabric - Fabric Algo\n * Version 19.0.0\n * \n * 核心：演算法視角\n * - 織網上的「轉換規則集」\n * - 演算法在織網上流動與應用\n * - 動態演算法選擇與優化\n * - 演算法演化與自適應\n */\n\nimport { FabricCore, FabricNode, FabricEdge } from \'../fabric-core\';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\nexport interface Algorithm {\n  id: string;\n  name: string;\n  type: AlgorithmType;\n  category: AlgorithmCategory;\n  description: string;\n  implementation: AlgorithmImplementation;\n  parameters: AlgorithmParameter[];\n  constraints: AlgorithmConstraints;\n  performance: AlgorithmPerformance;\n  version: string;\n}\n\nexport type AlgorithmType = \n  | \'transformation\'  // 轉換演算法\n  | \'inference\'       // 推理演算法\n  | \'optimization\'    // 優化演算法\n  | \'search\'          // 搜尋演算法\n  | \'pattern_match\'   // 模式匹配演算法\n  | \'reasoning\'       // 推理演算法\n  | \'learning\'        // 學習演算法\n  | \'evolution\';      // 演化演算法\n\nexport type AlgorithmCategory = \n  | \'graph\'           // 圖演算法\n  | \'semantic\'        // 語意演算法\n  | \'statistical\'     // 統計演算法\n  | \'neural\'          // 神經網路演算法\n  | \'symbolic\'        // 符號演算法\n  | \'probabilistic\';  // 概率演算法\n\nexport interface AlgorithmImplementation {\n  type: \'function\' | \'flow\' | \'pipeline\' | \'composite\';\n  definition: any;\n  dependencies: string[];\n  computeRequirements: {\n    cpuCores: number;\n    memory: number;\n    estimatedDuration: number;\n  };\n}\n\nexport interface AlgorithmParameter {\n  name: string;\n  type: \'number\' | \'string\' | \'boolean\' | \'array\' | \'object\';\n  default: any;\n  range?: [number, number];\n  description: string;\n  required: boolean;\n}\n\nexport interface AlgorithmConstraints {\n  minInputSize?: number;\n  maxInputSize?: number;\n  supportedNodeTypes?: string[];\n  supportedEdgeTypes?: string[];\n  requiresSuperposition?: boolean;\n}\n\nexport interface AlgorithmPerformance {\n  averageRuntime: number;\n  successRate: number;\n  accuracy: number;\n  resourceUsage: {\n    cpu: number;\n    memory: number;\n  };\n  lastExecuted: number;\n}\n\nexport interface AlgorithmExecution {\n  id: string;\n  algorithmId: string;\n  input: any;\n  parameters: Record<string, any>;\n  startTime: number;\n  endTime?: number;\n  status: \'pending\' | \'running\' | \'completed\' | \'failed\';\n  result?: any;\n  error?: Error;\n  performance: {\n    runtime: number;\n    resourceUsage: {\n      cpu: number;\n      memory: number;\n    };\n  };\n}\n\nexport interface AlgoConfig {\n  enableAutoSelection: boolean;\n  enableAutoTuning: boolean;\n  enableCaching: boolean;\n  maxConcurrentExecutions: number;\n}\n\n// ============================================================================\n// Fabric Algo Class\n// ============================================================================\n\nexport class FabricAlgo {\n  private fabric: FabricCore;\n  private config: AlgoConfig;\n  private algorithms: Map<string, Algorithm>;\n  private executions: Map<string, AlgorithmExecution>;\n  private algorithmRegistry: AlgorithmRegistry;\n  private executionEngine: AlgorithmExecutionEngine;\n  private performanceTracker: PerformanceTracker;\n  private initialized: boolean;\n  \n  constructor(fabric: FabricCore, config?: Partial<AlgoConfig>) {\n    this.fabric = fabric;\n    this.config = {\n      enableAutoSelection: config?.enableAutoSelection ?? true,\n      enableAutoTuning: config?.enableAutoTuning ?? true,\n      enableCaching: config?.enableCaching ?? true,\n      maxConcurrentExecutions: config?.maxConcurrentExecutions || 10\n    };\n    \n    this.algorithms = new Map();\n    this.executions = new Map();\n    this.algorithmRegistry = new AlgorithmRegistry(this);\n    this.executionEngine = new AlgorithmExecutionEngine(this);\n    this.performanceTracker = new PerformanceTracker(this);\n    this.initialized = false;\n  }\n  \n  async initialize(): Promise<void> {\n    console.log(\'[Fabric Algo] Initializing algorithm layer...\');\n    \n    // 註冊預設演算法\n    await this.registerDefaultAlgorithms();\n    \n    // 初始化執行引擎\n    await this.executionEngine.initialize();\n    \n    // 初始化性能追蹤器\n    await this.performanceTracker.initialize();\n    \n    this.initialized = true;\n    console.log(\'[Fabric Algo] Algorithm layer initialized\');\n  }\n  \n  // ========================================================================\n  // Algorithm Registration\n  // ========================================================================\n  \n  async registerAlgorithm(algorithm: Algorithm): Promise<void> {\n    console.log(`[Fabric Algo] Registering algorithm ${algorithm.name} (${algorithm.id})`);\n    \n    // 驗證演算法\n    await this.validateAlgorithm(algorithm);\n    \n    // 註冊演算法\n    this.algorithms.set(algorithm.id, algorithm);\n    \n    // 更新註冊表\n    await this.algorithmRegistry.register(algorithm);\n  }\n  \n  async unregisterAlgorithm(algorithmId: string): Promise<void> {\n    console.log(`[Fabric Algo] Unregistering algorithm ${algorithmId}`);\n    \n    this.algorithms.delete(algorithmId);\n    await this.algorithmRegistry.unregister(algorithmId);\n  }\n  \n  async getAlgorithm(algorithmId: string): Promise<Algorithm | undefined> {\n    return this.algorithms.get(algorithmId);\n  }\n  \n  async getAllAlgorithms(): Promise<Algorithm[]> {\n    return Array.from(this.algorithms.values());\n  }\n  \n  async queryAlgorithms(filter: {\n    type?: AlgorithmType;\n    category?: AlgorithmCategory;\n    nodeType?: string;\n    edgeType?: string;\n  }): Promise<Algorithm[]> {\n    let results = Array.from(this.algorithms.values());\n    \n    if (filter.type) {\n      results = results.filter(a => a.type === filter.type);\n    }\n    \n    if (filter.category) {\n      results = results.filter(a => a.category === filter.category);\n    }\n    \n    if (filter.nodeType && filter.nodeType !== \'all\') {\n      results = results.filter(a => \n        a.constraints.supportedNodeTypes?.includes(filter.nodeType!)\n      );\n    }\n    \n    if (filter.edgeType && filter.edgeType !== \'all\') {\n      results = results.filter(a => \n        a.constraints.supportedEdgeTypes?.includes(filter.edgeType!)\n      );\n    }\n    \n    return results;\n  }\n  \n  private async validateAlgorithm(algorithm: Algorithm): Promise<void> {\n    // 驗證必需欄位\n    if (!algorithm.id || !algorithm.name || !algorithm.type || !algorithm.implementation) {\n      throw new Error(\'Invalid algorithm: missing required fields\');\n    }\n    \n    // 驗證實作\n    if (!algorithm.implementation.definition) {\n      throw new Error(\'Invalid algorithm: missing implementation definition\');\n    }\n  }\n  \n  // ========================================================================\n  // Algorithm Execution\n  // ========================================================================\n  \n  async executeAlgorithm(\n    algorithmId: string,\n    input: any,\n    parameters?: Record<string, any>\n  ): Promise<AlgorithmExecution> {\n    console.log(`[Fabric Algo] Executing algorithm ${algorithmId}`);\n    \n    const algorithm = this.algorithms.get(algorithmId);\n    \n    if (!algorithm) {\n      throw new Error(`Algorithm ${algorithmId} not found`);\n    }\n    \n    // 創建執行記錄\n    const execution: AlgorithmExecution = {\n      id: `exec-${algorithmId}-${Date.now()}`,\n      algorithmId,\n      input,\n      parameters: parameters || {},\n      startTime: Date.now(),\n      status: \'pending\',\n      performance: {\n        runtime: 0,\n        resourceUsage: { cpu: 0, memory: 0 }\n      }\n    };\n    \n    this.executions.set(execution.id, execution);\n    \n    // 執行演算法\n    execution.status = \'running\';\n    \n    try {\n      const startTime = Date.now();\n      \n      // 執行演算法實作\n      const result = await this.executionEngine.execute(algorithm, input, parameters || {});\n      \n      execution.endTime = Date.now();\n      execution.status = \'completed\';\n      execution.result = result;\n      execution.performance.runtime = execution.endTime - startTime;\n      \n      // 更新性能追蹤\n      await this.performanceTracker.trackExecution(algorithmId, execution);\n      \n      // 更新演算法性能統計\n      algorithm.performance.averageRuntime = \n        (algorithm.performance.averageRuntime + execution.performance.runtime) / 2;\n      algorithm.performance.lastExecuted = Date.now();\n      \n    } catch (error) {\n      execution.endTime = Date.now();\n      execution.status = \'failed\';\n      execution.error = error as Error;\n      \n      // 更新失敗率\n      algorithm.performance.successRate = \n        (algorithm.performance.successRate * 9) / 10; // 降低成功率\n    }\n    \n    console.log(`[Fabric Algo] Algorithm ${algorithmId} execution completed with status ${execution.status}`);\n    return execution;\n  }\n  \n  async getExecution(executionId: string): Promise<AlgorithmExecution | undefined> {\n    return this.executions.get(executionId);\n  }\n  \n  async getExecutions(filter?: {\n    algorithmId?: string;\n    status?: string;\n    since?: number;\n  }): Promise<AlgorithmExecution[]> {\n    let results = Array.from(this.executions.values());\n    \n    if (filter?.algorithmId) {\n      results = results.filter(e => e.algorithmId === filter.algorithmId);\n    }\n    \n    if (filter?.status) {\n      results = results.filter(e => e.status === filter.status);\n    }\n    \n    if (filter?.since) {\n      results = results.filter(e => e.startTime >= filter.since!);\n    }\n    \n    return results;\n  }\n  \n  // ========================================================================\n  // Auto-Selection and Auto-Tuning\n  // ========================================================================\n  \n  async selectBestAlgorithm(\n    input: any,\n    requirements: {\n      type?: AlgorithmType;\n      category?: AlgorithmCategory;\n      priority?: \'speed\' | \'accuracy\' | \'resource_efficiency\';\n    }\n  ): Promise<Algorithm | undefined> {\n    if (!this.config.enableAutoSelection) {\n      return undefined;\n    }\n    \n    console.log(\'[Fabric Algo] Auto-selecting best algorithm...\');\n    \n    // 查詢候選演算法\n    const candidates = await this.queryAlgorithms({\n      type: requirements.type,\n      category: requirements.category\n    });\n    \n    if (candidates.length === 0) {\n      return undefined;\n    }\n    \n    // 根據優先級評分\n    const priority = requirements.priority || \'accuracy\';\n    \n    const scored = candidates.map(algo => ({\n      algorithm: algo,\n      score: this.calculateScore(algo, priority)\n    }));\n    \n    // 選擇最高分\n    scored.sort((a, b) => b.score - a.score);\n    \n    return scored[0]?.algorithm;\n  }\n  \n  private calculateScore(algorithm: Algorithm, priority: string): number {\n    let score = 0;\n    \n    switch (priority) {\n      case \'speed\':\n        // 優先選擇執行時間短\n        score += (1 / (algorithm.performance.averageRuntime + 1)) * 0.5;\n        score += algorithm.performance.successRate * 0.3;\n        score += algorithm.performance.resourceUsage.cpu * -0.1;\n        score += algorithm.performance.resourceUsage.memory * -0.1;\n        break;\n        \n      case \'accuracy\':\n        // 優先選擇準確度高\n        score += algorithm.performance.accuracy * 0.5;\n        score += algorithm.performance.successRate * 0.3;\n        score += (1 / (algorithm.performance.averageRuntime + 1)) * 0.1;\n        score += algorithm.performance.resourceUsage.cpu * -0.05;\n        break;\n        \n      case \'resource_efficiency\':\n        // 優先選擇資源使用少\n        score += (1 - algorithm.performance.resourceUsage.cpu) * 0.4;\n        score += (1 - algorithm.performance.resourceUsage.memory) * 0.4;\n        score += algorithm.performance.successRate * 0.1;\n        score += (1 / (algorithm.performance.averageRuntime + 1)) * 0.1;\n        break;\n    }\n    \n    return score;\n  }\n  \n  async tuneAlgorithm(algorithmId: string): Promise<void> {\n    if (!this.config.enableAutoTuning) {\n      return;\n    }\n    \n    console.log(`[Fabric Algo] Auto-tuning algorithm ${algorithmId}`);\n    \n    const algorithm = this.algorithms.get(algorithmId);\n    if (!algorithm) {\n      throw new Error(`Algorithm ${algorithmId} not found`);\n    }\n    \n    // 獲取歷史執行數據\n    const executions = await this.getExecutions({ algorithmId });\n    \n    if (executions.length < 5) {\n      console.log(`[Fabric Algo] Not enough execution data for tuning`);\n      return;\n    }\n    \n    // 簡化實作：調整參數\n    for (const param of algorithm.parameters) {\n      if (param.type === \'number\' && param.range) {\n        // 基於歷史表現調整參數\n        const avgRuntime = executions.reduce((sum, e) => sum + e.performance.runtime, 0) / executions.length;\n        \n        if (avgRuntime > algorithm.performance.averageRuntime * 1.5) {\n          // 執行慢，降低參數值\n          param.default = Math.max(param.range[0], param.default * 0.9);\n        } else if (avgRuntime < algorithm.performance.averageRuntime * 0.8) {\n          // 執行快，提高參數值\n          param.default = Math.min(param.range[1], param.default * 1.1);\n        }\n      }\n    }\n    \n    console.log(`[Fabric Algo] Algorithm ${algorithmId} tuned`);\n  }\n  \n  // ========================================================================\n  // Statistics\n  // ========================================================================\n  \n  async getStatistics(): Promise<AlgoStatistics> {\n    const algorithms = Array.from(this.algorithms.values());\n    const executions = Array.from(this.executions.values());\n    \n    return {\n      totalAlgorithms: algorithms.length,\n      totalExecutions: executions.length,\n      successfulExecutions: executions.filter(e => e.status === \'completed\').length,\n      failedExecutions: executions.filter(e => e.status === \'failed\').length,\n      averageExecutionTime: executions.reduce((sum, e) => sum + e.performance.runtime, 0) / executions.length || 0,\n      algorithmTypes: this.groupByType(algorithms)\n    };\n  }\n  \n  private groupByType(algorithms: Algorithm[]): Record<AlgorithmType, number> {\n    const counts = {} as Record<AlgorithmType, number>;\n    \n    for (const algo of algorithms) {\n      counts[algo.type] = (counts[algo.type] || 0) + 1;\n    }\n    \n    return counts;\n  }\n  \n  private async registerDefaultAlgorithms(): Promise<void> {\n    // 註冊預設演算法\n    \n    // 1. 節點轉換演算法\n    await this.registerAlgorithm({\n      id: \'algo-node-transform\',\n      name: \'Node Transformation\',\n      type: \'transformation\',\n      category: \'graph\',\n      description: \'Transform node properties\',\n      implementation: {\n        type: \'function\',\n        definition: async (node: FabricNode, params: any) => {\n          return {\n            ...node,\n            properties: { ...node.properties, ...params }\n          };\n        },\n        dependencies: [],\n        computeRequirements: { cpuCores: 1, memory: 128, estimatedDuration: 100 }\n      },\n      parameters: [\n        {\n          name: \'transform\',\n          type: \'object\',\n          default: {},\n          description: \'Transformations to apply\',\n          required: false\n        }\n      ],\n      constraints: {},\n      performance: {\n        averageRuntime: 100,\n        successRate: 0.95,\n        accuracy: 0.9,\n        resourceUsage: { cpu: 0.1, memory: 0.05 },\n        lastExecuted: 0\n      },\n      version: \'1.0.0\'\n    });\n    \n    // 2. 路徑搜尋演算法\n    await this.registerAlgorithm({\n      id: \'algo-path-search\',\n      name: \'Path Search\',\n      type: \'search\',\n      category: \'graph\',\n      description: \'Search for paths between nodes\',\n      implementation: {\n        type: \'function\',\n        definition: async (source: string, target: string, params: any) => {\n          return { path: [source, target], distance: 1 };\n        },\n        dependencies: [],\n        computeRequirements: { cpuCores: 2, memory: 256, estimatedDuration: 500 }\n      },\n      parameters: [\n        {\n          name: \'maxDepth\',\n          type: \'number\',\n          default: 10,\n          range: [1, 100],\n          description: \'Maximum search depth\',\n          required: false\n        }\n      ],\n      constraints: {},\n      performance: {\n        averageRuntime: 500,\n        successRate: 0.9,\n        accuracy: 0.85,\n        resourceUsage: { cpu: 0.2, memory: 0.1 },\n        lastExecuted: 0\n      },\n      version: \'1.0.0\'\n    });\n    \n    // 3. 模式匹配演算法\n    await this.registerAlgorithm({\n      id: \'algo-pattern-match\',\n      name: \'Pattern Matching\',\n      type: \'pattern_match\',\n      category: \'graph\',\n      description: \'Match patterns in the graph\',\n      implementation: {\n        type: \'function\',\n        definition: async (pattern: any, params: any) => {\n          return { matches: [], count: 0 };\n        },\n        dependencies: [],\n        computeRequirements: { cpuCores: 4, memory: 512, estimatedDuration: 1000 }\n      },\n      parameters: [\n        {\n          name: \'similarityThreshold\',\n          type: \'number\',\n          default: 0.8,\n          range: [0, 1],\n          description: \'Minimum similarity threshold\',\n          required: false\n        }\n      ],\n      constraints: {},\n      performance: {\n        averageRuntime: 1000,\n        successRate: 0.85,\n        accuracy: 0.8,\n        resourceUsage: { cpu: 0.4, memory: 0.2 },\n        lastExecuted: 0\n      },\n      version: \'1.0.0\'\n    });\n    \n    console.log(\'[Fabric Algo] Registered 3 default algorithms\');\n  }\n  \n  isInitialized(): boolean {\n    return this.initialized;\n  }\n}\n\n// ============================================================================\n// Algorithm Registry\n// ============================================================================\n\nclass AlgorithmRegistry {\n  private byType: Map<AlgorithmType, Set<string>>;\n  private byCategory: Map<AlgorithmCategory, Set<string>>;\n  \n  constructor(private algo: FabricAlgo) {\n    this.byType = new Map();\n    this.byCategory = new Map();\n  }\n  \n  async register(algorithm: Algorithm): Promise<void> {\n    // 按類型註冊\n    if (!this.byType.has(algorithm.type)) {\n      this.byType.set(algorithm.type, new Set());\n    }\n    this.byType.get(algorithm.type)!.add(algorithm.id);\n    \n    // 按類別註冊\n    if (!this.byCategory.has(algorithm.category)) {\n      this.byCategory.set(algorithm.category, new Set());\n    }\n    this.byCategory.get(algorithm.category)!.add(algorithm.id);\n  }\n  \n  async unregister(algorithmId: string): Promise<void> {\n    // 從類型映射中移除\n    for (const [type, ids] of this.byType) {\n      ids.delete(algorithmId);\n    }\n    \n    // 從類別映射中移除\n    for (const [category, ids] of this.byCategory) {\n      ids.delete(algorithmId);\n    }\n  }\n}\n\n// ============================================================================\n// Algorithm Execution Engine\n// ============================================================================\n\nclass AlgorithmExecutionEngine {\n  constructor(private algo: FabricAlgo) {}\n  \n  async initialize(): Promise<void> {\n    console.log(\'[Execution Engine] Initializing...\');\n  }\n  \n  async execute(algorithm: Algorithm, input: any, parameters: Record<string, any>): Promise<any> {\n    // 執行演算法實作\n    if (algorithm.implementation.type === \'function\') {\n      return await algorithm.implementation.definition(input, parameters);\n    }\n    \n    // 其他類型的實作（flow, pipeline, composite）可以在這裡處理\n    throw new Error(`Unsupported implementation type: ${algorithm.implementation.type}`);\n  }\n}\n\n// ============================================================================\n// Performance Tracker\n// ============================================================================\n\nclass PerformanceTracker {\n  private executionHistory: Map<string, number[]>;\n  \n  constructor(private algo: FabricAlgo) {\n    this.executionHistory = new Map();\n  }\n  \n  async initialize(): Promise<void> {\n    console.log(\'[Performance Tracker] Initializing...\');\n  }\n  \n  async trackExecution(algorithmId: string, execution: AlgorithmExecution): Promise<void> {\n    if (!this.executionHistory.has(algorithmId)) {\n      this.executionHistory.set(algorithmId, []);\n    }\n    \n    const history = this.executionHistory.get(algorithmId)!;\n    history.push(execution.performance.runtime);\n    \n    // 只保留最近 100 次執行\n    if (history.length > 100) {\n      history.shift();\n    }\n  }\n  \n  async getAverageRuntime(algorithmId: string): Promise<number> {\n    const history = this.executionHistory.get(algorithmId);\n    \n    if (!history || history.length === 0) {\n      return 0;\n    }\n    \n    return history.reduce((sum, time) => sum + time, 0) / history.length;\n  }\n}\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\nexport interface AlgoStatistics {\n  totalAlgorithms: number;\n  totalExecutions: number;\n  successfulExecutions: number;\n  failedExecutions: number;\n  averageExecutionTime: number;\n  algorithmTypes: Record<AlgorithmType, number>;\n}\n</create-file>\n</function_calls>'}