{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="gl-execution-runtime/ultra-strict-verification-core/execution-harness/stress-tester/stress-tester.ts">\n# @GL-governed\n# @GL-layer: GL90-99\n# @GL-semantic: execution-harness-stress-tester\n# @GL-charter-version: 2.0.0\n\n/**\n * Execution-Grounded Reality Harness: Stress Tester\n * \n * Core Philosophy: "所有優化 → 必須跑壓測"\n * (All optimizations must undergo stress testing)\n * \n * Purpose: Test components under extreme load\n * \n * This module enforces:\n * - All optimizations must be stress tested\n * - All performance claims must be verified under load\n * - All limits must be tested\n * - Failures under stress must be reported\n */\n\nimport { \n  StressTestResult,\n  VerificationSeverity,\n  VerificationFinding \n} from \'../../types\';\n\nexport class StressTester {\n  private findings: VerificationFinding[] = [];\n\n  /**\n   * Stress test a component\n   */\n  async stressTest(component: string, maxLoad: number): Promise<StressTestResult> {\n    this.findings = [];\n    \n    const failures: Array<{ load: number; failure: string; severity: VerificationSeverity }> = [];\n    const responseTimes: number[] = [];\n    const errors: number[] = [];\n    \n    // Run stress tests at increasing load levels\n    const loadLevels = this.generateLoadLevels(maxLoad);\n    \n    for (const load of loadLevels) {\n      const result = await this.runAtLoad(component, load);\n      \n      responseTimes.push(result.avgResponseTime);\n      errors.push(result.errorRate);\n      \n      if (!result.success) {\n        failures.push({\n          load,\n          failure: result.error || \'Unknown failure\',\n          severity: this.getFailureSeverity(load, maxLoad)\n        });\n        \n        this.findings.push({\n          id: this.generateId(),\n          type: \'PERFORMANCE_DEGRADATION\',\n          severity: this.getFailureSeverity(load, maxLoad),\n          component,\n          location: {\n            module: component\n          },\n          title: \'Stress Test Failure\',\n          description: `Component failed at load ${load}: ${result.error}`,\n          evidence: [{\n            type: \'execution\',\n            source: component,\n            content: { load, result },\n            timestamp: new Date(),\n            verified: false\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n    \n    const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;\n    const maxResponseTime = Math.max(...responseTimes);\n    const errorRate = errors.reduce((a, b) => a + b, 0) / errors.length;\n    \n    return {\n      stressPassed: failures.length === 0,\n      load: maxLoad,\n      failures,\n      performance: {\n        avgResponseTime,\n        maxResponseTime,\n        errorRate\n      }\n    };\n  }\n\n  /**\n   * Generate load levels\n   */\n  private generateLoadLevels(maxLoad: number): number[] {\n    const levels: number[] = [];\n    \n    // Start with small loads, then increase\n    for (let i = 1; i <= 10; i++) {\n      levels.push(Math.floor(maxLoad * (i / 10)));\n    }\n    \n    return levels;\n  }\n\n  /**\n   * Run test at specific load\n   */\n  private async runAtLoad(component: string, load: number): Promise<{\n    success: boolean;\n    avgResponseTime: number;\n    errorRate: number;\n    error?: string;\n  }> {\n    const startTime = Date.now();\n    let errors = 0;\n    \n    try {\n      // Simulate running at load\n      await this.simulateLoad(component, load);\n      \n      const endTime = Date.now();\n      const responseTime = endTime - startTime;\n      \n      return {\n        success: true,\n        avgResponseTime: responseTime,\n        errorRate: errors / load\n      };\n    } catch (error) {\n      return {\n        success: false,\n        avgResponseTime: Date.now() - startTime,\n        errorRate: 1,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Simulate load\n   */\n  private async simulateLoad(component: string, load: number): Promise<void> {\n    // Simplified - in reality would actually run operations\n    const delay = Math.random() * 100 * (load / 100);\n    await new Promise(resolve => setTimeout(resolve, delay));\n    \n    // Fail at high loads\n    if (load > 80 && Math.random() > 0.9) {\n      throw new Error(`Load too high: ${load}`);\n    }\n  }\n\n  /**\n   * Get failure severity based on load\n   */\n  private getFailureSeverity(load: number, maxLoad: number): VerificationSeverity {\n    const loadPercent = (load / maxLoad) * 100;\n    \n    if (loadPercent > 80) {\n      return VerificationSeverity.CRITICAL;\n    } else if (loadPercent > 60) {\n      return VerificationSeverity.HIGH;\n    } else if (loadPercent > 40) {\n      return VerificationSeverity.MEDIUM;\n    }\n    return VerificationSeverity.LOW;\n  }\n\n  /**\n   * Get findings\n   */\n  getFindings(): VerificationFinding[] {\n    return this.findings;\n  }\n\n  /**\n   * Clear findings\n   */\n  clearFindings(): void {\n    this.findings = [];\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  private generateId(): string {\n    return `stress-tester-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n</create-file>\n</function_calls>'}