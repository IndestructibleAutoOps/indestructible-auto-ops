{'role': 'assistant', 'content': '繼續實作 Execution-Harness，創建 **Oracle Validator**、**Stress Tester**、**Fuzzing Engine** 和 **Regression Diff**：\n\n<function_calls>\n<create-file file_path="gl-runtime-platform/ultra-strict-verification-core/execution-harness/oracle-validator/oracle-validator.ts">\n# @GL-governed\n# @GL-layer: GL90-99\n# @GL-semantic: execution-harness-oracle-validator\n# @GL-charter-version: 2.0.0\n\n/**\n * Execution-Grounded Reality Harness: Oracle Validator\n * \n * Core Philosophy: "所有結論 → 必須經過反例測試"\n * (All conclusions must be tested with counterexamples)\n * \n * Purpose: Validate system behavior against trusted oracles\n * \n * This module enforces:\n * - All behavior must be validated against oracles\n * - All outputs must be checked against oracle predictions\n * - All edge cases must be covered by oracles\n * - Oracle violations must be critical findings\n */\n\nimport { \n  OracleValidationResult,\n  VerificationSeverity,\n  VerificationFinding \n} from \'../../types\';\n\nexport class OracleValidator {\n  private findings: VerificationFinding[] = [];\n  private oracles: Map<string, any> = new Map();\n\n  /**\n   * Validate against oracle\n   */\n  async validateOracle(component: string, oracle: string): Promise<OracleValidationResult> {\n    this.findings = [];\n    \n    // Load oracle\n    const oracleData = await this.loadOracle(oracle);\n    \n    if (!oracleData) {\n      this.findings.push({\n        id: this.generateId(),\n        type: \'INCONSISTENCY\',\n        severity: VerificationSeverity.HIGH,\n        component,\n        location: {\n          module: component\n        },\n        title: \'Oracle Not Found\',\n        description: `Oracle \'${oracle}\' not found - cannot validate`,\n        evidence: [{\n          type: \'oracle\',\n          source: oracle,\n          content: { oracle, status: \'not found\' },\n          timestamp: new Date(),\n          verified: false\n        }],\n        timestamp: new Date(),\n        verified: false,\n        falsifiable: true\n      });\n      \n      return {\n        oracleValidated: false,\n        violations: this.extractViolations()\n      };\n    }\n    \n    // Validate component against oracle\n    await this.validateAgainstOracle(component, oracleData);\n    \n    return {\n      oracleValidated: this.findings.length === 0,\n      violations: this.extractViolations()\n    };\n  }\n\n  /**\n   * Load oracle\n   */\n  private async loadOracle(oracle: string): Promise<any | null> {\n    // Check if oracle is already loaded\n    if (this.oracles.has(oracle)) {\n      return this.oracles.get(oracle);\n    }\n    \n    // Try to load from file\n    const oraclePath = this.getOraclePath(oracle);\n    \n    try {\n      const fs = require(\'fs\').promises;\n      const content = await fs.readFile(oraclePath, \'utf-8\');\n      const oracleData = JSON.parse(content);\n      \n      this.oracles.set(oracle, oracleData);\n      return oracleData;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Validate component against oracle\n   */\n  private async validateAgainstOracle(component: string, oracle: any): Promise<void> {\n    // Get component implementation\n    const componentPath = this.getComponentPath(component);\n    const files = await this.getTsFiles(componentPath);\n\n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // Validate functions against oracle\n      await this.validateFunctionsAgainstOracle(file, content, oracle);\n      \n      // Validate classes against oracle\n      await this.validateClassesAgainstOracle(file, content, oracle);\n    }\n  }\n\n  /**\n   * Validate functions against oracle\n   */\n  private async validateFunctionsAgainstOracle(file: string, content: string, oracle: any): Promise<void> {\n    if (!oracle.functions) return;\n\n    for (const functionName of Object.keys(oracle.functions)) {\n      const functionOracle = oracle.functions[functionName];\n      \n      // Find function in code\n      const functionMatch = content.match(\n        new RegExp(`function\\\\s+${functionName}\\\\s*\\\\([^)]*\\\\)\\\\s*{([^}]*(?:{[^}]*}[^}]*)*)?}`, \'s\')\n      );\n      \n      if (!functionMatch) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'INCONSISTENCY\',\n          severity: VerificationSeverity.HIGH,\n          component: file,\n          location: {\n            file,\n            module: file\n          },\n          title: \'Function Missing\',\n          description: `Function \'${functionName}\' specified in oracle but not found in implementation`,\n          evidence: [{\n            type: \'oracle\',\n            source: \'oracle\',\n            content: functionOracle,\n            timestamp: new Date(),\n            verified: false\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n        continue;\n      }\n      \n      // Validate function signature\n      if (functionOracle.signature) {\n        const actualSignature = functionMatch[0].split(\'{\')[0];\n        if (!this.matchesSignature(actualSignature, functionOracle.signature)) {\n          this.findings.push({\n            id: this.generateId(),\n            type: \'INCONSISTENCY\',\n            severity: VerificationSeverity.HIGH,\n            component: file,\n            location: {\n              file,\n              line: this.getLineNumber(content, functionMatch.index!),\n              module: file\n            },\n            title: \'Function Signature Mismatch\',\n            description: `Function \'${functionName}\' signature does not match oracle`,\n            evidence: [\n              {\n                type: \'oracle\',\n                source: \'oracle\',\n                content: { expected: functionOracle.signature, actual: actualSignature },\n                timestamp: new Date(),\n                verified: false\n              },\n              {\n                type: \'code\',\n                source: file,\n                content: actualSignature,\n                timestamp: new Date(),\n                verified: true\n              }\n            ],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n      \n      // Validate function behavior\n      if (functionOracle.behavior) {\n        const functionBody = functionMatch[1];\n        \n        if (functionOracle.behavior.throws && !functionBody.includes(\'throw\')) {\n          this.findings.push({\n            id: this.generateId(),\n            type: \'INCONSISTENCY\',\n            severity: VerificationSeverity.HIGH,\n            component: file,\n            location: {\n              file,\n              line: this.getLineNumber(content, functionMatch.index!),\n              module: file\n            },\n            title: \'Oracle Behavior Violation\',\n            description: `Function \'${functionName}\' should throw according to oracle but doesn\'t`,\n            evidence: [\n              {\n                type: \'oracle\',\n                source: \'oracle\',\n                content: functionOracle,\n                timestamp: new Date(),\n                verified: false\n              },\n              {\n                type: \'code\',\n                source: file,\n                content: functionBody.substring(0, 100),\n                timestamp: new Date(),\n                verified: true\n              }\n            ],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Validate classes against oracle\n   */\n  private async validateClassesAgainstOracle(file: string, content: string, oracle: any): Promise<void> {\n    if (!oracle.classes) return;\n\n    for (const className of Object.keys(oracle.classes)) {\n      const classOracle = oracle.classes[className];\n      \n      // Find class in code\n      const classMatch = content.match(\n        new RegExp(`class\\\\s+${className}\\\\s*\\\\{([^}]+)}`, \'s\')\n      );\n      \n      if (!classMatch) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'INCONSISTENCY\',\n          severity: VerificationSeverity.HIGH,\n          component: file,\n          location: {\n            file,\n            module: file\n          },\n          title: \'Class Missing\',\n          description: `Class \'${className}\' specified in oracle but not found in implementation`,\n          evidence: [{\n            type: \'oracle\',\n            source: \'oracle\',\n            content: classOracle,\n            timestamp: new Date(),\n            verified: false\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n        continue;\n      }\n      \n      // Validate class methods\n      if (classOracle.methods) {\n        for (const methodName of Object.keys(classOracle.methods)) {\n          const methodOracle = classOracle.methods[methodName];\n          \n          const methodMatch = content.match(\n            new RegExp(`${methodName}\\\\s*\\\\([^)]*\\\\)\\\\s*{([^}]*)}`)\n          );\n          \n          if (!methodMatch) {\n            this.findings.push({\n              id: this.generateId(),\n              type: \'INCONSISTENCY\',\n              severity: VerificationSeverity.HIGH,\n              component: file,\n              location: {\n                file,\n                module: file\n              },\n              title: \'Method Missing\',\n              description: `Method \'${className}.${methodName}\' specified in oracle but not found in implementation`,\n              evidence: [{\n                type: \'oracle\',\n                source: \'oracle\',\n                content: methodOracle,\n                timestamp: new Date(),\n                verified: false\n              }],\n              timestamp: new Date(),\n              verified: false,\n              falsifiable: true\n            });\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if signature matches\n   */\n  private matchesSignature(actual: string, expected: string): boolean {\n    // Simplified signature matching\n    const normalizedActual = actual.replace(/\\s+/g, \'\').toLowerCase();\n    const normalizedExpected = expected.replace(/\\s+/g, \'\').toLowerCase();\n    return normalizedActual === normalizedExpected;\n  }\n\n  /**\n   * Extract violations from findings\n   */\n  private extractViolations() {\n    return this.findings.map(finding => ({\n      oracle: finding.location.file,\n      expected: finding.evidence[0]?.content,\n      actual: finding.evidence[1]?.content,\n      violation: finding.description,\n      severity: finding.severity\n    }));\n  }\n\n  /**\n   * Set oracle\n   */\n  setOracle(oracle: string, oracleData: any): void {\n    this.oracles.set(oracle, oracleData);\n  }\n\n  /**\n   * Save oracle to file\n   */\n  async saveOracle(oracle: string, oracleData: any): Promise<void> {\n    const oraclePath = this.getOraclePath(oracle);\n    const fs = require(\'fs\').promises;\n    \n    await fs.writeFile(oraclePath, JSON.stringify(oracleData, null, 2), \'utf-8\');\n    this.oracles.set(oracle, oracleData);\n  }\n\n  /**\n   * Get oracle path\n   */\n  private getOraclePath(oracle: string): string {\n    return `/workspace/gl-runtime-platform/.oracles/${oracle}.json`;\n  }\n\n  /**\n   * Get findings\n   */\n  getFindings(): VerificationFinding[] {\n    return this.findings;\n  }\n\n  /**\n   * Clear findings\n   */\n  clearFindings(): void {\n    this.findings = [];\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  private getComponentPath(component: string): string {\n    return `/workspace/gl-runtime-platform/${component}`;\n  }\n\n  private async getTsFiles(path: string): Promise<string[]> {\n    const { exec } = require(\'child_process\');\n    return new Promise((resolve, reject) => {\n      exec(`find ${path} -type f -name "*.ts"`, (error, stdout) => {\n        if (error) reject(error);\n        else resolve(stdout.trim().split(\'\\n\').filter(f => f));\n      });\n    });\n  }\n\n  private async readFileContent(filePath: string): Promise<string> {\n    const fs = require(\'fs\').promises;\n    return fs.readFile(filePath, \'utf-8\');\n  }\n\n  private getLineNumber(content: string, index: number): number {\n    return content.substring(0, index).split(\'\\n\').length;\n  }\n\n  private generateId(): string {\n    return `oracle-validator-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n</create-file>\n</function_calls>'}