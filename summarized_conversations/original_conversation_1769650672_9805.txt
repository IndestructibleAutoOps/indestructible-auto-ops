{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="gl-runtime-platform/unified-intelligence-fabric/fabric-composition/index.ts">\n// @GL-governed\n// @GL-layer: GL90-99\n// @GL-semantic: runtime-fabric-composition\n// @GL-charter-version: 4.0.0\n// @GL-audit-trail: ../../engine/governance/GL_SEMANTIC_ANCHOR.json\n\n/**\n * GL Unified Intelligence Fabric - Fabric Composition\n * Version 19.0.0\n * \n * 核心：組合視角\n * - 織網上的「路徑搜尋與組合」\n * - 動態組合演算法、計算、流程\n * - 自動發現最佳執行路徑\n * - 智能組合優化\n */\n\nimport { FabricCore, FabricNode, FabricEdge } from \'../fabric-core\';\nimport { FabricAlgo, Algorithm } from \'../fabric-algo\';\nimport { FabricCompute, ComputeTask } from \'../fabric-compute\';\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\nexport interface Composition {\n  id: string;\n  name: string;\n  type: CompositionType;\n  description: string;\n  components: Component[];\n  connections: Connection[];\n  properties: CompositionProperties;\n  performance: CompositionPerformance;\n  version: string;\n}\n\nexport type CompositionType = \n  | \'linear\'         // 線性組合\n  | \'parallel\'       // 並行組合\n  | \'branching\'      // 分支組合\n  | \'loop\'           // 循環組合\n  | \'conditional\'    // 條件組合\n  | \'recursive\'      // 遞迴組合\n  | \'adaptive\';      // 自適應組合\n\nexport interface Component {\n  id: string;\n  type: ComponentType;\n  ref: string; // Reference to algorithm, flow, or task\n  parameters: Record<string, any>;\n  position: Position;\n}\n\nexport type ComponentType = \n  | \'algorithm\'\n  | \'flow\'\n  | \'task\'\n  | \'sub_composition\';\n\nexport interface Position {\n  x: number;\n  y: number;\n  layer: number;\n}\n\nexport interface Connection {\n  id: string;\n  sourceComponentId: string;\n  targetComponentId: string;\n  condition?: ConnectionCondition;\n  weight: number;\n}\n\nexport interface ConnectionCondition {\n  type: \'always\' | \'on_success\' | \'on_failure\' | \'on_value\' | \'custom\';\n  condition?: any;\n}\n\nexport interface CompositionProperties {\n  deterministic: boolean;\n  retryPolicy: RetryPolicy;\n  timeout: number;\n  maxParallelism: number;\n  enableCaching: boolean;\n}\n\nexport interface RetryPolicy {\n  maxAttempts: number;\n  backoffStrategy: \'fixed\' | \'exponential\' | \'linear\';\n  initialDelay: number;\n}\n\nexport interface CompositionPerformance {\n  averageExecutionTime: number;\n  successRate: number;\n  throughput: number;\n  resourceEfficiency: number;\n  lastExecuted: number;\n}\n\nexport interface CompositionExecution {\n  id: string;\n  compositionId: string;\n  input: any;\n  startTime: number;\n  endTime?: number;\n  status: \'pending\' | \'running\' | \'completed\' | \'failed\' | \'cancelled\';\n  componentExecutions: Map<string, ComponentExecution>;\n  result?: any;\n  error?: Error;\n  performance: {\n    executionTime: number;\n    componentsExecuted: number;\n    cacheHits: number;\n  };\n}\n\nexport interface ComponentExecution {\n  componentId: string;\n  status: \'pending\' | \'running\' | \'completed\' | \'failed\' | \'skipped\';\n  input: any;\n  output?: any;\n  startTime: number;\n  endTime?: number;\n  error?: Error;\n}\n\nexport interface CompositionConfig {\n  enableAutoOptimization: boolean;\n  enablePathSearch: boolean;\n  maxExecutionDepth: number;\n  enableMemoization: boolean;\n}\n\n// ============================================================================\n// Fabric Composition Class\n// ============================================================================\n\nexport class FabricComposition {\n  private fabric: FabricCore;\n  private algo: FabricAlgo;\n  private compute: FabricCompute;\n  private config: CompositionConfig;\n  private compositions: Map<string, Composition>;\n  private executions: Map<string, CompositionExecution>;\n  private pathFinder: PathFinder;\n  private optimizer: CompositionOptimizer;\n  private executor: CompositionExecutor;\n  private initialized: boolean;\n  \n  constructor(\n    fabric: FabricCore,\n    algo: FabricAlgo,\n    compute: FabricCompute,\n    config?: Partial<CompositionConfig>\n  ) {\n    this.fabric = fabric;\n    this.algo = algo;\n    this.compute = compute;\n    this.config = {\n      enableAutoOptimization: config?.enableAutoOptimization ?? true,\n      enablePathSearch: config?.enablePathSearch ?? true,\n      maxExecutionDepth: config?.maxExecutionDepth || 10,\n      enableMemoization: config?.enableMemoization ?? true\n    };\n    \n    this.compositions = new Map();\n    this.executions = new Map();\n    this.pathFinder = new PathFinder(this);\n    this.optimizer = new CompositionOptimizer(this);\n    this.executor = new CompositionExecutor(this);\n    this.initialized = false;\n  }\n  \n  async initialize(): Promise<void> {\n    console.log(\'[Fabric Composition] Initializing composition layer...\');\n    \n    // 註冊預設組合\n    await this.registerDefaultCompositions();\n    \n    // 初始化路徑搜尋器\n    await this.pathFinder.initialize();\n    \n    // 初始化優化器\n    await this.optimizer.initialize();\n    \n    // 初始化執行器\n    await this.executor.initialize();\n    \n    this.initialized = true;\n    console.log(\'[Fabric Composition] Composition layer initialized\');\n  }\n  \n  // ========================================================================\n  // Composition Management\n  // ========================================================================\n  \n  async registerComposition(composition: Composition): Promise<void> {\n    console.log(`[Fabric Composition] Registering composition ${composition.name} (${composition.id})`);\n    \n    // 驗證組合\n    await this.validateComposition(composition);\n    \n    // 註冊組合\n    this.compositions.set(composition.id, composition);\n  }\n  \n  async unregisterComposition(compositionId: string): Promise<void> {\n    console.log(`[Fabric Composition] Unregistering composition ${compositionId}`);\n    \n    this.compositions.delete(compositionId);\n  }\n  \n  async getComposition(compositionId: string): Promise<Composition | undefined> {\n    return this.compositions.get(compositionId);\n  }\n  \n  async getAllCompositions(): Promise<Composition[]> {\n    return Array.from(this.compositions.values());\n  }\n  \n  private async validateComposition(composition: Composition): Promise<void> {\n    // 驗證組件\n    const componentIds = new Set<string>();\n    \n    for (const component of composition.components) {\n      if (componentIds.has(component.id)) {\n        throw new Error(`Duplicate component ID: ${component.id}`);\n      }\n      componentIds.add(component.id);\n    }\n    \n    // 驗證連接\n    for (const connection of composition.connections) {\n      if (!componentIds.has(connection.sourceComponentId)) {\n        throw new Error(`Connection source component not found: ${connection.sourceComponentId}`);\n      }\n      if (!componentIds.has(connection.targetComponentId)) {\n        throw new Error(`Connection target component not found: ${connection.targetComponentId}`);\n      }\n    }\n  }\n  \n  // ========================================================================\n  // Composition Execution\n  // ========================================================================\n  \n  async executeComposition(\n    compositionId: string,\n    input: any,\n    options?: {\n      optimize?: boolean;\n      searchPath?: boolean;\n    }\n  ): Promise<CompositionExecution> {\n    console.log(`[Fabric Composition] Executing composition ${compositionId}`);\n    \n    const composition = this.compositions.get(compositionId);\n    \n    if (!composition) {\n      throw new Error(`Composition ${compositionId} not found`);\n    }\n    \n    // 創建執行記錄\n    const execution: CompositionExecution = {\n      id: `exec-${compositionId}-${Date.now()}`,\n      compositionId,\n      input,\n      startTime: Date.now(),\n      status: \'pending\',\n      componentExecutions: new Map(),\n      performance: {\n        executionTime: 0,\n        componentsExecuted: 0,\n        cacheHits: 0\n      }\n    };\n    \n    this.executions.set(execution.id, execution);\n    \n    // 優化（可選）\n    if (options?.optimize !== false && this.config.enableAutoOptimization) {\n      await this.optimizer.optimize(compositionId);\n    }\n    \n    // 搜尋路徑（可選）\n    let executionPath: string[] = [];\n    if (options?.searchPath !== false && this.config.enablePathSearch) {\n      executionPath = await this.pathFinder.findBestPath(compositionId, input);\n    }\n    \n    // 執行組合\n    execution.status = \'running\';\n    \n    try {\n      const result = await this.executor.execute(composition, input, executionPath);\n      \n      execution.endTime = Date.now();\n      execution.status = \'completed\';\n      execution.result = result;\n      execution.performance.executionTime = execution.endTime - execution.startTime;\n      \n      // 更新性能統計\n      composition.performance.averageExecutionTime = \n        (composition.performance.averageExecutionTime + execution.performance.executionTime) / 2;\n      composition.performance.lastExecuted = Date.now();\n      \n    } catch (error) {\n      execution.endTime = Date.now();\n      execution.status = \'failed\';\n      execution.error = error as Error;\n      \n      // 更新失敗率\n      composition.performance.successRate = \n        (composition.performance.successRate * 9) / 10;\n    }\n    \n    console.log(`[Fabric Composition] Composition ${compositionId} execution completed with status ${execution.status}`);\n    return execution;\n  }\n  \n  async getExecution(executionId: string): Promise<CompositionExecution | undefined> {\n    return this.executions.get(executionId);\n  }\n  \n  // ========================================================================\n  // Path Finding\n  // ========================================================================\n  \n  async findExecutionPath(\n    compositionId: string,\n    input: any,\n    criteria?: {\n      minimizeTime?: boolean;\n      maximizeSuccessRate?: boolean;\n      minimizeResourceUsage?: boolean;\n    }\n  ): Promise<string[]> {\n    if (!this.config.enablePathSearch) {\n      return [];\n    }\n    \n    console.log(`[Fabric Composition] Finding execution path for composition ${compositionId}`);\n    \n    return await this.pathFinder.findBestPath(\n      compositionId,\n      input,\n      criteria\n    );\n  }\n  \n  // ========================================================================\n  // Composition Building\n  // ========================================================================\n  \n  async buildComposition(\n    name: string,\n    type: CompositionType,\n    components: Omit<Component, \'id\' | \'position\'>[],\n    connections: Omit<Connection, \'id\'>[],\n    options?: Partial<CompositionProperties>\n  ): Promise<Composition> {\n    console.log(`[Fabric Composition] Building composition ${name}`);\n    \n    // 生成組件 ID 和位置\n    const compositionComponents: Component[] = [];\n    \n    for (let i = 0; i < components.length; i++) {\n      const component: Component = {\n        id: `comp-${Date.now()}-${i}`,\n        ...components[i],\n        position: {\n          x: i * 100,\n          y: 0,\n          layer: 0\n        }\n      };\n      compositionComponents.push(component);\n    }\n    \n    // 生成連接 ID\n    const compositionConnections: Connection[] = connections.map((conn, i) => ({\n      id: `conn-${Date.now()}-${i}`,\n      ...conn\n    }));\n    \n    // 建構組合\n    const composition: Composition = {\n      id: `composition-${Date.now()}`,\n      name,\n      type,\n      description: `Auto-generated ${type} composition`,\n      components: compositionComponents,\n      connections: compositionConnections,\n      properties: {\n        deterministic: true,\n        retryPolicy: {\n          maxAttempts: 3,\n          backoffStrategy: \'exponential\',\n          initialDelay: 1000\n        },\n        timeout: 60000,\n        maxParallelism: 5,\n        enableCaching: true,\n        ...options\n      },\n      performance: {\n        averageExecutionTime: 0,\n        successRate: 1.0,\n        throughput: 0,\n        resourceEfficiency: 1.0,\n        lastExecuted: 0\n      },\n      version: \'1.0.0\'\n    };\n    \n    // 註冊組合\n    await this.registerComposition(composition);\n    \n    return composition;\n  }\n  \n  // ========================================================================\n  // Statistics\n  // ========================================================================\n  \n  async getStatistics(): Promise<CompositionStatistics> {\n    const compositions = Array.from(this.compositions.values());\n    const executions = Array.from(this.executions.values());\n    \n    return {\n      totalCompositions: compositions.length,\n      totalExecutions: executions.length,\n      successfulExecutions: executions.filter(e => e.status === \'completed\').length,\n      failedExecutions: executions.filter(e => e.status === \'failed\').length,\n      averageExecutionTime: executions.reduce((sum, e) => sum + e.performance.executionTime, 0) / executions.length || 0,\n      compositionTypes: this.groupByType(compositions)\n    };\n  }\n  \n  private groupByType(compositions: Composition[]): Record<CompositionType, number> {\n    const counts = {} as Record<CompositionType, number>;\n    \n    for (const comp of compositions) {\n      counts[comp.type] = (counts[comp.type] || 0) + 1;\n    }\n    \n    return counts;\n  }\n  \n  private async registerDefaultCompositions(): Promise<void> {\n    console.log(\'[Fabric Composition] Registering default compositions...\');\n    \n    // 註冊預設組合：線性推理流程\n    const linearComposition: Composition = {\n      id: \'comp-linear-reasoning\',\n      name: \'Linear Reasoning Flow\',\n      type: \'linear\',\n      description: \'Linear composition for reasoning tasks\',\n      components: [\n        {\n          id: \'comp-input\',\n          type: \'task\',\n          ref: \'input-processing\',\n          parameters: {},\n          position: { x: 0, y: 0, layer: 0 }\n        },\n        {\n          id: \'comp-reason\',\n          type: \'algorithm\',\n          ref: \'algo-path-search\',\n          parameters: { maxDepth: 10 },\n          position: { x: 100, y: 0, layer: 0 }\n        },\n        {\n          id: \'comp-output\',\n          type: \'task\',\n          ref: \'output-generation\',\n          parameters: {},\n          position: { x: 200, y: 0, layer: 0 }\n        }\n      ],\n      connections: [\n        {\n          id: \'conn-1\',\n          sourceComponentId: \'comp-input\',\n          targetComponentId: \'comp-reason\',\n          condition: { type: \'always\' },\n          weight: 1.0\n        },\n        {\n          id: \'conn-2\',\n          sourceComponentId: \'comp-reason\',\n          targetComponentId: \'comp-output\',\n          condition: { type: \'always\' },\n          weight: 1.0\n        }\n      ],\n      properties: {\n        deterministic: true,\n        retryPolicy: {\n          maxAttempts: 3,\n          backoffStrategy: \'exponential\',\n          initialDelay: 1000\n        },\n        timeout: 60000,\n        maxParallelism: 1,\n        enableCaching: true\n      },\n      performance: {\n        averageExecutionTime: 0,\n        successRate: 1.0,\n        throughput: 0,\n        resourceEfficiency: 1.0,\n        lastExecuted: 0\n      },\n      version: \'1.0.0\'\n    };\n    \n    await this.registerComposition(linearComposition);\n    \n    console.log(\'[Fabric Composition] Registered 1 default composition\');\n  }\n  \n  isInitialized(): boolean {\n    return this.initialized;\n  }\n  \n  // ========================================================================\n  // Getters for internal components\n  // ========================================================================\n  \n  getAlgo(): FabricAlgo {\n    return this.algo;\n  }\n  \n  getCompute(): FabricCompute {\n    return this.compute;\n  }\n}\n\n// ============================================================================\n// Path Finder\n// ============================================================================\n\nclass PathFinder {\n  private pathCache: Map<string, string[]>;\n  \n  constructor(private composition: FabricComposition) {\n    this.pathCache = new Map();\n  }\n  \n  async initialize(): Promise<void> {\n    console.log(\'[Path Finder] Initializing...\');\n  }\n  \n  async findBestPath(\n    compositionId: string,\n    input: any,\n    criteria?: {\n      minimizeTime?: boolean;\n      maximizeSuccessRate?: boolean;\n      minimizeResourceUsage?: boolean;\n    }\n  ): Promise<string[]> {\n    const composition = this.composition[\'compositions\'].get(compositionId);\n    \n    if (!composition) {\n      throw new Error(`Composition ${compositionId} not found`);\n    }\n    \n    // 檢查緩存\n    const cacheKey = `${compositionId}-${JSON.stringify(criteria)}`;\n    if (this.pathCache.has(cacheKey)) {\n      return this.pathCache.get(cacheKey)!;\n    }\n    \n    // 根據組合類型搜尋路徑\n    let path: string[];\n    \n    switch (composition.type) {\n      case \'linear\':\n        path = this.findLinearPath(composition);\n        break;\n      case \'parallel\':\n        path = this.findParallelPath(composition);\n        break;\n      case \'branching\':\n        path = this.findBranchingPath(composition, input);\n        break;\n      case \'loop\':\n        path = this.findLoopPath(composition, input);\n        break;\n      case \'conditional\':\n        path = this.findConditionalPath(composition, input);\n        break;\n      default:\n        path = this.findLinearPath(composition);\n    }\n    \n    // 緩存路徑\n    this.pathCache.set(cacheKey, path);\n    \n    return path;\n  }\n  \n  private findLinearPath(composition: Composition): string[] {\n    // 線性路徑：按連接順序\n    const path: string[] = [];\n    const visited = new Set<string>();\n    \n    // 找到起始節點\n    const startComponents = composition.components.filter(c => \n      !composition.connections.some(conn => conn.targetComponentId === c.id)\n    );\n    \n    if (startComponents.length === 0) {\n      return composition.components.map(c => c.id);\n    }\n    \n    // 深度優先搜尋\n    const dfs = (componentId: string): void => {\n      if (visited.has(componentId)) {\n        return;\n      }\n      \n      visited.add(componentId);\n      path.push(componentId);\n      \n      const outgoingConnections = composition.connections.filter(\n        conn => conn.sourceComponentId === componentId\n      );\n      \n      for (const conn of outgoingConnections) {\n        dfs(conn.targetComponentId);\n      }\n    };\n    \n    for (const start of startComponents) {\n      dfs(start.id);\n    }\n    \n    return path;\n  }\n  \n  private findParallelPath(composition: Composition): string[] {\n    // 並行路徑：所有並行分支\n    const path: string[] = [];\n    \n    for (const component of composition.components) {\n      path.push(component.id);\n    }\n    \n    return path;\n  }\n  \n  private findBranchingPath(composition: Composition, input: any): string[] {\n    // 分支路徑：根據條件選擇\n    const path: string[] = [];\n    \n    // 簡化實作：選擇第一個分支\n    const startComponents = composition.components.filter(c => \n      !composition.connections.some(conn => conn.targetComponentId === c.id)\n    );\n    \n    if (startComponents.length > 0) {\n      path.push(startComponents[0].id);\n      \n      const outgoingConnections = composition.connections.filter(\n        conn => conn.sourceComponentId === startComponents[0].id\n      );\n      \n      if (outgoingConnections.length > 0) {\n        // 選擇權重最高的連接\n        outgoingConnections.sort((a, b) => b.weight - a.weight);\n        path.push(outgoingConnections[0].targetComponentId);\n      }\n    }\n    \n    return path;\n  }\n  \n  private findLoopPath(composition: Composition, input: any): string[] {\n    // 循環路徑：簡化實作\n    return this.findLinearPath(composition);\n  }\n  \n  private findConditionalPath(composition: Composition, input: any): string[] {\n    // 條件路徑：簡化實作\n    return this.findBranchingPath(composition, input);\n  }\n}\n\n// ============================================================================\n// Composition Optimizer\n// ============================================================================\n\nclass CompositionOptimizer {\n  constructor(private composition: FabricComposition) {}\n  \n  async initialize(): Promise<void> {\n    console.log(\'[Composition Optimizer] Initializing...\');\n  }\n  \n  async optimize(compositionId: string): Promise<void> {\n    console.log(`[Composition Optimizer] Optimizing composition ${compositionId}`);\n    \n    const composition = this.composition[\'compositions\'].get(compositionId);\n    \n    if (!composition) {\n      throw new Error(`Composition ${compositionId} not found`);\n    }\n    \n    // 優化步驟：\n    // 1. 移除冗餘組件\n    await this.removeRedundantComponents(composition);\n    \n    // 2. 合併相似組件\n    await this.mergeSimilarComponents(composition);\n    \n    // 3. 優化連接權重\n    await this.optimizeConnectionWeights(composition);\n    \n    console.log(`[Composition Optimizer] Composition ${compositionId} optimized`);\n  }\n  \n  private async removeRedundantComponents(composition: Composition): Promise<void> {\n    // 簡化實作：無操作\n  }\n  \n  private async mergeSimilarComponents(composition: Composition): Promise<void> {\n    // 簡化實作：無操作\n  }\n  \n  private async optimizeConnectionWeights(composition: Composition): Promise<void> {\n    // 基於歷史執行數據優化權重\n    for (const conn of composition.connections) {\n      // 簡化實作：使用固定權重\n      conn.weight = 1.0;\n    }\n  }\n}\n\n// ============================================================================\n// Composition Executor\n// ============================================================================\n\nclass CompositionExecutor {\n  constructor(private composition: FabricComposition) {}\n  \n  async initialize(): Promise<void> {\n    console.log(\'[Composition Executor] Initializing...\');\n  }\n  \n  async execute(\n    composition: Composition,\n    input: any,\n    path: string[]\n  ): Promise<any> {\n    console.log(`[Composition Executor] Executing composition ${composition.id}`);\n    \n    const executionMap = new Map<string, ComponentExecution>();\n    let currentInput = input;\n    let result: any = input;\n    \n    // 按路徑執行組件\n    for (const componentId of path) {\n      const component = composition.components.find(c => c.id === componentId);\n      \n      if (!component) {\n        throw new Error(`Component ${componentId} not found`);\n      }\n      \n      // 創建組件執行記錄\n      const componentExec: ComponentExecution = {\n        componentId,\n        status: \'running\',\n        input: currentInput,\n        startTime: Date.now()\n      };\n      \n      executionMap.set(componentId, componentExec);\n      \n      try {\n        // 執行組件\n        currentInput = await this.executeComponent(component, currentInput);\n        \n        componentExec.status = \'completed\';\n        componentExec.output = currentInput;\n        componentExec.endTime = Date.now();\n        \n        result = currentInput;\n        \n      } catch (error) {\n        componentExec.status = \'failed\';\n        componentExec.error = error as Error;\n        componentExec.endTime = Date.now();\n        \n        throw error;\n      }\n    }\n    \n    return result;\n  }\n  \n  private async executeComponent(component: Component, input: any): Promise<any> {\n    const algo = this.composition.getAlgo();\n    \n    switch (component.type) {\n      case \'algorithm\':\n        // 執行演算法\n        const algorithm = await algo.getAlgorithm(component.ref);\n        if (!algorithm) {\n          throw new Error(`Algorithm ${component.ref} not found`);\n        }\n        const execution = await algo.executeAlgorithm(\n          component.ref,\n          input,\n          component.parameters\n        );\n        return execution.result;\n        \n      case \'flow\':\n        // 執行流程\n        return await this.executeFlow(component.ref, input, component.parameters);\n        \n      case \'task\':\n        // 執行任務\n        return await this.executeTask(component.ref, input, component.parameters);\n        \n      case \'sub_composition\':\n        // 執行子組合\n        return await this.composition.executeComposition(\n          component.ref,\n          input,\n          component.parameters\n        );\n        \n      default:\n        throw new Error(`Unknown component type: ${component.type}`);\n    }\n  }\n  \n  private async executeFlow(flowRef: string, input: any, parameters: any): Promise<any> {\n    // 簡化實作：返回輸入\n    return { flow: flowRef, input, result: input };\n  }\n  \n  private async executeTask(taskRef: string, input: any, parameters: any): Promise<any> {\n    // 簡化實作：返回輸入\n    return { task: taskRef, input, result: input };\n  }\n}\n\n// ============================================================================\n// Type Definitions\n// ============================================================================\n\nexport interface CompositionStatistics {\n  totalCompositions: number;\n  totalExecutions: number;\n  successfulExecutions: number;\n  failedExecutions: number;\n  averageExecutionTime: number;\n  compositionTypes: Record<CompositionType, number>;\n}\n</create-file>\n</function_calls>'}