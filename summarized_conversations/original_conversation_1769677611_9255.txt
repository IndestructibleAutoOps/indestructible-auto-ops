{'role': 'assistant', 'content': '## ✅ Semantic Inconsistency Scanner 完成\n\n讓我繼續實作 Anti-Fabric 的其餘模組。接下來是 **Pattern Breaker**（模式破壞器）：\n\n<function_calls>\n<create-file file_path="gl-runtime-platform/ultra-strict-verification-core/anti-fabric/pattern-breaker/pattern-breaker.ts">\n# @GL-governed\n# @GL-layer: GL90-99\n# @GL-semantic: anti-fabric-pattern-breaker\n# @GL-charter-version: 2.0.0\n\n/**\n * Anti-Fabric: Pattern Breaker\n * \n * Core Philosophy: "推翻 GL 所有的結論，直到剩下的部分是真正站得住的。"\n * (Overturn all GL conclusions until only what truly stands remains.)\n * \n * Purpose: Detect violations of established patterns and conventions\n * \n * This module actively searches for:\n * - Inconsistent coding patterns\n * - Broken architectural patterns\n * - Violated design principles\n * - Anti-patterns in code\n * - Pattern drift across components\n */\n\nimport { \n  PatternBreakResult,\n  VerificationSeverity,\n  VerificationFinding \n} from \'../../types\';\n\nexport class PatternBreaker {\n  private findings: VerificationFinding[] = [];\n  private establishedPatterns: Map<string, string[]> = new Map();\n\n  /**\n   * Detect pattern breaks in a component\n   */\n  async detectPatternBreaks(component: string): Promise<PatternBreakResult> {\n    this.findings = [];\n    \n    // Build pattern database first\n    await this.buildPatternDatabase(component);\n    \n    // Scan component for pattern breaks\n    await this.scanComponent(component);\n    \n    return {\n      patternBroken: this.findings.length > 0,\n      breaks: this.extractBreaks()\n    };\n  }\n\n  /**\n   * Build pattern database from component files\n   */\n  private async buildPatternDatabase(component: string): Promise<void> {\n    const componentPath = this.getComponentPath(component);\n    const files = await this.getTsFiles(componentPath);\n\n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // Extract naming patterns\n      this.extractNamingPatterns(file, content);\n      \n      // Extract structural patterns\n      this.extractStructuralPatterns(file, content);\n      \n      // Extract architectural patterns\n      this.extractArchitecturalPatterns(file, content);\n    }\n  }\n\n  /**\n   * Extract naming patterns\n   */\n  private extractNamingPatterns(file: string, content: string): void {\n    // Class naming patterns\n    const classMatches = content.matchAll(/class\\s+(\\w+)/g);\n    for (const match of classMatches) {\n      const className = match[1];\n      const pattern = this.inferNamingPattern(className);\n      \n      if (!this.establishedPatterns.has(\'class-naming\')) {\n        this.establishedPatterns.set(\'class-naming\', []);\n      }\n      this.establishedPatterns.get(\'class-naming\')!.push(pattern);\n    }\n    \n    // Function naming patterns\n    const funcMatches = content.matchAll(/(?:function|const\\s+\\w+\\s*=\\s*)\\s*(\\w+)/g);\n    for (const match of funcMatches) {\n      const funcName = match[1];\n      const pattern = this.inferNamingPattern(funcName);\n      \n      if (!this.establishedPatterns.has(\'function-naming\')) {\n        this.establishedPatterns.set(\'function-naming\', []);\n      }\n      this.establishedPatterns.get(\'function-naming\')!.push(pattern);\n    }\n    \n    // Variable naming patterns\n    const varMatches = content.matchAll(/(?:const|let|var)\\s+(\\w+)\\s*=/g);\n    for (const match of varMatches) {\n      const varName = match[1];\n      const pattern = this.inferNamingPattern(varName);\n      \n      if (!this.establishedPatterns.has(\'variable-naming\')) {\n        this.establishedPatterns.set(\'variable-naming\', []);\n      }\n      this.establishedPatterns.get(\'variable-naming\')!.push(pattern);\n    }\n  }\n\n  /**\n   * Extract structural patterns\n   */\n  private extractStructuralPatterns(file: string, content: string): void {\n    // Import patterns\n    const importMatches = content.matchAll(/import\\s+.*from\\s+[\'"]([^\'"]+)[\'"]/g);\n    for (const match of importMatches) {\n      const importPath = match[1];\n      \n      if (!this.establishedPatterns.has(\'import-style\')) {\n        this.establishedPatterns.set(\'import-style\', []);\n      }\n      this.establishedPatterns.get(\'import-style\')!.push(importPath);\n    }\n    \n    // Export patterns\n    const exportMatches = content.matchAll(/export\\s+(?:default\\s+)?(?:class|function|const|interface)\\s+(\\w+)/g);\n    for (const match of exportMatches) {\n      const exportName = match[1];\n      \n      if (!this.establishedPatterns.has(\'export-style\')) {\n        this.establishedPatterns.set(\'export-style\', []);\n      }\n      this.establishedPatterns.get(\'export-style\')!.push(exportName);\n    }\n  }\n\n  /**\n   * Extract architectural patterns\n   */\n  private extractArchitecturalPatterns(file: string, content: string): void {\n    // Service patterns\n    if (file.includes(\'/services/\') || file.includes(\'-service\')) {\n      if (!this.establishedPatterns.has(\'service-pattern\')) {\n        this.establishedPatterns.set(\'service-pattern\', []);\n      }\n      this.establishedPatterns.get(\'service-pattern\')!.push(file);\n    }\n    \n    // Controller patterns\n    if (file.includes(\'/controllers/\') || file.includes(\'-controller\')) {\n      if (!this.establishedPatterns.has(\'controller-pattern\')) {\n        this.establishedPatterns.set(\'controller-pattern\', []);\n      }\n      this.establishedPatterns.get(\'controller-pattern\')!.push(file);\n    }\n    \n    // Model patterns\n    if (file.includes(\'/models/\') || file.includes(\'-model\')) {\n      if (!this.establishedPatterns.has(\'model-pattern\')) {\n        this.establishedPatterns.set(\'model-pattern\', []);\n      }\n      this.establishedPatterns.get(\'model-pattern\')!.push(file);\n    }\n  }\n\n  /**\n   * Scan component for pattern breaks\n   */\n  private async scanComponent(component: string): Promise<void> {\n    const componentPath = this.getComponentPath(component);\n    const files = await this.getTsFiles(componentPath);\n\n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // 1. Detect naming pattern violations\n      await this.detectNamingPatternViolations(file, content);\n      \n      // 2. Detect structural pattern violations\n      await this.detectStructuralPatternViolations(file, content);\n      \n      // 3. Detect architectural pattern violations\n      await this.detectArchitecturalPatternViolations(file, content);\n      \n      // 4. Detect anti-patterns\n      await this.detectAntiPatterns(file, content);\n    }\n  }\n\n  /**\n   * Detect naming pattern violations\n   */\n  private async detectNamingPatternViolations(file: string, content: string): Promise<void> {\n    // Check class naming\n    const classMatches = content.matchAll(/class\\s+(\\w+)/g);\n    for (const match of classMatches) {\n      const className = match[1];\n      const pattern = this.inferNamingPattern(className);\n      \n      const classPatterns = this.establishedPatterns.get(\'class-naming\') || [];\n      const dominantPattern = this.findDominantPattern(classPatterns);\n      \n      if (dominantPattern && pattern !== dominantPattern) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'PATTERN_BREAK\',\n          severity: VerificationSeverity.MEDIUM,\n          component: file,\n          location: {\n            file,\n            line: this.getLineNumber(content, match.index!),\n            module: file\n          },\n          title: \'Naming Pattern Violation\',\n          description: `Class \'${className}\' follows pattern \'${pattern}\' but dominant pattern is \'${dominantPattern}\'`,\n          evidence: [{\n            type: \'code\',\n            source: file,\n            content: match[0],\n            timestamp: new Date(),\n            verified: true\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n  }\n\n  /**\n   * Detect structural pattern violations\n   */\n  private async detectStructuralPatternViolations(file: string, content: string): Promise<void> {\n    // Check import ordering\n    const importLines: Array<{ line: number; content: string }> = [];\n    const importMatches = content.matchAll(/^import\\s+.*$/gm);\n    \n    for (const match of importMatches) {\n      importLines.push({\n        line: this.getLineNumber(content, match.index!),\n        content: match[0]\n      });\n    }\n    \n    // Check if imports are properly grouped\n    if (importLines.length > 1) {\n      const groups = this.groupImports(importLines);\n      \n      if (groups.length > 1 && this.importsOutOfOrder(groups)) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'PATTERN_BREAK\',\n          severity: VerificationSeverity.LOW,\n          component: file,\n          location: {\n            file,\n            line: importLines[0].line,\n            module: file\n          },\n          title: \'Import Pattern Violation\',\n          description: \'Imports are not properly grouped or ordered\',\n          evidence: importLines.map(line => ({\n            type: \'code\' as const,\n            source: file,\n            content: line.content,\n            timestamp: new Date(),\n            verified: true\n          })),\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n  }\n\n  /**\n   * Detect architectural pattern violations\n   */\n  private async detectArchitecturalPatternViolations(file: string, content: string): Promise<void> {\n    // Check service pattern compliance\n    if (file.includes(\'/services/\') || file.includes(\'-service\')) {\n      // Services should have specific structure\n      const hasMethod = /async\\s+\\w+\\s*\\(/.test(content);\n      \n      if (!hasMethod) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'PATTERN_BREAK\',\n          severity: VerificationSeverity.MEDIUM,\n          component: file,\n          location: {\n            file,\n            module: file\n          },\n          title: \'Service Pattern Violation\',\n          description: \'Service file should contain async methods\',\n          evidence: [{\n            type: \'code\',\n            source: file,\n            content: content.substring(0, 500),\n            timestamp: new Date(),\n            verified: true\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n    \n    // Check controller pattern compliance\n    if (file.includes(\'/controllers/\') || file.includes(\'-controller\')) {\n      // Controllers should handle requests\n      const hasRequestHandler = /req|request|ctx|context/.test(content);\n      \n      if (!hasRequestHandler) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'PATTERN_BREAK\',\n          severity: VerificationSeverity.MEDIUM,\n          component: file,\n          location: {\n            file,\n            module: file\n          },\n          title: \'Controller Pattern Violation\',\n          description: \'Controller file should handle request/response\',\n          evidence: [{\n            type: \'code\',\n            source: file,\n            content: content.substring(0, 500),\n            timestamp: new Date(),\n            verified: true\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n  }\n\n  /**\n   * Detect anti-patterns\n   */\n  private async detectAntiPatterns(file: string, content: string): Promise<void> {\n    // God object anti-pattern\n    const lineCount = content.split(\'\\n\').length;\n    const classMatches = content.matchAll(/class\\s+(\\w+)\\s*{([^}]*(?:{[^}]*}[^}]*)*)}/gs);\n    \n    for (const match of classMatches) {\n      const className = match[1];\n      const classBody = match[2];\n      const methodCount = (classBody.match(/\\w+\\s*\\([^)]*\\)\\s*{/g) || []).length;\n      \n      if (methodCount > 15) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'PATTERN_BREAK\',\n          severity: VerificationSeverity.HIGH,\n          component: file,\n          location: {\n            file,\n            line: this.getLineNumber(content, match.index!),\n            module: file\n          },\n          title: \'God Object Anti-Pattern Detected\',\n          description: `Class \'${className}\' has ${methodCount} methods (threshold: 15)`,\n          evidence: [{\n            type: \'code\',\n            source: file,\n            content: `class ${className} { ... } // ${methodCount} methods`,\n            timestamp: new Date(),\n            verified: true\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n    \n    // Magic number anti-pattern\n    const magicNumberMatches = content.matchAll(/(?<![\\w])(\\d{2,})(?![\\d])/g);\n    for (const match of magicNumberMatches) {\n      const number = match[1];\n      \n      // Skip common constants\n      if (![\'100\', \'1000\', \'3600\', \'86400\'].includes(number)) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'PATTERN_BREAK\',\n          severity: VerificationSeverity.LOW,\n          component: file,\n          location: {\n            file,\n            line: this.getLineNumber(content, match.index!),\n            module: file\n          },\n          title: \'Magic Number Anti-Pattern Detected\',\n          description: `Magic number \'${number}\' found - consider using a named constant`,\n          evidence: [{\n            type: \'code\',\n            source: file,\n            content: match[0],\n            timestamp: new Date(),\n            verified: true\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n    \n    // Deep nesting anti-pattern\n    const lines = content.split(\'\\n\');\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const indentMatch = line.match(/^(\\s*)/);\n      if (indentMatch) {\n        const indent = indentMatch[1].length;\n        if (indent > 24) { // More than 6 levels of indentation\n          this.findings.push({\n            id: this.generateId(),\n            type: \'PATTERN_BREAK\',\n            severity: VerificationSeverity.MEDIUM,\n            component: file,\n            location: {\n              file,\n              line: i + 1,\n              module: file\n            },\n            title: \'Deep Nesting Anti-Pattern Detected\',\n            description: `Deep nesting detected at line ${i + 1} (${indent} spaces)`,\n            evidence: [{\n              type: \'code\',\n              source: file,\n              content: line.trim(),\n              timestamp: new Date(),\n              verified: true\n            }],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Extract pattern breaks from findings\n   */\n  private extractBreaks() {\n    return this.findings.map(finding => ({\n      pattern: finding.type,\n      violation: finding.description,\n      location: `${finding.location.file}:${finding.location.line}`,\n      justification: finding.title\n    }));\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  private getComponentPath(component: string): string {\n    return `/workspace/gl-runtime-platform/${component}`;\n  }\n\n  private async getTsFiles(path: string): Promise<string[]> {\n    const { exec } = require(\'child_process\');\n    return new Promise((resolve, reject) => {\n      exec(`find ${path} -type f -name "*.ts"`, (error, stdout) => {\n        if (error) reject(error);\n        else resolve(stdout.trim().split(\'\\n\').filter(f => f));\n      });\n    });\n  }\n\n  private async readFileContent(filePath: string): Promise<string> {\n    const fs = require(\'fs\').promises;\n    return fs.readFile(filePath, \'utf-8\');\n  }\n\n  private getLineNumber(content: string, index: number): number {\n    return content.substring(0, index).split(\'\\n\').length;\n  }\n\n  private generateId(): string {\n    return `pattern-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private inferNamingPattern(name: string): string {\n    // PascalCase\n    if (/^[A-Z][a-zA-Z0-9]*$/.test(name)) {\n      return \'PascalCase\';\n    }\n    // camelCase\n    if (/^[a-z][a-zA-Z0-9]*$/.test(name)) {\n      return \'camelCase\';\n    }\n    // kebab-case\n    if (/^[a-z][a-z0-9-]*$/.test(name)) {\n      return \'kebab-case\';\n    }\n    // snake_case\n    if (/^[a-z][a-z0-9_]*$/.test(name)) {\n      return \'snake_case\';\n    }\n    // UPPER_CASE\n    if (/^[A-Z][A-Z0-9_]*$/.test(name)) {\n      return \'UPPER_CASE\';\n    }\n    \n    return \'unknown\';\n  }\n\n  private findDominantPattern(patterns: string[]): string | null {\n    if (patterns.length === 0) return null;\n    \n    const counts = new Map<string, number>();\n    for (const pattern of patterns) {\n      counts.set(pattern, (counts.get(pattern) || 0) + 1);\n    }\n    \n    let maxCount = 0;\n    let dominantPattern = \'\';\n    \n    for (const [pattern, count] of counts) {\n      if (count > maxCount) {\n        maxCount = count;\n        dominantPattern = pattern;\n      }\n    }\n    \n    return maxCount > patterns.length / 2 ? dominantPattern : null;\n  }\n\n  private groupImports(importLines: Array<{ line: number; content: string }>): string[][] {\n    const groups: string[][] = [];\n    let currentGroup: string[] = [];\n    \n    for (const line of importLines) {\n      if (currentGroup.length === 0) {\n        currentGroup.push(line.content);\n      } else {\n        const prevLine = currentGroup[currentGroup.length - 1];\n        const gap = line.line - this.getLineNumberFromContent(prevLine, importLines) - 1;\n        \n        if (gap > 1) {\n          groups.push(currentGroup);\n          currentGroup = [line.content];\n        } else {\n          currentGroup.push(line.content);\n        }\n      }\n    }\n    \n    if (currentGroup.length > 0) {\n      groups.push(currentGroup);\n    }\n    \n    return groups;\n  }\n\n  private importsOutOfOrder(groups: string[][]): boolean {\n    // Simplified check - in reality, would check for proper ordering\n    // (external -> internal -> relative)\n    return groups.length > 1;\n  }\n\n  private getLineNumberFromContent(content: string, importLines: Array<{ line: number; content: string }>): number {\n    const match = importLines.find(line => line.content === content);\n    return match?.line || 0;\n  }\n}\n</create-file>\n</function_calls>'}