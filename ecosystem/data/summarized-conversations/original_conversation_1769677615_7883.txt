{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="gl-execution-runtime/ultra-strict-verification-core/execution-harness/regression-diff/regression-diff.ts">\n# @GL-governed\n# @GL-layer: GL90-99\n# @GL-semantic: execution-harness-regression-diff\n# @GL-charter-version: 2.0.0\n\n/**\n * Execution-Grounded Reality Harness: Regression Diff\n * \n * Core Philosophy: "所有重構 → 必須跑差分測試"\n * (All refactoring must undergo diff testing)\n * \n * Purpose: Detect regressions between versions\n * \n * This module enforces:\n * - All changes must be diff tested\n * - All regressions must be reported\n * - All behavior changes must be justified\n * - Performance regressions must be detected\n */\n\nimport { \n  RegressionDiffResult,\n  VerificationSeverity,\n  VerificationFinding \n} from \'../../types\';\n\nexport class RegressionDiff {\n  private findings: VerificationFinding[] = [];\n  private previousVersions: Map<string, any> = new Map();\n\n  /**\n   * Detect regressions between current and previous version\n   */\n  async detectRegression(component: string, previousVersion: string): Promise<RegressionDiffResult> {\n    this.findings = [];\n    \n    // Load previous version\n    const previousData = await this.loadPreviousVersion(component, previousVersion);\n    \n    if (!previousData) {\n      this.findings.push({\n        id: this.generateId(),\n        type: \'INCONSISTENCY\',\n        severity: VerificationSeverity.MEDIUM,\n        component,\n        location: {\n          module: component\n        },\n        title: \'Previous Version Not Found\',\n        description: `Previous version \'${previousVersion}\' not found - cannot detect regressions`,\n        evidence: [{\n          type: \'baseline\',\n          source: component,\n          content: { previousVersion, status: \'not found\' },\n          timestamp: new Date(),\n          verified: false\n        }],\n        timestamp: new Date(),\n        verified: false,\n        falsifiable: true\n      });\n      \n      return {\n        regressionDetected: false,\n        regressions: []\n      };\n    }\n    \n    // Compare current version with previous\n    await this.compareVersions(component, previousData);\n    \n    return {\n      regressionDetected: this.findings.length > 0,\n      regressions: this.extractRegressions()\n    };\n  }\n\n  /**\n   * Load previous version\n   */\n  private async loadPreviousVersion(component: string, version: string): Promise<any | null> {\n    const key = `${component}:${version}`;\n    \n    // Check if already loaded\n    if (this.previousVersions.has(key)) {\n      return this.previousVersions.get(key);\n    }\n    \n    // Try to load from file\n    const versionPath = this.getVersionPath(component, version);\n    \n    try {\n      const fs = require(\'fs\').promises;\n      const content = await fs.readFile(versionPath, \'utf-8\');\n      const data = JSON.parse(content);\n      \n      this.previousVersions.set(key, data);\n      return data;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Compare current version with previous\n   */\n  private async compareVersions(component: string, previousData: any): Promise<void> {\n    const componentPath = this.getComponentPath(component);\n    \n    // Get current version data\n    const currentData = await this.getCurrentVersionData(component, componentPath);\n    \n    // Compare functions\n    if (previousData.functions && currentData.functions) {\n      await this.compareFunctions(component, previousData.functions, currentData.functions);\n    }\n    \n    // Compare classes\n    if (previousData.classes && currentData.classes) {\n      await this.compareClasses(component, previousData.classes, currentData.classes);\n    }\n    \n    // Compare metrics\n    if (previousData.metrics && currentData.metrics) {\n      await this.compareMetrics(component, previousData.metrics, currentData.metrics);\n    }\n  }\n\n  /**\n   * Get current version data\n   */\n  private async getCurrentVersionData(component: string, componentPath: string): Promise<any> {\n    const files = await this.getTsFiles(componentPath);\n    \n    const data: any = {\n      functions: {},\n      classes: {},\n      metrics: {}\n    };\n    \n    for (const file of files) {\n      const content = await this.readFileContent(file);\n      \n      // Extract functions\n      const functionMatches = content.matchAll(\n        /(?:function|const\\s+\\w+\\s*=\\s*|(?:async\\s+)?\\w+)\\s*(\\w+)\\s*\\(([^)]*)\\)/g\n      );\n      \n      for (const match of functionMatches) {\n        const functionName = match[1];\n        const params = match[2];\n        \n        if (!data.functions[functionName]) {\n          data.functions[functionName] = {\n            file,\n            params: params.split(\',\').map(p => p.trim()),\n            count: 0\n          };\n        }\n        data.functions[functionName].count++;\n      }\n      \n      // Extract classes\n      const classMatches = content.matchAll(/class\\s+(\\w+)/g);\n      for (const match of classMatches) {\n        const className = match[1];\n        \n        if (!data.classes[className]) {\n          data.classes[className] = {\n            file,\n            methods: []\n          };\n        }\n      }\n    }\n    \n    return data;\n  }\n\n  /**\n   * Compare functions\n   */\n  private async compareFunctions(\n    component: string,\n    previous: any,\n    current: any\n  ): Promise<void> {\n    // Check for removed functions\n    for (const functionName of Object.keys(previous)) {\n      if (!current[functionName]) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'REGRESSION\',\n          severity: VerificationSeverity.HIGH,\n          component,\n          location: {\n            module: component\n          },\n          title: \'Function Removed\',\n          description: `Function \'${functionName}\' was removed - this may break compatibility`,\n          evidence: [{\n            type: \'baseline\',\n            source: \'previous version\',\n            content: previous[functionName],\n            timestamp: new Date(),\n            verified: false\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n    \n    // Check for changed function signatures\n    for (const functionName of Object.keys(current)) {\n      if (previous[functionName]) {\n        const prevFunc = previous[functionName];\n        const currFunc = current[functionName];\n        \n        if (prevFunc.params.join(\',\') !== currFunc.params.join(\',\')) {\n          this.findings.push({\n            id: this.generateId(),\n            type: \'REGRESSION\',\n            severity: VerificationSeverity.HIGH,\n            component,\n            location: {\n              file: currFunc.file,\n              module: component\n            },\n            title: \'Function Signature Changed\',\n            description: `Function \'${functionName}\' signature changed from (${prevFunc.params.join(\',\')}) to (${currFunc.params.join(\',\')})`,\n            evidence: [\n              {\n                type: \'baseline\',\n                source: \'previous version\',\n                content: prevFunc,\n                timestamp: new Date(),\n                verified: false\n              },\n              {\n                type: \'code\',\n                source: \'current version\',\n                content: currFunc,\n                timestamp: new Date(),\n                verified: true\n              }\n            ],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Compare classes\n   */\n  private async compareClasses(\n    component: string,\n    previous: any,\n    current: any\n  ): Promise<void> {\n    // Check for removed classes\n    for (const className of Object.keys(previous)) {\n      if (!current[className]) {\n        this.findings.push({\n          id: this.generateId(),\n          type: \'REGRESSION\',\n          severity: VerificationSeverity.HIGH,\n          component,\n          location: {\n            module: component\n          },\n          title: \'Class Removed\',\n          description: `Class \'${className}\' was removed - this may break compatibility`,\n          evidence: [{\n            type: \'baseline\',\n            source: \'previous version\',\n            content: previous[className],\n            timestamp: new Date(),\n            verified: false\n          }],\n          timestamp: new Date(),\n          verified: false,\n          falsifiable: true\n        });\n      }\n    }\n  }\n\n  /**\n   * Compare metrics\n   */\n  private async compareMetrics(\n    component: string,\n    previous: any,\n    current: any\n  ): Promise<void> {\n    for (const metricName of Object.keys(previous)) {\n      if (current[metricName]) {\n        const prevValue = previous[metricName];\n        const currValue = current[metricName];\n        \n        // Check for performance regression (values that got worse)\n        const isWorse = this.isMetricWorse(metricName, prevValue, currValue);\n        \n        if (isWorse) {\n          const percentChange = ((currValue - prevValue) / prevValue) * 100;\n          \n          this.findings.push({\n            id: this.generateId(),\n            type: \'PERFORMANCE_DEGRADATION\',\n            severity: Math.abs(percentChange) > 50 ? VerificationSeverity.HIGH : VerificationSeverity.MEDIUM,\n            component,\n            location: {\n              module: component\n            },\n            title: \'Performance Regression Detected\',\n            description: `Metric \'${metricName}\' regressed from ${prevValue} to ${currValue} (${percentChange.toFixed(2)}% change)`,\n            evidence: [\n              {\n                type: \'baseline\',\n                source: \'previous version\',\n                content: { metric: metricName, value: prevValue },\n                timestamp: new Date(),\n                verified: false\n              },\n              {\n                type: \'execution\',\n                source: \'current version\',\n                content: { metric: metricName, value: currValue },\n                timestamp: new Date(),\n                verified: false\n              }\n            ],\n            timestamp: new Date(),\n            verified: false,\n            falsifiable: true\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if metric got worse\n   */\n  private isMetricWorse(metricName: string, previous: number, current: number): boolean {\n    // Lower is better metrics\n    const lowerIsBetter = [\n      \'executionTime\', \'responseTime\', \'latency\', \'memoryUsage\', \'cpuTime\',\n      \'errorRate\', \'failureRate\', \'loadTime\', \'renderTime\'\n    ];\n    \n    if (lowerIsBetter.some(m => metricName.toLowerCase().includes(m))) {\n      return current > previous;\n    }\n    \n    // Higher is better metrics\n    const higherIsBetter = [\n      \'throughput\', \'qps\', \'requestsPerSecond\', \'successRate\', \'availability\',\n      \'efficiency\', \'score\', \'rating\', \'accuracy\'\n    ];\n    \n    if (higherIsBetter.some(m => metricName.toLowerCase().includes(m))) {\n      return current < previous;\n    }\n    \n    return false;\n  }\n\n  /**\n   * Extract regressions from findings\n   */\n  private extractRegressions() {\n    return this.findings.map(finding => ({\n      component: finding.component,\n      change: finding.title,\n      impact: finding.description,\n      severity: finding.severity\n    }));\n  }\n\n  /**\n   * Save current version\n   */\n  async saveVersion(component: string, version: string, data: any): Promise<void> {\n    const versionPath = this.getVersionPath(component, version);\n    const fs = require(\'fs\').promises;\n    \n    await fs.writeFile(versionPath, JSON.stringify(data, null, 2), \'utf-8\');\n    this.previousVersions.set(`${component}:${version}`, data);\n  }\n\n  /**\n   * Get version path\n   */\n  private getVersionPath(component: string, version: string): string {\n    return `/workspace/gl-execution-runtime/.versions/${component}/${version}.json`;\n  }\n\n  /**\n   * Get findings\n   */\n  getFindings(): VerificationFinding[] {\n    return this.findings;\n  }\n\n  /**\n   * Clear findings\n   */\n  clearFindings(): void {\n    this.findings = [];\n  }\n\n  // ============================================================================\n  // Helper Methods\n  // ============================================================================\n\n  private getComponentPath(component: string): string {\n    return `/workspace/gl-execution-runtime/${component}`;\n  }\n\n  private async getTsFiles(path: string): Promise<string[]> {\n    const { exec } = require(\'child_process\');\n    return new Promise((resolve, reject) => {\n      exec(`find ${path} -type f -name "*.ts"`, (error, stdout) => {\n        if (error) reject(error);\n        else resolve(stdout.trim().split(\'\\n\').filter(f => f));\n      });\n    });\n  }\n\n  private async readFileContent(filePath: string): Promise<string> {\n    const fs = require(\'fs\').promises;\n    return fs.readFile(filePath, \'utf-8\');\n  }\n\n  private generateId(): string {\n    return `regression-diff-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n</create-file>\n</function_calls>'}