"""
Evidence Chain Vulnerability Tests v1.0
Implements comprehensive evidence chain vulnerability detection for Era-1

This module provides evidence chain vulnerability detection:
- Hash inconsistency tests
- YAML anchors destruction tests
- JSON canonicalization tests
- Event-stream missing field tests
- Evidence completeness verification
- Hash registry validation
"""

import hashlib
import json
import re
import uuid
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path

try:
    from rfc8785 import canonicalize
    JCS_AVAILABLE = True
except ImportError:
    JCS_AVAILABLE = False


class Severity(Enum):
    """Severity levels for vulnerabilities"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


class TestStatus(Enum):
    """Test status"""
    PASSED = "PASSED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"
    ERROR = "ERROR"


@dataclass
class Vulnerability:
    """Represents an evidence chain vulnerability"""
    vulnerability_id: str
    test_id: str
    severity: Severity
    description: str
    evidence: Dict
    affected_artifacts: List[str] = field(default_factory=list)
    affected_events: List[str] = field(default_factory=list)
    remediation: Optional[str] = None


@dataclass
class TestResult:
    """Result of a vulnerability test"""
    test_id: str
    test_name: str
    status: TestStatus
    score: float  # 0.0 to 100.0
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    metadata: Dict = field(default_factory=dict)
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())


class EvidenceChainVulnerabilityTests:
    """
    Evidence chain vulnerability detection class
    
    Implements comprehensive evidence chain vulnerability detection
    """
    
    def __init__(self, workspace: str = "/workspace"):
        self.workspace = Path(workspace)
        self.evidence_dir = self.workspace / "ecosystem" / ".evidence"
        self.governance_dir = self.workspace / "ecosystem" / ".governance"
        
        # Load data
        self.artifacts = self._load_artifacts()
        self.events = self._load_events()
        self.hash_registry = self._load_hash_registry()
    
    def _load_artifacts(self) -> List[Dict]:
        """Load all evidence artifacts"""
        artifacts = []
        for artifact_file in sorted(self.evidence_dir.glob("step-*.json")):
            with open(artifact_file, 'r') as f:
                artifact = json.load(f)
                artifacts.append(artifact)
        return artifacts
    
    def _load_events(self) -> List[Dict]:
        """Load all events from event stream"""
        events = []
        event_stream_file = self.governance_dir / "event-stream.jsonl"
        if event_stream_file.exists():
            with open(event_stream_file, 'r') as f:
                for line in f:
                    if line.strip():
                        try:
                            events.append(json.loads(line))
                        except json.JSONDecodeError:
                            continue
        return events
    
    def _load_hash_registry(self) -> Dict:
        """Load hash registry"""
        registry_file = self.governance_dir / "hash-registry.json"
        if registry_file.exists():
            with open(registry_file, 'r') as f:
                return json.load(f)
        return {}
    
    # ========== Test 1: Hash Inconsistency Test ==========
    
    def test_hash_inconsistency(self) -> TestResult:
        """
        Test 1: Hash Inconsistency Test
        
        Verifies that all artifact hashes are consistent with their content.
        """
        vulnerabilities = []
        tested_artifacts = 0
        failed_artifacts = 0
        
        for artifact in self.artifacts:
            tested_artifacts += 1
            artifact_id = artifact.get("artifact_id", "UNKNOWN")
            
            # Get expected hash
            expected_hash = artifact.get("sha256_hash")
            if not expected_hash:
                failed_artifacts += 1
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    test_id="EC-1",
                    severity=Severity.CRITICAL,
                    description="Artifact missing sha256_hash field",
                    evidence={"artifact_id": artifact_id},
                    affected_artifacts=[artifact_id],
                    remediation="Add sha256_hash field with canonicalized SHA256 hash"
                ))
                continue
            
            # Recompute hash from artifact content
            try:
                # Remove hash field before recomputing
                artifact_copy = artifact.copy()
                artifact_copy.pop("sha256_hash", None)
                artifact_copy.pop("canonical_hash", None)
                
                # Canonicalize and hash
                if JCS_AVAILABLE:
                    canonicalized = canonicalize(artifact_copy)
                else:
                    canonicalized = json.dumps(artifact_copy, sort_keys=True, separators=(',', ':'))
                
                recomputed_hash = hashlib.sha256(canonicalized.encode()).hexdigest()
                
                if recomputed_hash != expected_hash:
                    failed_artifacts += 1
                    vulnerabilities.append(Vulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        test_id="EC-1",
                        severity=Severity.CRITICAL,
                        description=f"Hash inconsistency detected",
                        evidence={
                            "artifact_id": artifact_id,
                            "expected_hash": expected_hash,
                            "recomputed_hash": recomputed_hash
                        },
                        affected_artifacts=[artifact_id],
                        remediation="Re-canonicalize artifact and update sha256_hash field"
                    ))
            except Exception as e:
                failed_artifacts += 1
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    test_id="EC-1",
                    severity=Severity.HIGH,
                    description=f"Failed to recompute hash: {str(e)}",
                    evidence={"artifact_id": artifact_id, "error": str(e)},
                    affected_artifacts=[artifact_id],
                    remediation="Fix artifact structure or canonicalization logic"
                ))
        
        score = ((tested_artifacts - failed_artifacts) / tested_artifacts * 100) if tested_artifacts > 0 else 100
        
        return TestResult(
            test_id="EC-1",
            test_name="Hash Inconsistency Test",
            status=TestStatus.PASSED if failed_artifacts == 0 else TestStatus.FAILED,
            score=score,
            vulnerabilities=vulnerabilities
        )
    
    # ========== Test 2: YAML Anchors Destruction Test ==========
    
    def test_yaml_anchors_destruction(self) -> TestResult:
        """
        Test 2: YAML Anchors Destruction Test
        
        Verifies that YAML anchors are properly resolved during JSON conversion.
        """
        vulnerabilities = []
        
        # Check if any YAML files exist in .evidence/
        yaml_files = list(self.evidence_dir.glob("*.yaml")) + list(self.evidence_dir.glob("*.yml"))
        
        if not yaml_files:
            return TestResult(
                test_id="EC-2",
                test_name="YAML Anchors Destruction Test",
                status=TestStatus.SKIPPED,
                score=100.0,
                vulnerabilities=[],
                metadata={"reason": "No YAML files found in .evidence/"}
            )
        
        # Check for YAML anchors
        anchor_pattern = r'&\w+'
        reference_pattern = r'\*\w+'
        
        for yaml_file in yaml_files:
            with open(yaml_file, 'r') as f:
                content = f.read()
                
                anchors = re.findall(anchor_pattern, content)
                references = re.findall(reference_pattern, content)
                
                if anchors or references:
                    vulnerabilities.append(Vulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        test_id="EC-2",
                        severity=Severity.HIGH,
                        description="YAML file contains anchors or references",
                        evidence={
                            "file": str(yaml_file),
                            "anchors": anchors,
                            "references": references
                        },
                        remediation="Convert YAML to JSON with anchors resolved"
                    ))
        
        score = 100.0 if not vulnerabilities else 0.0
        
        return TestResult(
            test_id="EC-2",
            test_name="YAML Anchors Destruction Test",
            status=TestStatus.PASSED if not vulnerabilities else TestStatus.FAILED,
            score=score,
            vulnerabilities=vulnerabilities
        )
    
    # ========== Test 3: JSON Canonicalization Test ==========
    
    def test_json_canonicalization(self) -> TestResult:
        """
        Test 3: JSON Canonicalization Test
        
        Verifies that all JSON artifacts are properly canonicalized.
        """
        vulnerabilities = []
        
        if not JCS_AVAILABLE:
            return TestResult(
                test_id="EC-3",
                test_name="JSON Canonicalization Test",
                status=TestStatus.ERROR,
                score=0.0,
                vulnerabilities=[Vulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    test_id="EC-3",
                    severity=Severity.HIGH,
                    description="RFC8785 canonicalization not available",
                    evidence={},
                    remediation="Install rfc8785 package: pip install rfc8785"
                )],
                metadata={"error": "RFC8785 not installed"}
            )
        
        tested_artifacts = 0
        failed_artifacts = 0
        
        for artifact in self.artifacts:
            tested_artifacts += 1
            artifact_id = artifact.get("artifact_id", "UNKNOWN")
            
            try:
                # Canonicalize using JCS
                canonicalized = canonicalize(artifact)
                
                # Verify canonicalization output
                if not isinstance(canonicalized, str):
                    failed_artifacts += 1
                    vulnerabilities.append(Vulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        test_id="EC-3",
                        severity=Severity.HIGH,
                        description="Canonicalization did not produce string output",
                        evidence={"artifact_id": artifact_id, "type": type(canonicalized)},
                        affected_artifacts=[artifact_id],
                        remediation="Fix artifact structure for JCS canonicalization"
                    ))
                
                # Verify UTF-8 encoding
                try:
                    canonicalized.encode('utf-8')
                except UnicodeEncodeError:
                    failed_artifacts += 1
                    vulnerabilities.append(Vulnerability(
                        vulnerability_id=str(uuid.uuid4()),
                        test_id="EC-3",
                        severity=Severity.MEDIUM,
                        description="Canonicalized output not UTF-8 encodable",
                        evidence={"artifact_id": artifact_id},
                        affected_artifacts=[artifact_id],
                        remediation="Fix artifact encoding"
                    ))
                
            except Exception as e:
                failed_artifacts += 1
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    test_id="EC-3",
                    severity=Severity.HIGH,
                    description=f"Canonicalization failed: {str(e)}",
                    evidence={"artifact_id": artifact_id, "error": str(e)},
                    affected_artifacts=[artifact_id],
                    remediation="Fix artifact structure for JCS canonicalization"
                ))
        
        score = ((tested_artifacts - failed_artifacts) / tested_artifacts * 100) if tested_artifacts > 0 else 100
        
        return TestResult(
            test_id="EC-3",
            test_name="JSON Canonicalization Test",
            status=TestStatus.PASSED if failed_artifacts == 0 else TestStatus.FAILED,
            score=score,
            vulnerabilities=vulnerabilities
        )
    
    # ========== Test 4: Event-Stream Missing Field Test ==========
    
    def test_event_stream_missing_fields(self) -> TestResult:
        """
        Test 4: Event-Stream Missing Field Test
        
        Verifies that all events in event stream have required fields.
        """
        required_fields = ["uuid", "timestamp", "type", "payload", "canonical_hash"]
        
        vulnerabilities = []
        total_events = len(self.events)
        failed_events = 0
        
        for i, event in enumerate(self.events):
            missing_fields = [f for f in required_fields if f not in event]
            
            if missing_fields:
                failed_events += 1
                vulnerabilities.append(Vulnerability(
                    vulnerability_id=str(uuid.uuid4()),
                    test_id="EC-4",
                    severity=Severity.CRITICAL,
                    description="Event missing required fields",
                    evidence={
                        "event_index": i,
                        "event_id": event.get("uuid", "UNKNOWN"),
                        "missing_fields": missing_fields
                    },
                    affected_events=[event.get("uuid", "UNKNOWN")],
                    remediation=f"Add missing fields: {', '.join(missing_fields)}"
                ))
        
        score = ((total_events - failed_events) / total_events * 100) if total_events > 0 else 100
        
        return TestResult(
            test_id="EC-4",
            test_name="Event-Stream Missing Field Test",
            status=TestStatus.PASSED if failed_events == 0 else TestStatus.FAILED,
            score=score,
            vulnerabilities=vulnerabilities
        )
    
    # ========== Test 5: Evidence Completeness Test ==========
    
    def test_evidence_completeness(self) -> TestResult:
        """
        Test 5: Evidence Completeness Test
        
        Verifies that .evidence/ directory is complete.
        """
        vulnerabilities = []
        
        # Check for step-*.json files
        step_files = sorted(self.evidence_dir.glob("step-*.json"))
        expected_steps = list(range(1, 11))  # Steps 1-10
        existing_steps = [int(f.stem.split('-')[1]) for f in step_files]
        
        missing_steps = set(expected_steps) - set(existing_steps)
        
        if missing_steps:
            vulnerabilities.append(Vulnerability(
                vulnerability_id=str(uuid.uuid4()),
                test_id="EC-5",
                severity=Severity.CRITICAL,
                description=f"Missing step artifacts",
                evidence={"missing_steps": sorted(missing_steps)},
                remediation=f"Generate missing step artifacts: {', '.join(f'step-{s}.json' for s in sorted(missing_steps))}"
            ))
        
        # Check for artifacts directory
        artifacts_dir = self.evidence_dir / "artifacts"
        if not artifacts_dir.exists():
            vulnerabilities.append(Vulnerability(
                vulnerability_id=str(uuid.uuid4()),
                test_id="EC-5",
                severity=Severity.HIGH,
                description="Missing artifacts directory",
                evidence={"expected_path": str(artifacts_dir)},
                remediation="Create .evidence/artifacts/ directory"
            ))
        
        # Check for events directory
        events_dir = self.evidence_dir / "events"
        if not events_dir.exists():
            vulnerabilities.append(Vulnerability(
                vulnerability_id=str(uuid.uuid4()),
                test_id="EC-5",
                severity=Severity.HIGH,
                description="Missing events directory",
                evidence={"expected_path": str(events_dir)},
                remediation="Create .evidence/events/ directory"
            ))
        
        # Check for registry directory
        registry_dir = self.evidence_dir / "registry"
        if not registry_dir.exists():
            vulnerabilities.append(Vulnerability(
                vulnerability_id=str(uuid.uuid4()),
                test_id="EC-5",
                severity=Severity.HIGH,
                description="Missing registry directory",
                evidence={"expected_path": str(registry_dir)},
                remediation="Create .evidence/registry/ directory"
            ))
        
        score = 100.0 if not vulnerabilities else 0.0
        
        return TestResult(
            test_id="EC-5",
            test_name="Evidence Completeness Test",
            status=TestStatus.PASSED if not vulnerabilities else TestStatus.FAILED,
            score=score,
            vulnerabilities=vulnerabilities
        )
    
    # ========== Test 6: Hash Registry Test ==========
    
    def test_hash_registry(self) -> TestResult:
        """
        Test 6: Hash Registry Test
        
        Verifies that hash registry exists and contains all artifact hashes.
        """
        vulnerabilities = []
        
        # Check if hash registry exists
        if not self.hash_registry:
            vulnerabilities.append(Vulnerability(
                vulnerability_id=str(uuid.uuid4()),
                test_id="EC-6",
                severity=Severity.CRITICAL,
                description="Hash registry does not exist or is empty",
                evidence={"registry_path": str(self.governance_dir / "hash-registry.json")},
                remediation="Generate hash-registry.json with all artifact hashes"
            ))
            return TestResult(
                test_id="EC-6",
                test_name="Hash Registry Test",
                status=TestStatus.FAILED,
                score=0.0,
                vulnerabilities=vulnerabilities
            )
        
        # Check if all artifact hashes are in registry
        artifact_hashes_in_registry = set(self.hash_registry.get("artifacts", {}).keys())
        expected_artifact_hashes = {art.get("sha256_hash") for art in self.artifacts if art.get("sha256_hash")}
        
        missing_hashes = expected_artifact_hashes - artifact_hashes_in_registry
        
        if missing_hashes:
            vulnerabilities.append(Vulnerability(
                vulnerability_id=str(uuid.uuid4()),
                test_id="EC-6",
                severity=Severity.HIGH,
                description="Artifact hashes missing from registry",
                evidence={"missing_hashes": list(missing_hashes)},
                remediation="Add missing artifact hashes to hash registry"
            ))
        
        # Check for hash translation table (Era-1 to Era-2)
        if "hash_translation_table" not in self.hash_registry:
            vulnerabilities.append(Vulnerability(
                vulnerability_id=str(uuid.uuid4()),
                test_id="EC-6",
                severity=Severity.MEDIUM,
                description="Hash translation table not defined",
                evidence={},
                remediation="Add hash_translation_table for cross-era migration"
            ))
        
        score = 100.0 if not vulnerabilities else 0.0
        
        return TestResult(
            test_id="EC-6",
            test_name="Hash Registry Test",
            status=TestStatus.PASSED if not vulnerabilities else TestStatus.FAILED,
            score=score,
            vulnerabilities=vulnerabilities
        )
    
    # ========== Comprehensive Testing ==========
    
    def run_all_tests(self) -> Dict:
        """
        Run all evidence chain vulnerability tests and return comprehensive results.
        """
        results = {
            "test_run_id": str(uuid.uuid4()),
            "timestamp": datetime.utcnow().isoformat(),
            "test_results": {},
            "summary": {
                "total_tests": 0,
                "passed": 0,
                "failed": 0,
                "skipped": 0,
                "error": 0,
                "overall_score": 0.0
            },
            "vulnerabilities": [],
            "critical_vulnerabilities": 0,
            "high_vulnerabilities": 0,
            "medium_vulnerabilities": 0,
            "low_vulnerabilities": 0
        }
        
        # Run all tests
        print("\n" + "="*70)
        print("ğŸ” Evidence Chain Vulnerability Tests - Running All Tests")
        print("="*70)
        
        # Test 1: Hash Inconsistency
        print("\n[Test 1/6] Hash Inconsistency Test...")
        result = self.test_hash_inconsistency()
        results["test_results"]["EC-1"] = self._result_to_dict(result)
        self._update_summary(results, result)
        print(f"  Status: {result.status.value} | Score: {result.score:.1f}/100 | Vulnerabilities: {len(result.vulnerabilities)}")
        
        # Test 2: YAML Anchors Destruction
        print("\n[Test 2/6] YAML Anchors Destruction Test...")
        result = self.test_yaml_anchors_destruction()
        results["test_results"]["EC-2"] = self._result_to_dict(result)
        self._update_summary(results, result)
        print(f"  Status: {result.status.value} | Score: {result.score:.1f}/100 | Vulnerabilities: {len(result.vulnerabilities)}")
        
        # Test 3: JSON Canonicalization
        print("\n[Test 3/6] JSON Canonicalization Test...")
        result = self.test_json_canonicalization()
        results["test_results"]["EC-3"] = self._result_to_dict(result)
        self._update_summary(results, result)
        print(f"  Status: {result.status.value} | Score: {result.score:.1f}/100 | Vulnerabilities: {len(result.vulnerabilities)}")
        
        # Test 4: Event-Stream Missing Fields
        print("\n[Test 4/6] Event-Stream Missing Field Test...")
        result = self.test_event_stream_missing_fields()
        results["test_results"]["EC-4"] = self._result_to_dict(result)
        self._update_summary(results, result)
        print(f"  Status: {result.status.value} | Score: {result.score:.1f}/100 | Vulnerabilities: {len(result.vulnerabilities)}")
        
        # Test 5: Evidence Completeness
        print("\n[Test 5/6] Evidence Completeness Test...")
        result = self.test_evidence_completeness()
        results["test_results"]["EC-5"] = self._result_to_dict(result)
        self._update_summary(results, result)
        print(f"  Status: {result.status.value} | Score: {result.score:.1f}/100 | Vulnerabilities: {len(result.vulnerabilities)}")
        
        # Test 6: Hash Registry
        print("\n[Test 6/6] Hash Registry Test...")
        result = self.test_hash_registry()
        results["test_results"]["EC-6"] = self._result_to_dict(result)
        self._update_summary(results, result)
        print(f"  Status: {result.status.value} | Score: {result.score:.1f}/100 | Vulnerabilities: {len(result.vulnerabilities)}")
        
        # Calculate overall score
        if results["summary"]["total_tests"] > 0:
            total_score = sum(r["score"] for r in results["test_results"].values())
            results["summary"]["overall_score"] = total_score / len(results["test_results"])
        
        # Collect all vulnerabilities
        for test_result in results["test_results"].values():
            for vulnerability in test_result.get("vulnerabilities", []):
                results["vulnerabilities"].append(vulnerability)
                if vulnerability["severity"] == "CRITICAL":
                    results["critical_vulnerabilities"] += 1
                elif vulnerability["severity"] == "HIGH":
                    results["high_vulnerabilities"] += 1
                elif vulnerability["severity"] == "MEDIUM":
                    results["medium_vulnerabilities"] += 1
                elif vulnerability["severity"] == "LOW":
                    results["low_vulnerabilities"] += 1
        
        return results
    
    def _result_to_dict(self, result: TestResult) -> Dict:
        """Convert TestResult to dict"""
        return {
            "test_id": result.test_id,
            "test_name": result.test_name,
            "status": result.status.value,
            "score": result.score,
            "vulnerabilities": [
                {
                    "vulnerability_id": v.vulnerability_id,
                    "test_id": v.test_id,
                    "severity": v.severity.value,
                    "description": v.description,
                    "evidence": v.evidence,
                    "affected_artifacts": v.affected_artifacts,
                    "affected_events": v.affected_events,
                    "remediation": v.remediation
                }
                for v in result.vulnerabilities
            ],
            "metadata": result.metadata,
            "timestamp": result.timestamp
        }
    
    def _update_summary(self, results: Dict, result: TestResult):
        """Update summary with test result"""
        results["summary"]["total_tests"] += 1
        if result.status == TestStatus.PASSED:
            results["summary"]["passed"] += 1
        elif result.status == TestStatus.FAILED:
            results["summary"]["failed"] += 1
        elif result.status == TestStatus.SKIPPED:
            results["summary"]["skipped"] += 1
        elif result.status == TestStatus.ERROR:
            results["summary"]["error"] += 1
    
    def generate_report(self, results: Dict, output_file: Optional[Path] = None) -> str:
        """Generate a comprehensive vulnerability report"""
        
        report_lines = [
            "# Evidence Chain Vulnerability Test Report",
            "",
            f"**Test Run ID**: {results['test_run_id']}",
            f"**Timestamp**: {results['timestamp']}",
            "",
            "## Summary",
            "",
            f"- **Total Tests**: {results['summary']['total_tests']}",
            f"- **Passed**: {results['summary']['passed']}",
            f"- **Failed**: {results['summary']['failed']}",
            f"- **Skipped**: {results['summary']['skipped']}",
            f"- **Error**: {results['summary']['error']}",
            f"- **Overall Score**: {results['summary']['overall_score']:.1f}/100",
            "",
            f"## Vulnerability Summary",
            "",
            f"- **CRITICAL**: {results['critical_vulnerabilities']}",
            f"- **HIGH**: {results['high_vulnerabilities']}",
            f"- **MEDIUM**: {results['medium_vulnerabilities']}",
            f"- **LOW**: {results['low_vulnerabilities']}",
            ""
        ]
        
        # Add individual test results
        report_lines.append("## Test Results")
        report_lines.append("")
        
        for test_id, test_result in results["test_results"].items():
            status_emoji = "âœ…" if test_result["status"] == "PASSED" else "â­ï¸" if test_result["status"] == "SKIPPED" else "âŒ"
            report_lines.append(f"### {status_emoji} {test_result['test_name']} ({test_id})")
            report_lines.append("")
            report_lines.append(f"- **Status**: {test_result['status']}")
            report_lines.append(f"- **Score**: {test_result['score']:.1f}/100")
            
            if test_result["vulnerabilities"]:
                report_lines.append(f"- **Vulnerabilities**: {len(test_result['vulnerabilities'])}")
                report_lines.append("")
                report_lines.append("**Vulnerability Details**:")
                for vuln in test_result["vulnerabilities"]:
                    report_lines.append(f"- **[{vuln['severity']}]** {vuln['description']}")
                    if vuln.get("remediation"):
                        report_lines.append(f"  - Remediation: {vuln['remediation']}")
            
            report_lines.append("")
        
        # Add conclusion
        report_lines.append("## Conclusion")
        report_lines.append("")
        
        if results['critical_vulnerabilities'] > 0:
            report_lines.append("âŒ **CRITICAL VULNERABILITIES DETECTED** - Evidence chain cannot be sealed.")
        elif results['high_vulnerabilities'] > 0:
            report_lines.append("âš ï¸  **HIGH SEVERITY VULNERABILITIES** - Fix required before sealing.")
        elif results['summary']['overall_score'] >= 90.0:
            report_lines.append("âœ… **EVIDENCE CHAIN SECURE** - Ready for Era-1 sealing.")
        elif results['summary']['overall_score'] >= 70.0:
            report_lines.append("âš ï¸  **NEEDS IMPROVEMENT** - Consider fixing vulnerabilities before sealing.")
        else:
            report_lines.append("âŒ **NOT SECURE** - Significant vulnerabilities detected.")
        
        report_text = "\n".join(report_lines)
        
        if output_file:
            output_file.parent.mkdir(parents=True, exist_ok=True)
            with open(output_file, 'w') as f:
                f.write(report_text)
            print(f"\nâœ“ Report saved to: {output_file}")
        
        return report_text


def main():
    """Main entry point"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Evidence Chain Vulnerability Tests v1.0")
    parser.add_argument("--workspace", default="/workspace", help="Workspace directory")
    parser.add_argument("--output", help="Output file for report")
    parser.add_argument("--json", action="store_true", help="Output JSON format")
    
    args = parser.parse_args()
    
    # Initialize tester
    tester = EvidenceChainVulnerabilityTests(workspace=args.workspace)
    
    # Run all tests
    results = tester.run_all_tests()
    
    # Print summary
    print("\n" + "="*70)
    print("ğŸ“Š Test Summary")
    print("="*70)
    print(f"Total Tests: {results['summary']['total_tests']}")
    print(f"Passed: {results['summary']['passed']}")
    print(f"Failed: {results['summary']['failed']}")
    print(f"Skipped: {results['summary']['skipped']}")
    print(f"Error: {results['summary']['error']}")
    print(f"Overall Score: {results['summary']['overall_score']:.1f}/100")
    print(f"\nVulnerabilities:")
    print(f"  CRITICAL: {results['critical_vulnerabilities']}")
    print(f"  HIGH: {results['high_vulnerabilities']}")
    print(f"  MEDIUM: {results['medium_vulnerabilities']}")
    print(f"  LOW: {results['low_vulnerabilities']}")
    
    # Generate report
    output_file = Path(args.output) if args.output else Path("reports") / f"evidence-chain-vulnerability-report-{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
    report = tester.generate_report(results, output_file)
    
    # Output JSON if requested
    if args.json:
        json_file = output_file.with_suffix('.json')
        with open(json_file, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nâœ“ JSON report saved to: {json_file}")
    
    # Exit with appropriate code
    if results['critical_vulnerabilities'] > 0 or results['high_vulnerabilities'] > 0:
        print("\nâŒ Tests FAILED - Fix vulnerabilities before Era-1 sealing")
        return 1
    elif results['summary']['overall_score'] < 70.0:
        print("\nâš ï¸  Tests PASSED with WARNINGS - Consider improvements")
        return 0
    else:
        print("\nâœ… Tests PASSED - Evidence chain secure for Era-1 sealing")
        return 0


if __name__ == "__main__":
    exit(main())