{
  "internal_retrieval": {
    "phase": "Internal Retrieval (内网检索)",
    "date": "2026-02-05",
    "documents_analyzed": 2,
    "findings": {
      "/workspace/MONICA_AI_AGENT_COMPREHENSIVE_ANALYSIS (1).md": {
        "core_modules": [],
        "key_features": [
          "：將複雜任務分解為明確的步驟。\\n\\n```\\n\\\"按照這些步驟操作",
          "（規劃、分析）",
          "：\\n- 為每個模型建立特定的系統提示\\n- 針對不同任務類型使用不同的提示模板\\n- 實施提示版本控制和 A/B 測試\\n\\n#### 2. 工具層\\n\\n以下是為代碼編輯器 Agent 設計的核心工具集",
          "：將 Agent 的輸出視為初始草稿\\n\\nAI Agent 在快速生成高質量初始内容方面表現出色，但應將其輸出視為起點而非終點。最佳實踐包括",
          "：\\n\\n```\\n輸入：原始內容/數據\\n  ↓\\n內容分析→ 識別關鍵信息\\n  ↓\\n結構化→ 組織邏輯流\\n  ↓\\n視覺化映射→ 選擇圖表類型\\n  ↓\\n模板應用→ 應用設計\\n  ↓\\n生成→ 輸出 Markdown/Slides/PDF\\n```\\n\\n### 技術棧推薦\\n\\n對於企業級實現，推薦的技術組合",
          "：增強的 Agent、性能報告、故障排查指南\\n\\n### 第三階段",
          "：工作的 MVP、性能基準、成本估算\\n\\n### 第二階段",
          "：\\n\\n假設用戶需要了解「2026 年 AI 代碼編輯工具的市場趨勢」。Deep Research 會自動：\\n\\n1. 分解為子問題：「有哪些主要的 AI 代碼編輯工具？」、「市場規模是多少？」、「發展方向是什麼？」、「企業採用率如何？」\\n2. 搜索各類源：Gartner 魔力象限報告、StackOverflow 開發者調查、GitHub Trends、公司新聞發布\\n3. 綜合信息：對比工具功能、分析市場增長率、識別新興技術方向\\n4. 生成報告",
          "：\\n  - 仔細閱讀 API 提供商的服務條款\\n  - 理解商業使用的含義\\n  - 如有疑問，尋求法律建議\\n  - 考慮多個模型選項以避免供應商鎖定\\n\\n---\\n\\n## 第六部分：實施路線圖\\n\\n### 第一階段",
          "：代理按預定義順序工作。例如",
          "：您的提示和後續反饋指導工作。Cursor 發現，最有效的工作流程包括：\\n- 首先用「@codebase」標記激活代碼庫感知模式\\n- 使用「#file」語法引用特定文件\\n- 在需要時添加上下文性評論（例如「#TODO(agent): refactor this function\\\"）\\n\\n### 2. 計劃驅動的開發模式\\n\\n芝加哥大學的研究表明，經驗豐富的開發人員在生成代碼前更可能進行計劃。[2] Cursor 通過「計劃模式」實現了這一點，通過按 `Shift+Tab` 激活。在計劃模式中，代理：\\n\\n1. 研究您的代碼庫以找到相關文件\\n2. 提出澄清性問題\\n3. 創建詳細的實施計劃\\n4. 等待您的批准再開始編碼\\n\\nMonica 的 Deep Research 可以提供類似的規劃能力。當要求創建代碼時，首先請求一個詳細的計劃而不是立即編碼。\\n\\n### 3. 工具聚焦的架構\\n\\nAnthrop IC 的研究發現，最成功的 AI Agent 實現使用簡單的、可組合的模式，而不是複雜的框架。[3] 關鍵原則包括",
          "：\\n- Prometheus（指標收集）\\n- ELK Stack（日誌分析）\\n- Jaeger（分佈式追蹤）\\n\\n---\\n\\n## 第五部分",
          "：多個代理討論和協商解決方案。例如",
          "：\\n- Python：LangGraph（工作流編排）或 Anthropic SDK（結構化任務）\\n- Node.js：LangChain.js（如果需要 JavaScript 優先方法）\\n- Go",
          "：\\n\\n一個研究人員用 Deep Research 生成了 15 頁的市場分析報告。使用 Create Slides，系統自動：\\n\\n1. 識別報告的關鍵部分（執行摘要、市場規模、競爭格局、趨勢、建議）\\n2. 為每個部分創建適當的幻燈片\\n3. 將數據表自動轉換為柱狀圖、餅圖或折線圖\\n4. 應用企業品牌指南（顏色、字體、標識）\\n5. 生成 20 張專業幻燈片的演示文稿\\n\\n從報告到演示文稿的轉換時間從 2-3 小時減少到 2-3 分鐘。\\n\\n---\\n\\n## 第二部分",
          "：\\n1. 監控實際使用和性能\\n2. 收集用戶反饋\\n3. 識別改進領域\\n4. 迭代提示和工具\\n5. 評估新模型和功能\\n\\n---\\n\\n## 結論\\n\\nMonica AI 代表了 AI 驅動工具的發展方向。通過理解其核心功能、應用最佳實踐、架構可復刻的系統，組織可以在自有環境中實現類似的能力。成功的關鍵在於從小規模開始、逐步擴展、持續迭代和優化。\\n\\n最重要的是記住，AI Agent 是工具而非替代品。最有效的實現將 AI 的速度和規模與人類的判斷和創造力相結合。\\n\\n---\\n\\n## 參考資源\\n\\n[1]: https://monica.im/help/Features/AI-Agent/Monica_Agent \\\"Monica Agent Official Documentation\\\"\\n[2]: https://cursor.com/blog/agent-best-practices \\\"Best Practices for Coding with Agents - Cursor\\\"\\n[3]: https://www.anthropic.com/research/building-effective-agents \\\"Building Effective Agents - Anthropic\\\"\\n[4]: https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns \\\"AI Agent Orchestration Patterns - Microsoft Azure\\\"\\n[5]: https",
          "：明確說明限制和邊界。\\n\\n```\\n\\\"約束條件",
          "：提供豐富的背景信息\\n\\nMonica AI Agent 的性能與所提供的上下文質量成正比。指定",
          "：生產就緒的系統、運維文檔、支援培訓\\n\\n### 第四階段",
          "：代理根據進度或複雜性動態轉移工作。例如：簡單函數由初級編碼代理處理，複雜系統架構由高級代理接手。\\n\\n### 5. 提示工程最佳實踐\\n\\n根據 UiPath 和 OpenAI 的最新研究（2025-2026），有效的 Agent 提示應包括",
          "：Cursor 為其代理提供了五個核心工具",
          "：\\n\\n```\\n輸入",
          "：\\n\\n較弱的提示：「分析 AI 代碼工具的市場\\\"\\n\\n優化的提示",
          "：使用 Agent 生成的分析作為決策支援，而不是決策本身\\n\\n---\\n\\n## 第三部分：代碼編輯器 Agent 的全球最前沿最佳實踐\\n\\n### 1. Cursor 的 Agent Harness 模型\\n\\nCursor 代表代碼編輯工具 AI 集成的最佳實踐。[2] 其 Agent Harness 由三個關鍵組件組成",
          "：多個代理同時工作在獨立子任務上。例如",
          "：定義什麼構成令人滿意的結果。\\n\\n```\\n\\\"我會認為這是成功的，如果：\\n- 所有現有測試通過\\n- 新功能有 100% 的測試覆蓋率\\n- 性能測試顯示改進\\n- 代碼審查通過\\\"\\n```\\n\\n---\\n\\n## 第四部分：在您的專案中復刻類似功能的技術架構\\n\\n### 架構概覽\\n\\n要在自有專案中復刻 Monica AI Agent 類似功能，需要設計一個由五層組成的系統",
          "：\\n\\n一家競爭分析公司需要監控 50 個競爭對手的定價和功能更新。手動方法需要每天 4-5 小時。使用 Browser Operator，該過程可以自動化"
        ],
        "technical_architecture": [],
        "best_practices": [],
        "challenges": [],
        "implementation_strategies": []
      },
      "/workspace/MONICA_AI_AGENT_ENGINEERING_SPECIFICATION.md": {
        "core_modules": [],
        "key_features": [
          "採用內容→結構→視覺化→渲染四層管道，將文本和數據轉換為專業演示文稿。核心優勢在於自動內容組織和視覺化選擇。\\n\\n三個模組各自獨立又相互補充，共同實現了一個完整的智能工作流系統。\\n\\n---\\n\\n## 參考資源\\n\\n[1]: https://monica.im/help/Features/AI-Agent/Monica_Agent \\\"Monica Agent - Official Documentation\\\"\\n\\n\\n---\\n\\n## 第二部分",
          "原則 5",
          "（導航控制）：\\n\\n```python\\nfrom selenium.webdriver.common.keys import Keys\\nfrom selenium.webdriver.common.action_chains import ActionChains\\n\\nclass NavigationController:\\n    \\\"\\\"\\\"導航控制引擎 - 執行自動化交互\\\"\\\"\\\"\\n    \\n    def __init__(self, driver, llm_client):\\n        self.driver = driver\\n        self.llm = llm_client\\n        self.action_history = []\\n    \\n    def execute_command(self, command: str, context: Dict) -> Dict:\\n        \\\"\\\"\\\"執行自然語言命令\\\"\\\"\\\"\\n        \\n        # 第一步：命令理解 - 使用 LLM 理解指令\\n        understood_action = self._understand_command(command, context)\\n        \\n        # 第二步：元素定位\\n        target_element = self._locate_element(\\n            understood_action[\\\"target\\\"],\\n            context[\\\"page_analysis\\\"]\\n        )\\n        \\n        if not target_element:\\n            return {\\n                \\\"success\\\": False,\\n                \\\"error\\\": f\\\"找不到目標元素: {understood_action['target']}\\\"\\n            }\\n        \\n        # 第三步：交互執行\\n        result = self._execute_interaction(\\n            target_element,\\n            understood_action[\\\"action\\\"],\\n            understood_action.get(\\\"parameters\\\", {})\\n        )\\n        \\n        # 第四步：狀態驗證\\n        verification = self._verify_action_result(understood_action[\\\"verification_criteria\\\"])\\n        \\n        # 記錄操作\\n        self.action_history.append({\\n            \\\"command\\\": command,\\n            \\\"action\\\": understood_action,\\n            \\\"result\\\": result,\\n            \\\"verification\\\": verification,\\n            \\\"timestamp\\\": datetime.now()\\n        })\\n        \\n        return {\\n            \\\"success\\\": verification[\\\"success\\\"],\\n            \\\"action_taken\\\": understood_action,\\n            \\\"verification\\\": verification,\\n            \\\"next_state\\\": self._capture_current_state()\\n        }\\n    \\n    def _understand_command(self, command: str, context: Dict) -> Dict:\\n        \\\"\\\"\\\"使用 LLM 理解自然語言命令\\\"\\\"\\\"\\n        \\n        understanding_prompt = f\\\"\\\"\\\"\\n        分析以下用戶命令，返回結構化的操作描述。\\n        \\n        命令: {command}\\n        \\n        當前頁面分析:\\n        - 標題: {context['page_analysis']['dom_structure']['title']}\\n        - URL: {context['page_analysis']['dom_structure']['url']}\\n        - 可用元素:\\n        {json.dumps(context['page_analysis']['interactive_elements'][:5], indent=2)}\\n        \\n        返回 JSON 格式:\\n        {{\\n            \\\"action\\\": \\\"click|fill|select|navigate|scroll|wait\\\",\\n            \\\"target\\\": \\\"要操作的元素描述\\\",\\n            \\\"parameters\\\": {{\\n                \\\"text\\\": \\\"如果是填充操作\\\",\\n                \\\"option\\\": \\\"如果是選擇操作\\\"\\n            }},\\n            \\\"verification_criteria\\\": \\\"操作完成後的驗證方式\\\"\\n        }}\\n        \\\"\\\"\\\"\\n        \\n        response = self.llm.create(\\n            model=\\\"gpt-4o\\\",\\n            messages=[{\\\"role\\\": \\\"user\\\", \\\"content\\\": understanding_prompt}]\\n        )\\n        \\n        return json.loads(response.content)\\n    \\n    def _locate_element(self, target_description: str, page_analysis: Dict) -> Optional[WebElement]:\\n        \\\"\\\"\\\"定位目標元素\\\"\\\"\\\"\\n        \\n        # 嘗試多種定位策略\\n        strategies = [\\n            self._locate_by_text,\\n            self._locate_by_attributes,\\n            self._locate_by_position,\\n            self._locate_by_visual_similarity\\n        ]\\n        \\n        for strategy in strategies:\\n            element = strategy(target_description, page_analysis)\\n            if element and element.is_displayed():\\n                return element\\n        \\n        return None\\n    \\n    def _locate_by_text(self, text: str, page_analysis: Dict) -> Optional[WebElement]:\\n        \\\"\\\"\\\"根據文本定位元素\\\"\\\"\\\"\\n        try",
          "：\\n\\n| 維度 | Monica | Cursor | GitHub Copilot |\\n|-----|--------|--------|----------------|\\n| 核心功能 | 深度研究 + 瀏覽器操作 + 幻燈片 | 多代理編排 + 代碼重構 + 計劃模式 | 代碼補全 + 聊天 + Pull Request |\\n| 定價 | $15-50/月 | $20/月 | $10-39/月 |\\n| 企業安全 | SOC 2 類型 II | 數據隱私承諾 | GitHub Advanced Security |\\n| IDE 支持 | VSCode + JetBrains | VSCode 優先 | 全 IDE 支持 |\\n| 優勢 | 工作流自動化 | 代碼重構能力 | 市場領導 + 生態 |\\n| 劣勢 | IDE 集成有限 | VSCode 依賴 | 功能相對基礎 |\\n\\n### 1.3 Browser Operator 模組",
          "（內容結構化）：\\n\\n```python\\nfrom typing import List, Tuple\\n\\nclass SlidesGenerator:\\n    \\\"\\\"\\\"幻燈片生成引擎\\\"\\\"\\\"\\n    \\n    def generate_presentation(self, content: str, style: str = \\\"professional\\\") -> str:\\n        \\\"\\\"\\\"從文本內容生成演示文稿\\\"\\\"\\\"\\n        \\n        # 第一步：內容分析\\n        analysis = self._analyze_content(content)\\n        \\n        # 第二步：結構化\\n        structure = self._structure_content(analysis)\\n        \\n        # 第三步：視覺化決策\\n        visualizations = self._decide_visualizations(structure)\\n        \\n        # 第四步：生成幻燈片\\n        slides = self._generate_slides(structure, visualizations, style)\\n        \\n        # 第五步：渲染輸出\\n        output_path = self._render_presentation(slides)\\n        \\n        return output_path\\n    \\n    def _analyze_content(self, content: str) -> Dict:\\n        \\\"\\\"\\\"分析內容結構\\\"\\\"\\\"\\n        \\n        # 使用 NLP 識別標題、段落、列表等\\n        analysis = {\\n            \\\"title\\\": self._extract_title(content),\\n            \\\"sections\\\": self._identify_sections(content),\\n            \\\"key_points\\\": self._extract_key_points(content),\\n            \\\"data_points\\\": self._identify_data_points(content),\\n            \\\"length\\\": len(content),\\n            \\\"language\\\": \\\"en\\\"\\n        }\\n        \\n        return analysis\\n    \\n    def _structure_content(self, analysis: Dict) -> List[Dict]:\\n        \\\"\\\"\\\"組織內容為幻燈片結構\\\"\\\"\\\"\\n        \\n        slides_structure = []\\n        \\n        # 第 1 張：標題幻燈片\\n        slides_structure.append({\\n            \\\"type\\\": \\\"title\\\",\\n            \\\"title\\\": analysis[\\\"title\\\"],\\n            \\\"subtitle\\\": \\\"Key Insights and Analysis\\\"\\n        })\\n        \\n        # 第 2 張：目錄\\n        slides_structure.append({\\n            \\\"type\\\": \\\"toc\\\",\\n            \\\"items\\\": [s[\\\"title\\\"] for s in analysis[\\\"sections\\\"][:5]]\\n        })\\n        \\n        # 後續幻燈片：內容\\n        for section in analysis[\\\"sections\\\"]:\\n            slides_structure.append({\\n                \\\"type\\\": \\\"content\\\",\\n                \\\"title\\\": section[\\\"title\\\"],\\n                \\\"content\\\": section[\\\"content\\\"],\\n                \\\"has_data\\\": len(section.get(\\\"data\\\", [])) > 0\\n            })\\n        \\n        # 最後一張：結論\\n        slides_structure.append({\\n            \\\"type\\\": \\\"conclusion\\\",\\n            \\\"title\\\": \\\"Key Takeaways\\\",\\n            \\\"points\\\": analysis[\\\"key_points\\\"][:5]\\n        })\\n        \\n        return slides_structure\\n    \\n    def _decide_visualizations(self, structure: List[Dict]) -> Dict:\\n        \\\"\\\"\\\"決定每張幻燈片的可視化方式\\\"\\\"\\\"\\n        \\n        visualizations = {}\\n        \\n        for i, slide in enumerate(structure):\\n            viz_decision = self._choose_visualization(slide)\\n            visualizations[i] = viz_decision\\n        \\n        return visualizations\\n    \\n    def _choose_visualization(self, slide: Dict) -> Dict:\\n        \\\"\\\"\\\"選擇最佳可視化方式\\\"\\\"\\\"\\n        \\n        if slide[\\\"type\\\"] == \\\"title\\\":\\n            return {\\\"type\\\": \\\"title\\\", \\\"style\\\": \\\"bold_gradient\\\"}\\n        elif slide[\\\"type\\\"] == \\\"toc\\\":\\n            return {\\\"type\\\": \\\"bullet_list\\\"}\\n        elif slide[\\\"type\\\"] == \\\"content\\\":\\n            if slide[\\\"has_data\\\"]:\\n                return {\\\"type\\\": \\\"chart\\\", \\\"chart_type\\\": self._select_chart_type(slide[\\\"content\\\"])}\\n            else:\\n                return {\\\"type\\\": \\\"text\\\", \\\"layout\\\": \\\"two_column\\\"}\\n        else:\\n            return {\\\"type\\\": \\\"text\\\", \\\"layout\\\": \\\"centered\\\"}\\n    \\n    def _select_chart_type(self, content: str) -> str:\\n        \\\"\\\"\\\"根據內容選擇圖表類型\\\"\\\"\\\"\\n        \\n        # 簡化的圖表選擇邏輯\\n        if \\\"trend\\\" in content.lower() or \\\"over time\\\" in content.lower():\\n            return \\\"line_chart\\\"\\n        elif \\\"compare\\\" in content.lower() or \\\"vs\\\" in content.lower():\\n            return \\\"bar_chart\\\"\\n        elif \\\"percentage\\\" in content.lower() or \\\"%\\\" in content:\\n            return \\\"pie_chart\\\"\\n        elif \\\"correlation\\\" in content.lower():\\n            return \\\"scatter_plot\\\"\\n        else:\\n            return \\\"bar_chart\\\"\\n    \\n    def _generate_slides(self, structure: List[Dict], visualizations: Dict, style: str) -> List[Dict]:\\n        \\\"\\\"\\\"生成幻燈片對象\\\"\\\"\\\"\\n        \\n        slides = []\\n        style_config = self._load_style_config(style)\\n        \\n        for i, slide_struct in enumerate(structure):\\n            slide = {\\n                \\\"index\\\": i,\\n                \\\"type\\\": slide_struct[\\\"type\\\"],\\n                \\\"content\\\": slide_struct,\\n                \\\"visualization\\\": visualizations.get(i, {}),\\n                \\\"style\\\": style_config,\\n                \\\"transitions\\\": self._select_transition(i, len(structure))\\n            }\\n            slides.append(slide)\\n        \\n        return slides\\n    \\n    def _render_presentation(self, slides: List[Dict]) -> str:\\n        \\\"\\\"\\\"渲染為 PowerPoint 或 PDF\\\"\\\"\\\"\\n        \\n        from pptx import Presentation\\n        from pptx.util import Inches, Pt\\n        \\n        prs = Presentation()\\n        prs.slide_width = Inches(10)\\n        prs.slide_height = Inches(7.5)\\n        \\n        for slide_data in slides:\\n            slide_layout = prs.slide_layouts[self._get_layout_index(slide_data[\\\"type\\\"])]\\n            slide = prs.slides.add_slide(slide_layout)\\n            \\n            # 填充幻燈片內容\\n            self._fill_slide(slide, slide_data)\\n        \\n        # 保存演示文稿\\n        output_path = f\\\"/tmp/presentation_{datetime.now().timestamp()}.pptx\\\"\\n        prs.save(output_path)\\n        \\n        return output_path\\n    \\n    def _fill_slide(self, slide, slide_data: Dict):\\n        \\\"\\\"\\\"填充幻燈片內容\\\"\\\"\\\"\\n        \\n        # 根據幻燈片類型填充\\n        if slide_data[\\\"type\\\"] == \\\"title\\\":\\n            self._fill_title_slide(slide, slide_data[\\\"content\\\"])\\n        elif slide_data[\\\"type\\\"] == \\\"content\\\":\\n            self._fill_content_slide(slide, slide_data)\\n        else:\\n            self._fill_generic_slide(slide, slide_data)\\n    \\n    # 輔助方法\\n    def _extract_title(self, content: str) -> str:\\n        \\\"\\\"\\\"提取標題\\\"\\\"\\\"\\n        lines = content.split(\\\"\\\\n\\\")\\n        return lines[0] if lines else \\\"Untitled\\\"\\n    \\n    def _identify_sections(self, content: str) -> List[Dict]:\\n        \\\"\\\"\\\"識別內容部分\\\"\\\"\\\"\\n        sections = []\\n        current_section = {\\\"title\\\": \\\"\\\", \\\"content\\\": \\\"\\\"}\\n        \\n        for line in content.split(\\\"\\\\n\\\"):\\n            if line.startswith(\\\"#\\\"):  # 簡化的 Markdown 檢測\\n                if current_section[\\\"content\\\"]:\\n                    sections.append(current_section)\\n                current_section = {\\\"title\\\": line.strip(\\\"#\\\").strip(), \\\"content\\\": \\\"\\\"}\\n            else:\\n                current_section[\\\"content\\\"] += line + \\\"\\\\n\\\"\\n        \\n        if current_section[\\\"content\\\"]:\\n            sections.append(current_section)\\n        \\n        return sections\\n    \\n    def _extract_key_points(self, content: str) -> List[str]:\\n        \\\"\\\"\\\"提取關鍵點\\\"\\\"\\\"\\n        lines = content.split(\\\"\\\\n\\\")\\n        key_points = []\\n        \\n        for line in lines",
          "：列出您期望在研究中找到的關鍵信息點。例如",
          "（群組對話）：\\n\\n```python\\nclass GroupChatOrchestration:\\n    \\\"\\\"\\\"群組對話編排模式\\\"\\\"\\\"\\n    \\n    async def orchestrate_expert_panel(self, question: str, num_rounds: int = 3) -> Dict:\\n        \\\"\\\"\\\"組織專家小組討論\\\"\\\"\\\"\\n        \\n        # 定義專家角色\\n        experts = {\\n            \\\"技術_專家\\\": {\\n                \\\"role\\\": \\\"技術架構與可擴展性評估\\\",\\n                \\\"agent\\\": self.technical_agent\\n            },\\n            \\\"商業_專家\\\": {\\n                \\\"role\\\": \\\"成本效益和商業價值評估\\\",\\n                \\\"agent\\\": self.business_agent\\n            },\\n            \\\"安全_專家\\\": {\\n                \\\"role\\\": \\\"安全性和合規評估\\\",\\n                \\\"agent\\\": self.security_agent\\n            },\\n            \\\"用戶_體驗_專家\\\": {\\n                \\\"role\\\": \\\"用戶體驗和採用評估\\\",\\n                \\\"agent\\\": self.ux_agent\\n            }\\n        }\\n        \\n        # 初始化對話\\n        conversation_history = [{\\n            \\\"role\\\": \\\"moderator\\\",\\n            \\\"message\\\": f\\\"問題：{question}\\\",\\n            \\\"timestamp\\\": datetime.now()\\n        }]\\n        \\n        # 進行多輪討論\\n        for round_num in range(num_rounds):\\n            print(f\\\"\\\\n=== 第 {round_num + 1} 輪討論 ===\\\")\\n            \\n            for expert_name, expert_config in experts.items():\\n                # 獲取該專家的觀點\\n                context = self._prepare_context(conversation_history, expert_name)\\n                \\n                perspective = await expert_config[\\\"agent\\\"].provide_perspective(\\n                    question=question,\\n                    context=context,\\n                    expert_role=expert_config[\\\"role\\\"]\\n                )\\n                \\n                # 記錄觀點\\n                conversation_history.append({\\n                    \\\"expert\\\": expert_name,\\n                    \\\"perspective\\\": perspective,\\n                    \\\"timestamp\\\": datetime.now(),\\n                    \\\"round\\\": round_num\\n                })\\n                \\n                # 其他專家可以對此評論（可選）\\n                if round_num < num_rounds - 1:\\n                    critiques = await self._collect_critiques(\\n                        perspective,\\n                        experts,\\n                        expert_name\\n                    )\\n                    conversation_history.extend(critiques)\\n        \\n        # 生成共識和建議\\n        consensus = await self._generate_consensus(conversation_history, experts)\\n        \\n        return {\\n            \\\"question\\\": question,\\n            \\\"conversation\\\": conversation_history,\\n            \\\"consensus\\\": consensus,\\n            \\\"recommendations\\\": self._synthesize_recommendations(consensus)\\n        }\\n    \\n    def _prepare_context(self, history: List[Dict], expert_name: str) -> str:\\n        \\\"\\\"\\\"準備該專家的背景信息\\\"\\\"\\\"\\n        relevant_messages = [\\n            msg for msg in history \\n            if msg.get(\\\"expert\\\") != expert_name\\n        ]\\n        return json.dumps(relevant_messages[-5:], indent=2)  # 最近 5 條\\n    \\n    async def _collect_critiques(self, perspective: str, experts: Dict, excluding: str) -> List[Dict]:\\n        \\\"\\\"\\\"收集其他專家的批評\\\"\\\"\\\"\\n        critiques = []\\n        \\n        for expert_name, config in experts.items():\\n            if expert_name == excluding:\\n                continue\\n            \\n            critique = await config[\\\"agent\\\"].provide_critique(\\n                perspective=perspective,\\n                expert_role=config[\\\"role\\\"]\\n            )\\n            \\n            critiques.append({\\n                \\\"expert\\\": expert_name,\\n                \\\"critique\\\": critique,\\n                \\\"timestamp\\\": datetime.now()\\n            })\\n        \\n        return critiques\\n    \\n    async def _generate_consensus(self, history: List[Dict], experts: Dict) -> Dict:\\n        \\\"\\\"\\\"生成小組共識\\\"\\\"\\\"\\n        \\n        # 使用 LLM 總結所有觀點並生成共識\\n        synthesis_prompt = f\\\"\\\"\\\"\\n        根據以下多位專家的討論，請生成一個共識要點：\\n        \\n        {json.dumps(history, indent=2, default=str)}\\n        \\n        共識應該包括：\\n        1. 所有專家同意的核心要點\\n        2. 存在的主要分歧\\n        3. 建議的行動方向\\n        \\\"\\\"\\\"\\n        \\n        response = await self.llm_client.create(\\n            messages=[{\\\"role\\\": \\\"user\\\", \\\"content\\\": synthesis_prompt}]\\n        )\\n        \\n        return response.content\\n    \\n    def _synthesize_recommendations(self, consensus: str) -> List[str]:\\n        \\\"\\\"\\\"根據共識合成建議\\\"\\\"\\\"\\n        # 簡化實現\\n        return [\\\"建議 1\\\", \\\"建議 2\\\", \\\"建議 3\\\"]\\n\\n# 使用示例\\norchestrator = GroupChatOrchestration(agents_dict, llm_client)\\nresult = asyncio.run(orchestrator.orchestrate_expert_panel(\\n    \\\"我們是否應該採用 GitHub Copilot Enterprise？\\\",\\n    num_rounds=3\\n))\\n```\\n\\n#### 模式 4",
          "原則 4",
          "：\\n\\n```\\n\\\"在提供最終答案之前：\\n1. 驗證[特定方面]與[參考源]\\n2. 檢查[特定可能的錯誤]\\n3. 交叉引用[相關領域的數據]\\n4. 評估[潛在偏見]\\n\\n如果在驗證中發現任何問題，請",
          "（順序編排）：\\n\\n```python\\nclass SequentialOrchestration:\\n    \\\"\\\"\\\"順序編排模式\\\"\\\"\\\"\\n    \\n    async def orchestrate_market_research(self, product: str) -> Dict:\\n        \\\"\\\"\\\"順序執行市場研究流程\\\"\\\"\\\"\\n        \\n        # 第一步：Deep Research 代理搜索信息\\n        research_results = await self.deep_research_agent.research(\\n            f\\\"市場趨勢和 {product} 的競爭格局\\\"\\n        )\\n        \\n        # 第二步：Browser Operator 代理收集補充數據\\n        market_data = await self.browser_operator_agent.collect_data(\\n            competitors=[\\\"GitHub Copilot\\\", \\\"Cursor\\\"],\\n            data_points=[\\\"pricing\\\", \\\"features\\\", \\\"reviews\\\"]\\n        )\\n        \\n        # 第三步：分析代理綜合數據\\n        analysis = await self.analysis_agent.analyze(\\n            research_results,\\n            market_data\\n        )\\n        \\n        # 第四步：Create Slides 代理生成輸出\\n        presentation = await self.slides_agent.generate(\\n            analysis,\\n            style=\\\"executive_brief\\\"\\n        )\\n        \\n        return {\\n            \\\"research\\\": research_results,\\n            \\\"market_data\\\": market_data,\\n            \\\"analysis\\\": analysis,\\n            \\\"presentation\\\": presentation\\n        }\\n\\n# 使用示例\\norchestrator = SequentialOrchestration(agents_dict)\\nresult = asyncio.run(orchestrator.orchestrate_market_research(\\\"AI Code Editor\\\"))\\n```\\n\\n#### 模式 2",
          "（輸出結構化）：\\n\\n```python\\nclass OutputStructuring:\\n    \\\"\\\"\\\"輸出結構化和格式化\\\"\\\"\\\"\\n    \\n    def create_executive_summary(self, research_data: Dict, analysis_data: Dict) -> Dict:\\n        \\\"\\\"\\\"創建執行摘要\\\"\\\"\\\"\\n        \\n        summary = {\\n            \\\"title\\\": \\\"AI Code Editors Market Analysis 2026\\\",\\n            \\\"date\\\": datetime.now().strftime(\\\"%Y-%m-%d\\\"),\\n            \\\"executive_overview\\\": self._generate_executive_overview(analysis_data),\\n            \\\"key_findings\\\": self._extract_key_findings(analysis_data),\\n            \\\"recommendations\\\": self._generate_recommendations(analysis_data),\\n            \\\"risks_and_mitigation\\\": self._assess_risks(analysis_data),\\n            \\\"next_steps\\\": self._define_next_steps()\\n        }\\n        \\n        return summary\\n    \\n    def generate_presentation(self, summary: Dict) -> str:\\n        \\\"\\\"\\\"生成演示文稿\\\"\\\"\\\"\\n        \\n        presentation_content = f\\\"\\\"\\\"\\n        # {summary['title']}\\n        \\n        ## Executive Summary\\n        {summary['executive_overview']}\\n        \\n        ## Key Findings\\n        {self._format_findings(summary['key_findings'])}\\n        \\n        ## Recommendations\\n        {self._format_recommendations(summary['recommendations'])}\\n        \\n        ## Risks and Mitigation\\n        {self._format_risks(summary['risks_and_mitigation'])}\\n        \\n        ## Next Steps\\n        {self._format_next_steps(summary['next_steps'])}\\n        \\\"\\\"\\\"\\n        \\n        # 使用 Create Slides 模組生成幻燈片\\n        slides_path = self.slides_generator.generate_presentation(\\n            presentation_content,\\n            style=\\\"professional\\\"\\n        )\\n        \\n        return slides_path\\n    \\n    def _generate_executive_overview(self, data: Dict) -> str:\\n        \\\"\\\"\\\"生成執行概覽\\\"\\\"\\\"\\n        # 使用 LLM 生成綜合總結\\n        prompt = f\\\"根據以下數據生成 2-3 句的執行摘要：{json.dumps(data)}\\\"\\n        return self.llm_client.generate(prompt)\\n    \\n    def _extract_key_findings(self, data: Dict) -> List[str]:\\n        \\\"\\\"\\\"提取關鍵發現\\\"\\\"\\\"\\n        findings = []\\n        \\n        # 提取影響最大的發現\\n        for key, value in data.items():\\n            if self._is_significant(value):\\n                findings.append(f\\\"{key}: {value}\\\")\\n        \\n        return findings[:5]  # 前 5 個最重要的發現\\n    \\n    def _generate_recommendations(self, data: Dict) -> List[str]:\\n        \\\"\\\"\\\"生成建議\\\"\\\"\\\"\\n        # 基於分析生成可操作建議\\n        recommendations = []\\n        \\n        if data.get(\\\"cost_benefit_ratio\\\", 0) > 1.5:\\n            recommendations.append(\\\"建議採用：成本效益比顯著\\\")\\n        \\n        if data.get(\\\"adoption_risk\\\", \\\"high\\\") == \\\"low\\\":\\n            recommendations.append(\\\"建議快速部署：集成風險低\\\")\\n        \\n        if data.get(\\\"market_trend\\\", \\\"\\\") == \\\"growing\\\":\\n            recommendations.append(\\\"建議優先評估：市場增長迅速\\\")\\n        \\n        return recommendations\\n    \\n    # 其他輔助方法\\n    def _is_significant(self, value) -> bool:\\n        \\\"\\\"\\\"判斷值是否顯著\\\"\\\"\\\"\\n        # 簡化邏輯\\n        return True\\n    \\n    def _format_findings(self, findings: List[str]) -> str:\\n        \\\"\\\"\\\"格式化發現\\\"\\\"\\\"\\n        return \\\"\\\\n\\\".join([f\\\"- {f}\\\" for f in findings])\\n    \\n    def _format_recommendations(self, recs: List[str]) -> str:\\n        \\\"\\\"\\\"格式化建議\\\"\\\"\\\"\\n        return \\\"\\\\n\\\".join([f\\\"- {r}\\\" for r in recs])\\n    \\n    def _format_risks(self, risks: Dict) -> str:\\n        \\\"\\\"\\\"格式化風險\\\"\\\"\\\"\\n        return json.dumps(risks, indent=2)\\n    \\n    def _format_next_steps(self, steps: List[str]) -> str:\\n        \\\"\\\"\\\"格式化下一步\\\"\\\"\\\"\\n        return \\\"\\\\n\\\".join([f\\\"{i+1}. {step}\\\" for i, step in enumerate(steps)])\\n    \\n    def _assess_risks(self, data: Dict) -> Dict:\\n        \\\"\\\"\\\"評估風險\\\"\\\"\\\"\\n        return {\\\"identified_risks\\\": [], \\\"mitigation_strategies\\\": []}\\n    \\n    def _define_next_steps(self) -> List[str]:\\n        \\\"\\\"\\\"定義後續步驟\\\"\\\"\\\"\\n        return [\\n            \\\"進行詳細的供應商演示\\\",\\n            \\\"與現有系統進行兼容性測試\\\",\\n            \\\"準備概念驗證（PoC）方案\\\"\\n        ]\\n\\n# 使用示例\\nstructuring = OutputStructuring(llm_client, slides_generator)\\nsummary = structuring.create_executive_summary(research_data, analysis_data)\\npresentation_path = structuring.generate_presentation(summary)\\n```\\n\\n### 2.2 多代理編排的四種模式\\n\\nMicrosoft Azure 定義了四種主要的多代理編排模式，每種適合不同的場景。[2] Monica AI Agent 可以組合這些模式實現複雜任務。\\n\\n#### 模式 1",
          "：\\n\\n```\\n\\\"在提供最終推薦之前：\\n1. 驗證所有成本數字與官方定價頁面的一致性\\n2. 檢查統計數據是否來自 2025 年或更新版本\\n3. 交叉引用採用率統計與多個行業報告\\n4. 評估您的分析中是否存在對特定工具的偏好\\n\\n如果在驗證中發現任何不一致之處，請",
          "：\\n\\n```\\n\\\"請執行此任務，但遵守這些約束：\\n- 資源限制：[時間、API 調用等]\\n- 數據限制：[不使用的信息類型]\\n- 功能限制：[不執行的操作]\\n- 輸出限制",
          "（並行搜索）：\\n\\n```python\\nimport asyncio\\nfrom typing import List, Dict\\nimport aiohttp\\n\\nclass ParallelSearchEngine:\\n    \\\"\\\"\\\"多源並行搜索引擎\\\"\\\"\\\"\\n    \\n    # 數據源配置\\n    DATA_SOURCES = {\\n        \\\"google_scholar\\\": {\\n            \\\"url\\\": \\\"https://scholar.google.com/scholar\\\",\\n            \\\"priority\\\": 0.4,\\n            \\\"timeout\\\": 15\\n        },\\n        \\\"hacker_news\\\": {\\n            \\\"url\\\": \\\"https://hn.algolia.com/api/v1/search\\\",\\n            \\\"priority\\\": 0.3,\\n            \\\"timeout\\\": 10\\n        },\\n        \\\"stack_overflow\\\": {\\n            \\\"url\\\": \\\"https://api.stackexchange.com/2.3/search/advanced\\\",\\n            \\\"priority\\\": 0.3,\\n            \\\"timeout\\\": 10\\n        },\\n        \\\"arxiv\\\": {\\n            \\\"url\\\": \\\"http://export.arxiv.org/api/query\\\",\\n            \\\"priority\\\": 0.4,\\n            \\\"timeout\\\": 12\\n        }\\n    }\\n    \\n    async def search_parallel(self, query: str, subquestions: List[Dict]) -> Dict:\\n        \\\"\\\"\\\"並行搜索多個數據源\\\"\\\"\\\"\\n        \\n        tasks = []\\n        results = {}\\n        \\n        async with aiohttp.ClientSession() as session:\\n            for source_name, source_config in self.DATA_SOURCES.items():\\n                # 為每個源創建搜索任務\\n                for subq in subquestions",
          "：\\n\\n```\\n\\\"請進行競爭對手分析，遵守這些約束",
          "\\\"))\\n        }\\n\\n# 使用示例\\ncontroller = NavigationController(driver, llm_client)\\nresult = controller.execute_command(\\n    \\\"點擊標題為 '搜索' 的按鈕，然後在搜索框中輸入 'AI code editor'\\\",\\n    {\\\"page_analysis\\\"",
          "：\\n```\\n\\\"為我們的 500 人軟件公司評估 GitHub Copilot Enterprise。\\n我們主要使用 Python、TypeScript 和 Go。\\n請提供",
          "（綜合分析）：\\n\\n```python\\nfrom collections import defaultdict\\nfrom sklearn.feature_extraction.text import TfidfVectorizer\\n\\nclass SynthesisAnalyzer:\\n    \\\"\\\"\\\"綜合分析引擎 - 將多源數據綜合為洞見\\\"\\\"\\\"\\n    \\n    def synthesize(self, search_results: Dict, llm_client) -> Dict:\\n        \\\"\\\"\\\"綜合分析搜索結果\\\"\\\"\\\"\\n        \\n        # 第一步：信息提取\\n        extracted_info = self._extract_facts(search_results)\\n        \\n        # 第二步：去重和去偏\\n        deduplicated = self._deduplicate_and_balance(extracted_info)\\n        \\n        # 第三步：跨源比較\\n        comparisons = self._cross_source_comparison(deduplicated)\\n        \\n        # 第四步：模式識別\\n        patterns = self._identify_patterns(deduplicated)\\n        \\n        # 第五步：結論生成\\n        conclusions = self._generate_conclusions(\\n            deduplicated, comparisons, patterns, llm_client\\n        )\\n        \\n        return {\\n            \\\"facts\\\": extracted_info,\\n            \\\"comparisons\\\": comparisons,\\n            \\\"patterns\\\": patterns,\\n            \\\"conclusions\\\": conclusions,\\n            \\\"confidence_scores\\\": self._calculate_confidence(search_results)\\n        }\\n    \\n    def _extract_facts(self, results: Dict) -> List[Dict]:\\n        \\\"\\\"\\\"從搜索結果中提取關鍵事實\\\"\\\"\\\"\\n        facts = []\\n        for subq_id, sources in results.items():\\n            for source in sources:\\n                # 使用 NLP 技術提取實體、數字、日期等\\n                extracted = self._nlp_extraction(source[\\\"data\\\"])\\n                facts.append({\\n                    \\\"subquestion_id\\\": subq_id,\\n                    \\\"source\\\": source[\\\"source\\\"],\\n                    \\\"extracted\\\": extracted\\n                })\\n        return facts\\n    \\n    def _deduplicate_and_balance(self, facts: List[Dict]) -> Dict:\\n        \\\"\\\"\\\"去重和去偏 - 識別和平衡相反觀點\\\"\\\"\\\"\\n        balanced = {}\\n        claims = defaultdict(list)\\n        \\n        for fact in facts:\\n            # 聚合相似聲明\\n            for item in fact[\\\"extracted\\\"]:\\n                key = self._normalize_claim(item)\\n                claims[key].append({\\n                    \\\"source\\\": fact[\\\"source\\\"],\\n                    \\\"content\\\": item\\n                })\\n        \\n        # 平衡相反觀點\\n        for claim, sources in claims.items():\\n            balanced[claim] = {\\n                \\\"frequency\\\": len(sources),\\n                \\\"sources\\\": [s[\\\"source\\\"] for s in sources],\\n                \\\"confidence\\\": len(sources) / len(facts)  # 簡化的信度計算\\n            }\\n        \\n        return balanced\\n    \\n    def _cross_source_comparison(self, balanced: Dict) -> Dict:\\n        \\\"\\\"\\\"跨源比較 - 識別一致性和差異\\\"\\\"\\\"\\n        comparison = {\\n            \\\"consensus\\\": {},  # 高度一致的觀點\\n            \\\"disputed\\\": {},   # 有爭議的觀點\\n            \\\"unique\\\": {}      # 只在某源出現的觀點\\n        }\\n        \\n        for claim, info in balanced.items():\\n            if info[\\\"confidence\\\"] > 0.7:\\n                comparison[\\\"consensus\\\"][claim] = info\\n            elif info[\\\"confidence\\\"] > 0.3:\\n                comparison[\\\"disputed\\\"][claim] = info\\n            else:\\n                comparison[\\\"unique\\\"][claim] = info\\n        \\n        return comparison\\n    \\n    def _identify_patterns(self, balanced: Dict) -> Dict:\\n        \\\"\\\"\\\"識別趨勢和模式\\\"\\\"\\\"\\n        patterns = {\\n            \\\"emerging_trends\\\": [],\\n            \\\"market_shifts\\\": [],\\n            \\\"technology_evolution\\\": []\\n        }\\n        \\n        # 簡化的模式識別\\n        for claim, info in balanced.items():\\n            if self._is_trend_keyword(claim):\\n                patterns[\\\"emerging_trends\\\"].append(claim)\\n            elif self._is_market_keyword(claim):\\n                patterns[\\\"market_shifts\\\"].append(claim)\\n            elif self._is_tech_keyword(claim):\\n                patterns[\\\"technology_evolution\\\"].append(claim)\\n        \\n        return patterns\\n    \\n    def _generate_conclusions(self, balanced, comparisons, patterns, llm_client) -> List[str]:\\n        \\\"\\\"\\\"使用 LLM 生成最終結論\\\"\\\"\\\"\\n        \\n        synthesis_prompt = f\\\"\\\"\\\"\\n        基於以下數據綜合分析：\\n        \\n        共識觀點：{len(comparisons['consensus'])} 項\\n        爭議觀點：{len(comparisons['disputed'])} 項\\n        新興趨勢：{len(patterns['emerging_trends'])} 項\\n        \\n        主要發現：\\n        {json.dumps(comparisons, indent=2)}\\n        \\n        請生成 3-5 個關鍵結論，每個結論應該：\\n        1. 基於數據證據\\n        2. 具有可操作性\\n        3. 包含置信度評估\\n        \\\"\\\"\\\"\\n        \\n        response = llm_client.create(\\n            model=\\\"gpt-4o\\\",\\n            messages=[{\\\"role\\\": \\\"user\\\", \\\"content\\\": synthesis_prompt}]\\n        )\\n        \\n        return response.content.split(\\\"\\\\n\\\")\\n    \\n    def _calculate_confidence(self, results: Dict) -> Dict:\\n        \\\"\\\"\\\"計算結論的置信度\\\"\\\"\\\"\\n        return {\\n            \\\"sources_count\\\": len(results),\\n            \\\"total_items\\\": sum(len(v) for v in results.values()),\\n            \\\"freshness_score\\\": self._calculate_freshness(),\\n            \\\"diversity_score\\\": self._calculate_source_diversity(results)\\n        }\\n    \\n    # 輔助方法\\n    def _normalize_claim(self, claim: str) -> str:\\n        \\\"\\\"\\\"標準化聲明便於比較\\\"\\\"\\\"\\n        return claim.lower().strip()\\n    \\n    def _nlp_extraction(self, data) -> List[str]:\\n        \\\"\\\"\\\"使用 NLP 提取信息\\\"\\\"\\\"\\n        return []  # 實現 NLP 提取邏輯\\n    \\n    def _is_trend_keyword(self, text: str) -> bool:\\n        \\\"\\\"\\\"檢測趨勢關鍵字\\\"\\\"\\\"\\n        trend_keywords = [\\\"trend\\\", \\\"emerging\\\", \\\"growth\\\", \\\"innovation\\\"]\\n        return any(kw in text.lower() for kw in trend_keywords)\\n    \\n    def _is_market_keyword(self, text: str) -> bool:\\n        \\\"\\\"\\\"檢測市場關鍵字\\\"\\\"\\\"\\n        market_keywords = [\\\"market\\\", \\\"adoption\\\", \\\"share\\\", \\\"revenue\\\"]\\n        return any(kw in text.lower() for kw in market_keywords)\\n    \\n    def _is_tech_keyword(self, text: str) -> bool:\\n        \\\"\\\"\\\"檢測技術關鍵字\\\"\\\"\\\"\\n        tech_keywords = [\\\"technology\\\", \\\"feature\\\", \\\"capability\\\", \\\"performance\\\"]\\n        return any(kw in text.lower() for kw in tech_keywords)\\n    \\n    def _calculate_freshness(self) -> float:\\n        \\\"\\\"\\\"計算數據新鮮度\\\"\\\"\\\"\\n        return 0.8  # 簡化實現\\n    \\n    def _calculate_source_diversity(self, results: Dict) -> float:\\n        \\\"\\\"\\\"計算源多樣性\\\"\\\"\\\"\\n        sources = set()\\n        for subq_result in results.values():\\n            for item in subq_result:\\n                sources.add(item[\\\"source\\\"])\\n        return len(sources) / len(self.DATA_SOURCES) if self.DATA_SOURCES else 0\\n\\n# 使用示例\\nanalyzer = SynthesisAnalyzer()\\nsynthesis_result = analyzer.synthesize(search_results, llm_client)\\n```\\n\\n#### 應用案例 1",
          "：收集的原始數據必須經過分析和綜合。該引擎執行以下操作",
          "：\\n```json\\n{\\n  \\\"market_leaders\\\": [\\n    {\\\"name\\\": \\\"GitHub Copilot\\\", \\\"market_share\\\": \\\"45%\\\", \\\"confidence\\\": 0.85},\\n    {\\\"name\\\": \\\"Cursor\\\", \\\"market_share\\\": \\\"18%\\\", \\\"confidence\\\": 0.82},\\n    {\\\"name\\\": \\\"Monica Code\\\", \\\"market_share\\\": \\\"12%\\\", \\\"confidence\\\": 0.78}\\n  ],\\n  \\\"adoption_barriers\\\": [\\n    \\\"成本（企業許可證 $100-150/月）\\\",\\n    \\\"隱私考慮（代碼發送至雲端）\\\",\\n    \\\"現有工作流集成複雜性\\\"\\n  ],\\n  \\\"market_forecast_2026\\\": {\\n    \\\"expected_cagr\\\": \\\"32%\\\",\\n    \\\"primary_drivers\\\": [\\\"代碼質量改進\\\", \\\"開發速度加快\\\", \\\"成本節省\\\"]\\n  },\\n  \\\"key_insights\\\": [\\n    \\\"企業級功能（安全、合規）成為差異化因素\\\",\\n    \\\"多代理協作架構成為新的競爭優勢\\\",\\n    \\\"邊緣計算和本地模型需求上升\\\"\\n  ]\\n}\\n```\\n\\n#### 應用案例 2",
          ": 架構師、高級開發工程師、DevOps 工程師  \\n\\n---\\n\\n## 第一部分：Monica AI Agent 核心功能架構分析\\n\\n### 1.1 系統架構概覽\\n\\nMonICA AI Agent 由三個高度集成的模組組成，共同構成完整的智能工作流系統。[1] 架構設計採用微服務模式，允許各模組獨立部署和擴展，同時通過統一的編排層實現協調。\\n\\n```\\n┌────────────────────────────────────────────────────────────┐\\n│                  用戶輸入層                                 │\\n│        自然語言查詢 / 結構化指令 / 交互反饋                │\\n└────────────────────────────────────────────────────────────┘\\n                            ↓\\n┌────────────────────────────────────────────────────────────┐\\n│                    統一編排層                               │\\n│  任務理解 → 模組選擇 → 參數配置 → 執行控制 → 結果驗證    │\\n└────────────────────────────────────────────────────────────┘\\n        ↓                   ↓                   ↓\\n┌──────────────┐  ┌──────────────┐  ┌──────────────┐\\n│Deep Research │  │   Browser    │  │    Create    │\\n│  模組        │  │  Operator    │  │   Slides     │\\n│              │  │  模組        │  │   模組       │\\n└──────────────┘  └──────────────┘  └──────────────┘\\n        ↓                   ↓                   ↓\\n┌──────────────┐  ┌──────────────┐  ┌──────────────┐\\n│問題分解引擎  │  │視覺識別引擎  │  │結構化引擎    │\\n│多源搜索引擎  │  │導航控制引擎  │  │設計應用引擎  │\\n│綜合分析引擎  │  │數據提取引擎  │  │渲染引擎      │\\n└──────────────┘  └──────────────┘  └──────────────┘\\n        ↓                   ↓                   ↓\\n  結構化報告        結構化數據集        演示文稿\\n```\\n\\n### 1.2 Deep Research 模組",
          "（權重 0.2）",
          ")', content)\\n        \\n        data_points.append({\\\"type\\\": \\\"percentages\\\", \\\"values\\\": percentages})\\n        data_points.append({\\\"type\\\": \\\"currency\\\", \\\"values\\\": numbers})\\n        \\n        return data_points\\n    \\n    def _load_style_config(self, style: str) -> Dict:\\n        \\\"\\\"\\\"載入樣式配置\\\"\\\"\\\"\\n        styles = {\\n            \\\"professional\\\": {\\\"colors\\\": [\\\"#1f77b4\\\", \\\"#ff7f0e\\\"], \\\"font\\\": \\\"Arial\\\"},\\n            \\\"creative\\\": {\\\"colors\\\": [\\\"#e74c3c\\\", \\\"#3498db\\\"], \\\"font\\\": \\\"Georgia\\\"},\\n            \\\"minimal\\\": {\\\"colors\\\": [\\\"#2c3e50\\\", \\\"#ecf0f1\\\"], \\\"font\\\": \\\"Helvetica\\\"}\\n        }\\n        return styles.get(style, styles[\\\"professional\\\"])\\n    \\n    def _select_transition(self, slide_index: int, total_slides: int) -> str:\\n        \\\"\\\"\\\"選擇幻燈片轉換效果\\\"\\\"\\\"\\n        if slide_index == 0:\\n            return \\\"dissolve\\\"\\n        elif slide_index == total_slides - 1:\\n            return \\\"fade\\\"\\n        else:\\n            return \\\"push\\\"\\n    \\n    def _get_layout_index(self, slide_type: str) -> int:\\n        \\\"\\\"\\\"根據幻燈片類型獲取佈局索引\\\"\\\"\\\"\\n        layouts = {\\\"title\\\": 0, \\\"toc\\\": 1, \\\"content\\\": 5, \\\"conclusion\\\": 6}\\n        return layouts.get(slide_type, 5)\\n    \\n    def _fill_title_slide(self, slide, content: Dict):\\n        \\\"\\\"\\\"填充標題幻燈片\\\"\\\"\\\"\\n        title = slide.shapes.title\\n        subtitle = slide.placeholders[1]\\n        \\n        title.text = content[\\\"title\\\"]\\n        subtitle.text = content.get(\\\"subtitle\\\", \\\"\\\")\\n    \\n    def _fill_content_slide(self, slide, slide_data: Dict):\\n        \\\"\\\"\\\"填充內容幻燈片\\\"\\\"\\\"\\n        # 實現邏輯\\n        pass\\n    \\n    def _fill_generic_slide(self, slide, slide_data: Dict):\\n        \\\"\\\"\\\"填充通用幻燈片\\\"\\\"\\\"\\n        # 實現邏輯\\n        pass\\n\\n# 使用示例\\ngenerator = SlidesGenerator()\\npresentation_path = generator.generate_presentation(\\\"\\\"\\\"\\n# Market Analysis: AI Code Editors 2026\\n\\n## Key Findings\\n- 45% market share held by GitHub Copilot\\n- 32% year-over-year growth expected\\n- Enterprise adoption increasing\\n\\n## Market Size\\n- Current: $2.5B\\n- 2026 Forecast",
          "：\\n\\n```\\n\\\"請按照這些步驟進行市場分析",
          "（切換編排）：\\n\\n```python\\nclass HandoffOrchestration:\\n    \\\"\\\"\\\"切換/移交編排模式\\\"\\\"\\\"\\n    \\n    async def orchestrate_adaptive_workflow(self, task: str) -> Dict:\\n        \\\"\\\"\\\"自適應工作流 - 根據需要在代理之間切換\\\"\\\"\\\"\\n        \\n        current_agent = \\\"router\\\"  # 開始於路由代理\\n        context = {\\\"initial_task\\\": task, \\\"history\\\": []}\\n        max_handoffs = 5\\n        handoff_count = 0\\n        \\n        while current_agent and handoff_count < max_handoffs:\\n            # 獲取當前代理的決策\\n            decision = await self._get_agent_decision(current_agent, context, task)\\n            \\n            # 記錄決策\\n            context[\\\"history\\\"].append({\\n                \\\"agent\\\": current_agent,\\n                \\\"action\\\": decision[\\\"action\\\"],\\n                \\\"result\\\": decision.get(\\\"result\\\"),\\n                \\\"timestamp\\\": datetime.now()\\n            })\\n            \\n            # 確定是否需要切換\\n            if decision[\\\"action\\\"] == \\\"complete\\\":\\n                return {\\n                    \\\"status\\\": \\\"completed\\\",\\n                    \\\"result\\\": decision[\\\"result\\\"],\\n                    \\\"history\\\": context[\\\"history\\\"],\\n                    \\\"handoffs\\\": handoff_count\\n                }\\n            elif decision[\\\"action\\\"] == \\\"handoff\\\":\\n                # 切換到下一個代理\\n                next_agent = decision[\\\"next_agent\\\"]\\n                print(f\\\"\\\\n切換: {current_agent} → {next_agent}\\\")\\n                current_agent = next_agent\\n                handoff_count += 1\\n                # 使用新代理的輸出更新上下文\\n                context[\\\"current_result\\\"] = decision.get(\\\"result\\\")\\n            else:\\n                current_agent = None  # 結束循環\\n        \\n        return {\\n            \\\"status\\\": \\\"max_handoffs_exceeded\\\",\\n            \\\"history\\\": context[\\\"history\\\"]\\n        }\\n    \\n    async def _get_agent_decision(self, agent_name: str, context: Dict, task: str) -> Dict:\\n        \\\"\\\"\\\"獲取代理的決策\\\"\\\"\\\"\\n        \\n        if agent_name == \\\"router\\\":\\n            # 路由代理決定初始方向\\n            complexity = self._assess_complexity(task)\\n            if complexity == \\\"simple\\\":\\n                return {\\n                    \\\"action\\\": \\\"handoff\\\",\\n                    \\\"next_agent\\\": \\\"simple_agent\\\"\\n                }\\n            else:\\n                return {\\n                    \\\"action\\\": \\\"handoff\\\",\\n                    \\\"next_agent\\\": \\\"deep_research_agent\\\"\\n                }\\n        \\n        elif agent_name == \\\"deep_research_agent\\\":\\n            # Deep Research 代理進行研究\\n            research_result = await self.deep_research_agent.research(task)\\n            \\n            # 決定是否需要額外數據\\n            if research_result[\\\"completeness_score\\\"] < 0.7:\\n                return {\\n                    \\\"action\\\": \\\"handoff\\\",\\n                    \\\"next_agent\\\": \\\"browser_operator_agent\\\",\\n                    \\\"result\\\": research_result\\n                }\\n            else:\\n                return {\\n                    \\\"action\\\": \\\"handoff\\\",\\n                    \\\"next_agent\\\": \\\"analysis_agent\\\",\\n                    \\\"result\\\": research_result\\n                }\\n        \\n        elif agent_name == \\\"browser_operator_agent\\\":\\n            # Browser Operator 收集補充數據\\n            supplementary_data = await self.browser_operator_agent.collect_data(\\n                task=task,\\n                previous_context=context\\n            )\\n            \\n            return {\\n                \\\"action\\\": \\\"handoff\\\",\\n                \\\"next_agent\\\": \\\"analysis_agent\\\",\\n                \\\"result\\\": supplementary_data\\n            }\\n        \\n        elif agent_name == \\\"analysis_agent\\\":\\n            # 分析代理綜合數據\\n            analysis = await self.analysis_agent.analyze(\\n                data=context.get(\\\"current_result\\\"),\\n                task=task\\n            )\\n            \\n            # 決定是否需要生成輸出\\n            if analysis[\\\"requires_visualization\\\"]:\\n                return {\\n                    \\\"action\\\": \\\"handoff\\\",\\n                    \\\"next_agent\\\": \\\"slides_agent\\\",\\n                    \\\"result\\\": analysis\\n                }\\n            else:\\n                return {\\n                    \\\"action\\\": \\\"complete\\\",\\n                    \\\"result\\\": analysis\\n                }\\n        \\n        elif agent_name == \\\"slides_agent\\\":\\n            # 創建幻燈片\\n            presentation = await self.slides_agent.generate(\\n                data=context.get(\\\"current_result\\\")\\n            )\\n            \\n            return {\\n                \\\"action\\\": \\\"complete\\\",\\n                \\\"result\\\": presentation\\n            }\\n        \\n        return {\\\"action\\\": \\\"complete\\\"}\\n    \\n    def _assess_complexity(self, task: str) -> str:\\n        \\\"\\\"\\\"評估任務複雜性\\\"\\\"\\\"\\n        if len(task) < 50:\\n            return \\\"simple\\\"\\n        elif len(task) < 200:\\n            return \\\"medium\\\"\\n        else:\\n            return \\\"complex\\\"\\n\\n# 使用示例\\norchestrator = HandoffOrchestration(agents_dict)\\nresult = asyncio.run(orchestrator.orchestrate_adaptive_workflow(\\n    \\\"比較 GitHub Copilot 和 Cursor 的定價、功能和企業支持\\\"\\n))\\n```\\n\\n### 2.3 提示工程的 5 個核心原則\\n\\nBased on latest research from OpenAI, UiPath, and industry practitioners (2025-2026), [3] [4] effective prompts follow these 5 core principles",
          "（簡化）：\\n\\n```python\\nclass ReviewScraper:\\n    def scrape_reviews(self, product_name: str, num_pages: int = 10) -> pd.DataFrame:\\n        reviews_data = []\\n        \\n        for page in range(1, num_pages + 1):\\n            # 導航到評論頁面\\n            url = f\\\"https://reviews.example.com?product={product_name}&page={page}\\\"\\n            self.driver.get(url)\\n            \\n            # 提取該頁面的所有評論\\n            extraction_schema = {\\n                \\\"type\\\": \\\"custom\\\",\\n                \\\"template\\\": {\\n                    \\\"rating\\\": \\\"span.star-rating\\\",\\n                    \\\"review_text\\\": \\\"div.review-content\\\",\\n                    \\\"reviewer_name\\\": \\\"span.reviewer-name\\\",\\n                    \\\"review_date\\\": \\\"span.review-date\\\"\\n                }\\n            }\\n            \\n            page_data = self.extractor.extract_structured_data(extraction_schema)\\n            reviews_data.extend(page_data[\\\"data\\\"])\\n        \\n        return pd.DataFrame(reviews_data)\\n\\n# 執行\\nscraper = ReviewScraper(driver, llm_client, extractor)\\nreviews_df = scraper.scrape_reviews(\\\"AI Code Editor\\\", num_pages=5)\\nreviews_df.to_csv(\\\"reviews.csv\\\", index=False)\\n```\\n\\n### 1.4 Create Slides 模組",
          "（並發編排）：\\n\\n```python\\nclass ConcurrentOrchestration:\\n    \\\"\\\"\\\"並發編排模式\\\"\\\"\\\"\\n    \\n    async def orchestrate_multi_competitor_analysis(self, competitors: List[str]) -> Dict:\\n        \\\"\\\"\\\"並行分析多個競爭對手\\\"\\\"\\\"\\n        \\n        tasks = []\\n        \\n        # 為每個競爭對手創建並發任務\\n        for competitor in competitors",
          "（確保每項都包含）：\\n\\n| 項目 | 較弱 | 優化 |\\n|-----|------|------|\\n| 目標受眾 | 未指定 | \\\"為 C-suite 高管決策\\\" |\\n| 時間框架 | 模糊 | \\\"2025-2026 年數據\\\" |\\n| 地理範圍 | 全球 | \\\"主要關注亞太地區企業\\\" |\\n| 深度水平 | 通用 | \\\"技術細節和成本分析的平衡\\\" |\\n| 應用背景 | 未指定 | \\\"我們計劃在 Q2 2026 評估工具\\\" |\\n| 排除項 | 未指定 | \\\"排除免費工具，專注企業解決方案\\\" |\\n| 輸出格式 | 默認 | \\\"提供表格、成本模型和風險評估\\\" |\\n\\n#### 第二階段",
          "：對於每個子問題，該引擎並行發起搜索請求到多個信息源。數據源按優先級分類",
          "（視覺感知）：\\n\\n```python\\nfrom selenium import webdriver\\nfrom selenium.webdriver.common.by import By\\nfrom pytesseract import pytesseract\\nfrom PIL import Image\\nimport cv2\\nimport numpy as np\\n\\nclass VisualPerceptionEngine:\\n    \\\"\\\"\\\"網頁視覺感知引擎\\\"\\\"\\\"\\n    \\n    def __init__(self):\\n        self.driver = None\\n        self.ocr_enabled = True\\n    \\n    def analyze_page(self, driver) -> Dict:\\n        \\\"\\\"\\\"分析頁面視覺結構\\\"\\\"\\\"\\n        \\n        # 第一步：DOM 解析\\n        dom_structure = self._parse_dom(driver)\\n        \\n        # 第二步：視覺元素檢測\\n        interactive_elements = self._detect_interactive_elements(driver)\\n        \\n        # 第三步：OCR 文本識別（如需要）\\n        page_text = self._perform_ocr(driver) if self.ocr_enabled else {}\\n        \\n        # 第四步：佈局理解\\n        layout = self._understand_layout(driver, interactive_elements)\\n        \\n        return {\\n            \\\"dom_structure\\\": dom_structure,\\n            \\\"interactive_elements\\\": interactive_elements,\\n            \\\"text_content\\\": page_text,\\n            \\\"layout\\\": layout,\\n            \\\"timestamp\\\": datetime.now()\\n        }\\n    \\n    def _parse_dom(self, driver) -> Dict:\\n        \\\"\\\"\\\"解析 DOM 結構\\\"\\\"\\\"\\n        dom_tree = {\\n            \\\"title\\\": driver.title,\\n            \\\"url\\\": driver.current_url,\\n            \\\"elements\\\": []\\n        }\\n        \\n        # 查找所有交互元素\\n        interactive_selectors = [\\n            (By.TAG_NAME, \\\"button\\\"),\\n            (By.TAG_NAME, \\\"a\\\"),\\n            (By.TAG_NAME, \\\"input\\\"),\\n            (By.TAG_NAME, \\\"select\\\"),\\n            (By.TAG_NAME, \\\"form\\\")\\n        ]\\n        \\n        for by_type, selector in interactive_selectors:\\n            try:\\n                elements = driver.find_elements(by_type, selector)\\n                for elem in elements:\\n                    # 計算元素的特徵向量便於識別\\n                    dom_tree[\\\"elements\\\"].append({\\n                        \\\"tag\\\": elem.tag_name,\\n                        \\\"text\\\": elem.text[:50],  # 前 50 字符\\n                        \\\"type\\\": elem.get_attribute(\\\"type\\\"),\\n                        \\\"id\\\": elem.get_attribute(\\\"id\\\"),\\n                        \\\"class\\\": elem.get_attribute(\\\"class\\\"),\\n                        \\\"location\\\": elem.location,\\n                        \\\"size\\\": elem.size,\\n                        \\\"is_displayed\\\": elem.is_displayed(),\\n                        \\\"is_enabled\\\": elem.is_enabled()\\n                    })\\n            except Exception as e:\\n                pass  # 某些元素可能無法查詢\\n        \\n        return dom_tree\\n    \\n    def _detect_interactive_elements(self, driver) -> List[Dict]:\\n        \\\"\\\"\\\"檢測交互元素\\\"\\\"\\\"\\n        elements = []\\n        \\n        # 獲取頁面截圖進行視覺檢測\\n        screenshot = driver.get_screenshot_as_png()\\n        image = Image.open(BytesIO(screenshot))\\n        image_array = np.array(image)\\n        \\n        # 使用 OpenCV 檢測邊界框（簡化版）\\n        gray = cv2.cvtColor(image_array, cv2.COLOR_BGR2GRAY)\\n        edges = cv2.Canny(gray, 100, 200)\\n        \\n        # 檢測矩形（按鈕、文本框等）\\n        contours, _ = cv2.findContours(edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\\n        \\n        for contour in contours[:20]:  # 限制檢測數量\\n            x, y, w, h = cv2.boundingRect(contour)\\n            if w > 20 and h > 20:  # 過濾掉過小的元素\\n                elements.append({\\n                    \\\"type\\\": \\\"button\\\" if h < w else \\\"input\\\",  # 簡化分類\\n                    \\\"bounding_box\\\": {\\\"x\\\": x, \\\"y\\\": y, \\\"width\\\": w, \\\"height\\\": h},\\n                    \\\"confidence\\\": 0.8\\n                })\\n        \\n        return elements\\n    \\n    def _perform_ocr(self, driver) -> Dict:\\n        \\\"\\\"\\\"使用 OCR 提取文本\\\"\\\"\\\"\\n        screenshot = driver.get_screenshot_as_png()\\n        image = Image.open(BytesIO(screenshot))\\n        \\n        # 使用 Tesseract 進行 OCR\\n        extracted_text = pytesseract.image_to_string(image)\\n        \\n        # 結構化文本提取\\n        text_blocks = pytesseract.image_to_data(image)\\n        \\n        return {\\n            \\\"full_text\\\": extracted_text,\\n            \\\"structured_blocks\\\": text_blocks,\\n            \\\"confidence\\\": 0.85\\n        }\\n    \\n    def _understand_layout(self, driver, elements: List[Dict]) -> Dict:\\n        \\\"\\\"\\\"理解頁面佈局\\\"\\\"\\\"\\n        layout = {\\n            \\\"width\\\": driver.execute_script(\\\"return window.innerWidth\\\"),\\n            \\\"height\\\": driver.execute_script(\\\"return window.innerHeight\\\"),\\n            \\\"viewport_boxes\\\": [],\\n            \\\"reading_order\\\": []\\n        }\\n        \\n        # 根據元素位置確定視口\\n        sorted_elements = sorted(\\n            elements,\\n            key=lambda x: (x[\\\"location\\\"][\\\"y\\\"], x[\\\"location\\\"][\\\"x\\\"])\\n        )\\n        \\n        layout[\\\"reading_order\\\"] = [\\n            elem for elem in sorted_elements \\n            if elem[\\\"is_displayed\\\"]\\n        ][:10]  # 前 10 個可見元素\\n        \\n        return layout\\n\\n# 使用示例\\nperception_engine = VisualPerceptionEngine()\\ndriver = webdriver.Chrome()\\ndriver.get(\\\"https",
          "（權重 0.4）",
          "：從網頁中結構化地提取數據。該子系統支持",
          "（自動化執行）：\\n\\n```python\\nclass AutomationOrchestrator:\\n    \\\"\\\"\\\"統一的自動化編排器\\\"\\\"\\\"\\n    \\n    def automate_competitor_monitoring(self, competitors: List[str]) -> pd.DataFrame:\\n        \\\"\\\"\\\"自動監控競爭對手\\\"\\\"\\\"\\n        \\n        all_data = []\\n        \\n        for competitor in competitors:\\n            # 第一步：導航到競爭對手網站\\n            self.navigation_controller.execute_command(\\n                f\\\"導航到 {competitor} 的定價頁面\\\",\\n                context=self.current_state\\n            )\\n            \\n            # 第二步：定義提取模式\\n            extraction_schema = {\\n                \\\"type\\\": \\\"custom\\\",\\n                \\\"template\\\": {\\n                    \\\"product_name\\\": \\\"h1.product-title\\\",\\n                    \\\"pricing_tier\\\": \\\"div.pricing-tier\\\",\\n                    \\\"price\\\": \\\"span.price\\\",\\n                    \\\"features\\\": \\\"ul.features li\\\",\\n                    \\\"support_level\\\": \\\"span.support-type\\\",\\n                    \\\"last_updated\\\": \\\"span.update-date\\\"\\n                }\\n            }\\n            \\n            # 第三步：提取數據\\n            extracted = self.data_extractor.extract_structured_data(extraction_schema)\\n            \\n            # 第四步：驗證提取質量\\n            if extracted[\\\"quality_score\\\"] > 0.8:\\n                all_data.append(extracted[\\\"data\\\"])\\n            else:\\n                # 重試或記錄失敗\\n                self.logger.warning(f\\\"低質量提取: {competitor}, 分數: {extracted['quality_score']}\\\")\\n        \\n        return pd.DataFrame(all_data)\\n\\n# 使用示例\\norchestrator = AutomationOrchestrator(driver, llm_client)\\ncompetitors_data = orchest rator.automate_competitor_monitoring([\\n    \\\"GitHub Copilot\\\",\\n    \\\"Cursor\\\",\\n    \\\"JetBrains AI\\\",\\n    \\\"Amazon CodeWhisperer\\\"\\n])\\n```\\n\\n#### 第三階段",
          "\\\").strip())\\n        \\n        return key_points[:5]\\n    \\n    def _identify_data_points(self, content: str) -> List[Dict]:\\n        \\\"\\\"\\\"識別數據點\\\"\\\"\\\"\\n        data_points = []\\n        \\n        import re\\n        # 尋找百分比、數字等\\n        percentages = re.findall(r'(\\\\d+)%', content)\\n        numbers = re.findall(r'\\\\$(\\\\d+(?",
          "：根據自然語言指令自動化網站導航。該子系統能夠",
          "（權重 0.3）",
          "：繪製現在手動執行的步驟。示例",
          "：\\n\\n```\\n\\\"你是一位[具體職位/角色]，具有[特定領域]的[年數]年經驗。\\n你的任務是[明確的目標]。\\n你的主要受眾是[受眾描述]。\\n重要限制",
          "，每個階段有明確的目標和驗證標準。\\n\\n#### 第一階段",
          "：輸入一個複雜查詢（例如「分析 2026 年 AI 代碼編輯市場」），該引擎使用結構化提示和 LLM 自動生成 5-8 個互相補充的子問題。分解遵循以下原則",
          "：\\n\\n```\\n\\\"你是一位資深軟件架構師，擁有 15 年的企業系統設計經驗。\\n你的任務是評估 AI 代碼編輯工具對我們組織的適用性。\\n你的主要受眾是 C-suite 高管，他們需要業務影響分析而不是技術細節。\\n重要限制",
          "（問題分解）：\\n\\n```python\\nclass QuestionDecomposer:\\n    \\\"\\\"\\\"將複雜問題分解為結構化子問題\\\"\\\"\\\"\\n    \\n    def __init__(self, llm_client, model=\\\"gpt-4o\\\"):\\n        self.llm = llm_client\\n        self.model = model\\n    \\n    def decompose(self, main_question: str, num_subquestions: int = 7) -> List[Dict]:\\n        \\\"\\\"\\\"分解查詢為子問題\\\"\\\"\\\"\\n        \\n        decomposition_prompt = f\\\"\\\"\\\"\\n        請將以下複雜問題分解為 {num_subquestions} 個相互補充的子問題。\\n        每個子問題應該：\\n        1. 涵蓋不同的維度或視角\\n        2. 具有明確的搜索焦點\\n        3. 可獨立回答但對整體問題有貢獻\\n        \\n        主問題：{main_question}\\n        \\n        返回 JSON 格式：\\n        {{\\n            \\\"subquestions\\\": [\\n                {{\\n                    \\\"id\\\": 1,\\n                    \\\"question\\\": \\\"具體問題\\\",\\n                    \\\"search_focus\\\": \\\"搜索重點\\\",\\n                    \\\"dimension\\\": \\\"問題維度\\\",\\n                    \\\"priority\\\": \\\"high/medium/low\\\"\\n                }}\\n            ],\\n            \\\"strategy\\\": \\\"分解策略說明\\\"\\n        }}\\n        \\\"\\\"\\\"\\n        \\n        response = self.llm.create(\\n            model=self.model,\\n            messages=[\\n                {\\\"role\\\": \\\"system\\\", \\\"content\\\": \\\"你是一位資深研究分析師。\\\"},\\n                {\\\"role\\\": \\\"user\\\", \\\"content\\\"",
          "原則 3",
          "原則 1",
          "：\\n\\n```\\n\\\"我會認為這是成功的，如果輸出",
          "原則 2",
          "（上下文、步驟、約束、成功標準、驗證）確保 Agent 理解您的意圖並提供高質量的結果。遵循這些原則會顯著改善 Agent 的性能。\\n\\n---\\n\\n## 參考資源\\n\\n[2]: https://learn.microsoft.com/en-us/azure/architecture/ai-ml/guide/ai-agent-design-patterns \\\"AI Agent Orchestration Patterns - Microsoft Azure\\\"\\n[3]: https://www.uipath.com/blog/ai/agent-builder-best-practices \\\"10 Best Practices for Building Reliable AI Agents - UiPath\\\"\\n[4]: https",
          "tasks, return_exceptions=True)\\n        \\n        # 聚合結果\\n        aggregated = self._aggregate_results(results)\\n        \\n        return aggregated\\n    \\n    async def _analyze_single_competitor(self, competitor: str) -> Dict:\\n        \\\"\\\"\\\"分析單個競爭對手\\\"\\\"\\\"\\n        \\n        # 三個代理並行工作\\n        research_task = self.deep_research_agent.research(\\n            f\\\"{competitor} 功能和定位\\\"\\n        )\\n        data_task = self.browser_operator_agent.collect_data(\\n            competitor=competitor,\\n            data_points=[\\\"pricing\\\", \\\"features\\\", \\\"support\\\"]\\n        )\\n        sentiment_task = self.sentiment_agent.analyze(\\n            competitor=competitor\\n        )\\n        \\n        research, data, sentiment = await asyncio.gather(\\n            research_task, data_task, sentiment_task\\n        )\\n        \\n        return {\\n            \\\"competitor\\\": competitor,\\n            \\\"research\\\": research,\\n            \\\"market_data\\\": data,\\n            \\\"sentiment\\\": sentiment\\n        }\\n    \\n    def _aggregate_results(self, results: List[Dict]) -> Dict:\\n        \\\"\\\"\\\"聚合並發結果\\\"\\\"\\\"\\n        \\n        comparison_matrix = pd.DataFrame([\\n            {\\n                \\\"competitor\\\": r[\\\"competitor\\\"],\\n                \\\"features_score\\\": self._score_features(r[\\\"market_data\\\"]),\\n                \\\"pricing_competitiveness\\\": self._score_pricing(r[\\\"market_data\\\"]),\\n                \\\"market_sentiment\\\": r[\\\"sentiment\\\"][\\\"overall_score\\\"]\\n            }\\n            for r in results if not isinstance(r, Exception)\\n        ])\\n        \\n        return {\\n            \\\"comparison_matrix\\\": comparison_matrix,\\n            \\\"winner\\\": comparison_matrix.loc[comparison_matrix[\\\"features_score\\\"].idxmax()],\\n            \\\"recommendations\\\": self._generate_recommendations(comparison_matrix)\\n        }\\n    \\n    def _score_features(self, data: Dict) -> float:\\n        \\\"\\\"\\\"評分功能\\\"\\\"\\\"\\n        # 簡化實現\\n        return len(data.get(\\\"features\\\", [])) / 10\\n    \\n    def _score_pricing(self, data: Dict) -> float:\\n        \\\"\\\"\\\"評分定價競爭力\\\"\\\"\\\"\\n        # 簡化實現\\n        return 0.8\\n    \\n    def _generate_recommendations(self, matrix: pd.DataFrame) -> List[str]:\\n        \\\"\\\"\\\"生成建議\\\"\\\"\\\"\\n        return [\\\"基於功能：選擇 X\\\", \\\"基於定價：選擇 Y\\\"]\\n\\n# 使用示例\\norchestrator = ConcurrentOrchestration(agents_dict)\\nresult = asyncio.run(orchestrator.orchestrate_multi_competitor_analysis([\\n    \\\"GitHub Copilot\\\",\\n    \\\"Cursor\\\",\\n    \\\"JetBrains AI\\\",\\n    \\\"Amazon CodeWhisperer\\\"\\n]))\\n```\\n\\n#### 模式 3",
          "[contains(text(), '{text}')]\\\") \\n        except:\\n            return None\\n    \\n    def _locate_by_attributes(self, description: str, page_analysis: Dict) -> Optional[WebElement]:\\n        \\\"\\\"\\\"根據屬性定位元素\\\"\\\"\\\"\\n        # 使用 id、class 等屬性\\n        try:\\n            return self.driver.find_element(By.ID, description)\\n        except:\\n            try:\\n                return self.driver.find_element(By.CLASS_NAME, description)\\n            except:\\n                return None\\n    \\n    def _locate_by_position(self, description: str, page_analysis: Dict) -> Optional[WebElement]:\\n        \\\"\\\"\\\"根據相對位置定位元素（例如「上面的按鈕\\\"）\\\"\\\"\\\"\\n        # 簡化實現\\n        elements = page_analysis[\\\"interactive_elements\\\"]\\n        if \\\"top\\\" in description.lower() and elements:\\n            return self.driver.find_element(By.XPATH, \\\"//button[1]\\\")\\n        return None\\n    \\n    def _locate_by_visual_similarity(self, description: str, page_analysis: Dict) -> Optional[WebElement]:\\n        \\\"\\\"\\\"根據視覺相似性定位元素\\\"\\\"\\\"\\n        # 使用視覺特徵匹配（高級功能）\\n        return None\\n    \\n    def _execute_interaction(self, element: WebElement, action: str, parameters: Dict) -> Dict:\\n        \\\"\\\"\\\"執行交互操作\\\"\\\"\\\"\\n        \\n        result = {\\\"success\\\": True, \\\"action\\\": action}\\n        \\n        try:\\n            if action == \\\"click\\\":\\n                element.click()\\n            elif action == \\\"fill\\\":\\n                element.clear()\\n                element.send_keys(parameters.get(\\\"text\\\", \\\"\\\"))\\n            elif action == \\\"select\\\":\\n                select = Select(element)\\n                select.select_by_value(parameters.get(\\\"option\\\", \\\"\\\"))\\n            elif action == \\\"scroll\\\":\\n                self.driver.execute_script(\\\"arguments[0].scrollIntoView();\\\", element)\\n            elif action == \\\"wait\\\":\\n                WebDriverWait(self.driver, 10).until(\\n                    EC.presence_of_element_located((By.XPATH, element))\\n                )\\n        except Exception as e:\\n            result[\\\"success\\\"] = False\\n            result[\\\"error\\\"] = str(e)\\n        \\n        return result\\n    \\n    def _verify_action_result(self, verification_criteria: str) -> Dict:\\n        \\\"\\\"\\\"驗證操作結果\\\"\\\"\\\"\\n        \\n        # 簡化的驗證邏輯\\n        verification = {\\n            \\\"success\\\": True,\\n            \\\"criteria\\\": verification_criteria,\\n            \\\"page_changed\\\": self._has_page_changed(),\\n            \\\"new_url\\\": self.driver.current_url,\\n            \\\"timestamp\\\": datetime.now()\\n        }\\n        \\n        return verification\\n    \\n    def _has_page_changed(self) -> bool:\\n        \\\"\\\"\\\"檢測頁面是否已改變\\\"\\\"\\\"\\n        # 比較當前頁面摘要與之前的\\n        current_hash = hash(self.driver.page_source)\\n        return True  # 簡化實現\\n    \\n    def _capture_current_state(self) -> Dict:\\n        \\\"\\\"\\\"捕獲當前頁面狀態\\\"\\\"\\\"\\n        return {\\n            \\\"url\\\": self.driver.current_url,\\n            \\\"title\\\": self.driver.title,\\n            \\\"elements_count\\\"",
          "（數據提取）：\\n\\n```python\\nimport pandas as pd\\nfrom bs4 import BeautifulSoup\\n\\nclass DataExtractionEngine:\\n    \\\"\\\"\\\"數據提取引擎 - 結構化提取網頁內容\\\"\\\"\\\"\\n    \\n    def __init__(self, driver, llm_client):\\n        self.driver = driver\\n        self.llm = llm_client\\n    \\n    def extract_structured_data(self, extraction_schema: Dict) -> Dict:\\n        \\\"\\\"\\\"根據模式提取結構化數據\\\"\\\"\\\"\\n        \\n        page_source = self.driver.page_source\\n        soup = BeautifulSoup(page_source, 'html.parser')\\n        \\n        extracted_data = {}\\n        \\n        # 根據提取類型選擇策略\\n        if extraction_schema[\\\"type\\\"] == \\\"table\\\":\\n            extracted_data = self._extract_tables(soup, extraction_schema)\\n        elif extraction_schema[\\\"type\\\"] == \\\"list\\\":\\n            extracted_data = self._extract_lists(soup, extraction_schema)\\n        elif extraction_schema[\\\"type\\\"] == \\\"product\\\":\\n            extracted_data = self._extract_products(soup, extraction_schema)\\n        elif extraction_schema[\\\"type\\\"] == \\\"custom\\\":\\n            extracted_data = self._extract_custom(soup, extraction_schema)\\n        \\n        return {\\n            \\\"data\\\": extracted_data,\\n            \\\"schema\\\": extraction_schema,\\n            \\\"timestamp\\\": datetime.now(),\\n            \\\"quality_score\\\": self._calculate_quality_score(extracted_data)\\n        }\\n    \\n    def _extract_tables(self, soup: BeautifulSoup, schema: Dict) -> List[Dict]:\\n        \\\"\\\"\\\"提取表格數據\\\"\\\"\\\"\\n        \\n        tables = soup.find_all('table')\\n        extracted_tables = []\\n        \\n        for table in tables:\\n            try:\\n                df = pd.read_html(str(table))[0]\\n                extracted_tables.append({\\n                    \\\"data\\\": df.to_dict('records'),\\n                    \\\"rows\\\": len(df),\\n                    \\\"columns\\\": list(df.columns)\\n                })\\n            except:\\n                continue\\n        \\n        return extracted_tables\\n    \\n    def _extract_lists(self, soup: BeautifulSoup, schema: Dict) -> List[Dict]:\\n        \\\"\\\"\\\"提取列表數據\\\"\\\"\\\"\\n        \\n        lists = soup.find_all(['ul', 'ol'])\\n        extracted_lists = []\\n        \\n        for list_elem in lists:\\n            items = list_elem.find_all('li')\\n            extracted_lists.append({\\n                \\\"items\\\": [item.get_text(strip=True) for item in items],\\n                \\\"count\\\": len(items),\\n                \\\"type\\\": list_elem.name\\n            })\\n        \\n        return extracted_lists\\n    \\n    def _extract_products(self, soup: BeautifulSoup, schema: Dict) -> List[Dict]:\\n        \\\"\\\"\\\"提取電商產品信息\\\"\\\"\\\"\\n        \\n        # 查找產品容器\\n        products = soup.find_all(class_=schema.get(\\\"product_class\\\", \\\"product\\\"))\\n        \\n        extracted_products = []\\n        for product in products:\\n            product_data = {\\n                \\\"name\\\": self._safe_extract(product, schema.get(\\\"name_selector\\\")),\\n                \\\"price\\\": self._safe_extract(product, schema.get(\\\"price_selector\\\")),\\n                \\\"description\\\": self._safe_extract(product, schema.get(\\\"desc_selector\\\")),\\n                \\\"url\\\": self._safe_extract(product, schema.get(\\\"url_selector\\\"), is_url=True),\\n                \\\"image\\\": self._safe_extract(product, schema.get(\\\"image_selector\\\"), is_image=True)\\n            }\\n            extracted_products.append(product_data)\\n        \\n        return extracted_products\\n    \\n    def _extract_custom(self, soup: BeautifulSoup, schema: Dict) -> Dict:\\n        \\\"\\\"\\\"基於自定義模板提取數據\\\"\\\"\\\"\\n        \\n        # 使用 LLM 理解複雜的提取邏輯\\n        extraction_prompt = f\\\"\\\"\\\"\\n        請根據以下模板從 HTML 中提取數據：\\n        \\n        模板: {json.dumps(schema['template'])}\\n        \\n        HTML 片段:\\n        {str(soup)[:2000]}...  # 限制 HTML 大小\\n        \\n        返回 JSON 格式的提取結果。\\n        \\\"\\\"\\\"\\n        \\n        response = self.llm.create(\\n            model=\\\"gpt-4o\\\",\\n            messages=[{\\\"role\\\": \\\"user\\\", \\\"content\\\": extraction_prompt}]\\n        )\\n        \\n        return json.loads(response.content)\\n    \\n    def _safe_extract(self, element, selector: str, is_url: bool = False, is_image: bool = False) -> str:\\n        \\\"\\\"\\\"安全地提取元素\\\"\\\"\\\"\\n        try:\\n            if not selector:\\n                return \\\"\\\"\\n            \\n            target = element.select_one(selector)\\n            if not target:\\n                return \\\"\\\"\\n            \\n            if is_url:\\n                return target.get('href', '')\\n            elif is_image:\\n                return target.get('src', '')\\n            else:\\n                return target.get_text(strip=True)\\n        except:\\n            return \\\"\\\"\\n    \\n    def _calculate_quality_score(self, data: Dict) -> float:\\n        \\\"\\\"\\\"計算提取質量評分\\\"\\\"\\\"\\n        # 簡化實現：檢查缺失值\\n        if not data:\\n            return 0.0\\n        \\n        total_items = len(data) if isinstance(data, list) else 1\\n        non_empty_items = sum(1 for item in (data if isinstance(data, list) else [data]) \\n                             if item)\\n        \\n        return non_empty_items / total_items if total_items > 0 else 0.0\\n\\n# 使用示例\\nextractor = DataExtractionEngine(driver, llm_client)\\n\\n# 表格提取\\ntable_result = extractor.extract_structured_data({\\n    \\\"type\\\": \\\"table\\\"\\n})\\n\\n# 自定義提取\\ncustom_result = extractor.extract_structured_data({\\n    \\\"type\\\": \\\"custom\\\",\\n    \\\"template\\\": {\\n        \\\"product_name\\\": \\\"h2.product-title\\\",\\n        \\\"price\\\": \\\"span.price\\\",\\n        \\\"rating\\\": \\\"div.rating\\\"\\n    }\\n})\\n```\\n\\n#### 應用案例 3",
          "\\\")",
          "（權重 0.1）",
          "tasks, return_exceptions=True)\\n            \\n            # 聚合結果\\n            for result in search_results:\\n                if isinstance(result, Exception):\\n                    continue\\n                source = result[\\\"source\\\"]\\n                subq_id = result[\\\"subquestion_id\\\"]\\n                if subq_id not in results:\\n                    results[subq_id] = []\\n                results[subq_id].append(result)\\n        \\n        return self._rank_and_filter(results)\\n    \\n    async def _search_source(self, session, source_name: str, \\n                            config: Dict, query: str, subq_id: int) -> Dict:\\n        \\\"\\\"\\\"搜索單個數據源\\\"\\\"\\\"\\n        try:\\n            async with session.get(\\n                config[\\\"url\\\"],\\n                params={\\\"q\\\": query},\\n                timeout=config[\\\"timeout\\\"]\\n            ) as response:\\n                data = await response.json()\\n                return {\\n                    \\\"source\\\": source_name,\\n                    \\\"subquestion_id\\\": subq_id,\\n                    \\\"data\\\": data,\\n                    \\\"priority\\\": config[\\\"priority\\\"],\\n                    \\\"timestamp\\\": datetime.now()\\n                }\\n        except asyncio.TimeoutError:\\n            return {\\\"source\\\": source_name, \\\"subquestion_id\\\": subq_id, \\\"error\\\": \\\"timeout\\\"}\\n    \\n    def _rank_and_filter(self, results: Dict) -> Dict:\\n        \\\"\\\"\\\"根據優先級排序和過濾結果\\\"\\\"\\\"\\n        ranked = {}\\n        for subq_id, sources in results.items():\\n            # 按優先級排序\\n            ranked[subq_id] = sorted(\\n                sources,\\n                key=lambda x: x[\\\"priority\\\"],\\n                reverse=True\\n            )[:5]  # 保留前 5 個最相關結果\\n        return ranked\\n\\n# 使用示例\\nsearch_engine = ParallelSearchEngine()\\nsubquestions = [\\n    {\\\"id\\\": 1, \\\"question\\\": \\\"What are the top AI code editors in 2026?\\\", \\\"search_focus\\\": \\\"market leaders\\\"},\\n    {\\\"id\\\": 2, \\\"question\\\": \\\"What is the market size of AI code editors?\\\", \\\"search_focus\\\"",
          "：使用計算機視覺和 OCR 技術理解網頁內容。該子系統執行",
          "：\\n\\n```\\n\\\"請按照這些步驟操作，按順序進行"
        ],
        "technical_architecture": [],
        "best_practices": [],
        "challenges": [],
        "implementation_strategies": []
      }
    }
  }
}