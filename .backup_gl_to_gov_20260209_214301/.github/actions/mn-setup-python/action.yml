# @GL-governed
# @GL-layer: GL90-99
# @GL-semantic: governed-configuration
# @GL-audit-trail: engine/governance/GL_SEMANTIC_ANCHOR.json

# MachineNativeOps Official Action: mn-setup-python
# Replaces: actions/setup-python@v5
# Description: Set up Python environment with full feature parity
# Version: 1.0.0

name: 'MN Setup Python'
description: 'MachineNativeOps official Python setup action'
author: 'MachineNativeOps'

branding:
  icon: 'code'
  color: 'blue'

# Governance Metadata:
#   name: ""
#   description: ""
#   labels: {}

inputs:
  python-version:
    description: 'Version range or exact version of Python to use, using SemVer notation'
    required: false
    default: '3.x'
  python-version-file:
    description: 'File containing the Python version to use (e.g., .python-version, pyproject.toml)'
    required: false
    default: ''
  cache:
    description: 'Package manager to cache dependencies for (pip, pipenv, poetry)'
    required: false
    default: ''
  cache-dependency-path:
    description: 'Path to dependency file(s) for caching'
    required: false
    default: ''
  architecture:
    description: 'Target architecture (x64, x86, arm64)'
    required: false
    default: 'x64'
  check-latest:
    description: 'Check for the latest available version matching the specification'
    required: false
    default: 'false'
  token:
    description: 'GitHub token for API requests'
    required: false
    default: ${{ github.token }}
  allow-prereleases:
    description: 'Allow pre-release versions of Python'
    required: false
    default: 'false'
  update-environment:
    description: 'Update environment variables'
    required: false
    default: 'true'

outputs:
  python-version:
    description: 'The installed Python version'
    value: ${{ steps.setup.outputs.python_version }}
  python-path:
    description: 'The path to the Python executable'
    value: ${{ steps.setup.outputs.python_path }}
  cache-hit:
    description: 'Whether the cache was hit'
    value: ${{ steps.cache.outputs.cache_hit }}

runs:
  using: 'composite'
  steps:
    - name: Detect Python Version from File
      id: detect
      shell: bash
      run: |
        VERSION="${{ inputs.python-version }}"
        VERSION_FILE="${{ inputs.python-version-file }}"

        # Try to read version from file if specified
        if [[ -n "$VERSION_FILE" && -f "$VERSION_FILE" ]]; then
          echo "Reading Python version from: $VERSION_FILE"

          case "$VERSION_FILE" in
            *.python-version|.python-version)
              VERSION=$(cat "$VERSION_FILE" | head -1 | tr -d '[:space:]')
              ;;
            *pyproject.toml)
              # Extract from pyproject.toml
              VERSION=$(grep -E "^python\s*=" "$VERSION_FILE" | head -1 | sed 's/.*"\([^"]*\)".*/\1/' | sed 's/[^0-9.]//g') || true
              if [[ -z "$VERSION" ]]; then
                VERSION=$(grep -E "requires-python" "$VERSION_FILE" | head -1 | sed 's/.*"\([^"]*\)".*/\1/' | sed 's/[^0-9.]//g') || true
              fi
              ;;
            *setup.py)
              VERSION=$(grep -E "python_requires" "$VERSION_FILE" | head -1 | sed 's/.*"\([^"]*\)".*/\1/' | sed 's/[^0-9.]//g') || true
              ;;
            *.tool-versions)
              VERSION=$(grep "^python" "$VERSION_FILE" | awk '{print $2}') || true
              ;;
          esac
        fi

        # Default to 3.x if no version found
        if [[ -z "$VERSION" ]]; then
          VERSION="3.x"
        fi

        echo "Requested Python version: $VERSION"
        echo "requested_version=$VERSION" >> $GITHUB_OUTPUT

    - name: Resolve Python Version
      id: resolve
      shell: bash
      run: |
        REQUESTED="${{ steps.detect.outputs.requested_version }}"
        ALLOW_PRERELEASE="${{ inputs.allow-prereleases }}"
        CHECK_LATEST="${{ inputs.check-latest }}"

        # Get available Python versions
        AVAILABLE_VERSIONS=""

        # Check system Python versions
        for py in python3.12 python3.11 python3.10 python3.9 python3.8 python3; do
          if command -v "$py" &> /dev/null; then
            VER=$("$py" --version 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
            if [[ -n "$VER" ]]; then
              AVAILABLE_VERSIONS="$AVAILABLE_VERSIONS $VER"
            fi
          fi
        done

        # Also check pyenv if available
        if command -v pyenv &> /dev/null; then
          PYENV_VERSIONS=$(pyenv versions --bare 2>/dev/null | grep -E '^[0-9]+\.[0-9]+' || true)
          AVAILABLE_VERSIONS="$AVAILABLE_VERSIONS $PYENV_VERSIONS"
        fi

        echo "Available versions: $AVAILABLE_VERSIONS"

        # Match requested version
        RESOLVED=""

        # Handle version patterns
        if [[ "$REQUESTED" == "3.x" || "$REQUESTED" == "3" ]]; then
          # Get latest Python 3.x
          RESOLVED=$(echo "$AVAILABLE_VERSIONS" | tr ' ' '\n' | grep -E "^3\." | sort -V | tail -1 || true)
        elif [[ "$REQUESTED" =~ ^[0-9]+\.[0-9]+$ ]]; then
          # Match major.minor (e.g., 3.11)
          RESOLVED=$(echo "$AVAILABLE_VERSIONS" | tr ' ' '\n' | grep -E "^${REQUESTED}\." | sort -V | tail -1 || true)
          # If exact minor version not found, use closest available
          if [[ -z "$RESOLVED" ]]; then
            MAJOR=$(echo "$REQUESTED" | cut -d. -f1)
            RESOLVED=$(echo "$AVAILABLE_VERSIONS" | tr ' ' '\n' | grep -E "^${MAJOR}\." | sort -V | tail -1 || true)
            if [[ -n "$RESOLVED" ]]; then
              echo "::warning::Requested Python $REQUESTED not found, using $RESOLVED instead"
            fi
          fi
        elif [[ "$REQUESTED" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          # Exact version - check if available, otherwise use closest
          if echo "$AVAILABLE_VERSIONS" | tr ' ' '\n' | grep -qE "^${REQUESTED}$"; then
            RESOLVED="$REQUESTED"
          else
            MAJOR_MINOR=$(echo "$REQUESTED" | cut -d. -f1,2)
            RESOLVED=$(echo "$AVAILABLE_VERSIONS" | tr ' ' '\n' | grep -E "^${MAJOR_MINOR}\." | sort -V | tail -1 || true)
            if [[ -z "$RESOLVED" ]]; then
              MAJOR=$(echo "$REQUESTED" | cut -d. -f1)
              RESOLVED=$(echo "$AVAILABLE_VERSIONS" | tr ' ' '\n' | grep -E "^${MAJOR}\." | sort -V | tail -1 || true)
            fi
            if [[ -n "$RESOLVED" ]]; then
              echo "::warning::Requested Python $REQUESTED not found, using $RESOLVED instead"
            fi
          fi
        else
          # Try to match pattern
          RESOLVED=$(echo "$AVAILABLE_VERSIONS" | tr ' ' '\n' | grep "$REQUESTED" | sort -V | tail -1 || true)
        fi

        # Fallback to system Python
        if [[ -z "$RESOLVED" ]]; then
          RESOLVED=$(python3 --version 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
          echo "::warning::Using system Python $RESOLVED"
        fi

        echo "Resolved version: $RESOLVED"
        echo "resolved_version=$RESOLVED" >> $GITHUB_OUTPUT

    - name: Setup Python Environment
      id: setup
      shell: bash
      run: |
        RESOLVED="${{ steps.resolve.outputs.resolved_version }}"
        ARCH="${{ inputs.architecture }}"
        UPDATE_ENV="${{ inputs.update-environment }}"

        echo "Setting up Python $RESOLVED..."

        # Find Python executable
        PYTHON_PATH=""
        MAJOR_MINOR=$(echo "$RESOLVED" | cut -d. -f1,2)

        # Try specific version first
        for candidate in "python$MAJOR_MINOR" "python${MAJOR_MINOR//./}" "python3" "python"; do
          if command -v "$candidate" &> /dev/null; then
            CANDIDATE_VER=$("$candidate" --version 2>&1 | grep -oE '[0-9]+\.[0-9]+' | head -1)
            if [[ "$CANDIDATE_VER" == "$MAJOR_MINOR" ]]; then
              PYTHON_PATH=$(which "$candidate")
              break
            fi
          fi
        done

        # Fallback to any Python 3
        if [[ -z "$PYTHON_PATH" ]]; then
          PYTHON_PATH=$(which python3 2>/dev/null || which python 2>/dev/null)
        fi

        if [[ -z "$PYTHON_PATH" ]]; then
          echo "::error::Python not found. Please ensure Python is installed."
          exit 1
        fi

        # Get actual version
        ACTUAL_VERSION=$("$PYTHON_PATH" --version 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)

        echo "Python executable: $PYTHON_PATH"
        echo "Python version: $ACTUAL_VERSION"

        # Update PATH if requested
        if [[ "$UPDATE_ENV" == "true" ]]; then
          PYTHON_DIR=$(dirname "$PYTHON_PATH")
          echo "$PYTHON_DIR" >> $GITHUB_PATH

          # Set Python-related environment variables
          echo "PYTHON=$PYTHON_PATH" >> $GITHUB_ENV
          echo "PYTHON_VERSION=$ACTUAL_VERSION" >> $GITHUB_ENV

          # Setup pip user directory
          PIP_USER_BASE=$("$PYTHON_PATH" -m site --user-base 2>/dev/null || echo "$HOME/.local")
          echo "$PIP_USER_BASE/bin" >> $GITHUB_PATH
        fi

        echo "python_version=$ACTUAL_VERSION" >> $GITHUB_OUTPUT
        echo "python_path=$PYTHON_PATH" >> $GITHUB_OUTPUT

    - name: Upgrade pip
      shell: bash
      run: |
        PYTHON_PATH="${{ steps.setup.outputs.python_path }}"

        echo "Upgrading pip..."
        "$PYTHON_PATH" -m pip install --upgrade pip --quiet 2>/dev/null || true

    - name: Setup Cache
      id: cache
      if: inputs.cache != ''
      shell: bash
      run: |
        CACHE_TYPE="${{ inputs.cache }}"
        CACHE_PATH="${{ inputs.cache-dependency-path }}"
        PYTHON_VERSION="${{ steps.setup.outputs.python_version }}"

        echo "Setting up cache for: $CACHE_TYPE"

        # Determine cache directory
        case "$CACHE_TYPE" in
          pip)
            CACHE_DIR="$HOME/.cache/pip"
            if [[ -z "$CACHE_PATH" ]]; then
              CACHE_PATH="**/requirements*.txt"
            fi
            ;;
          pipenv)
            CACHE_DIR="$HOME/.cache/pipenv"
            if [[ -z "$CACHE_PATH" ]]; then
              CACHE_PATH="**/Pipfile.lock"
            fi
            ;;
          poetry)
            CACHE_DIR="$HOME/.cache/pypoetry"
            if [[ -z "$CACHE_PATH" ]]; then
              CACHE_PATH="**/poetry.lock"
            fi
            ;;
          *)
            CACHE_DIR="$HOME/.cache/pip"
            ;;
        esac

        mkdir -p "$CACHE_DIR"

        # Generate cache key
        CACHE_KEY="python-$CACHE_TYPE-$PYTHON_VERSION-${{ runner.os }}"

        # Add hash of dependency files
        if [[ -n "$CACHE_PATH" ]]; then
          DEP_HASH=$(find . -name "$(basename "$CACHE_PATH")" -type f -exec md5sum {} \; 2>/dev/null | sort | md5sum | cut -d' ' -f1)
          CACHE_KEY="$CACHE_KEY-$DEP_HASH"
        fi

        echo "Cache directory: $CACHE_DIR"
        echo "Cache key: $CACHE_KEY"

        # Check if cache exists (simplified - actual caching handled by workflow)
        CACHE_HIT="false"
        if [[ -d "$CACHE_DIR" && -n "$(ls -A "$CACHE_DIR" 2>/dev/null)" ]]; then
          CACHE_HIT="true"
        fi

        echo "cache_hit=$CACHE_HIT" >> $GITHUB_OUTPUT
        echo "cache_dir=$CACHE_DIR" >> $GITHUB_OUTPUT
        echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT

    - name: Display Setup Summary
      shell: bash
      run: |
        PYTHON_PATH="${{ steps.setup.outputs.python_path }}"

        echo "=========================================="
        echo "MN-SETUP-PYTHON SUMMARY"
        echo "=========================================="
        echo "Python Version: ${{ steps.setup.outputs.python_version }}"
        echo "Python Path: $PYTHON_PATH"
        echo "Cache: ${{ inputs.cache }}"
        echo "Cache Hit: ${{ steps.cache.outputs.cache_hit }}"
        echo "=========================================="

        # Display Python info
        "$PYTHON_PATH" --version
        "$PYTHON_PATH" -m pip --version 2>/dev/null || true
