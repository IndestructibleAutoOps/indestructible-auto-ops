# @GL-layer: GQS-L0
# @GL-governed
# @GL-layer: GL90-99
# @GL-semantic: naming-governance
# @GL-audit-trail: gl-enterprise-architecture/governance/audit-trails/GL90_99-audit.json
#
# GL Unified Architecture Governance Framework Activated
# GL Root Semantic Anchor: gl-enterprise-architecture/governance/GL-ROOT-SEMANTIC-ANCHOR.yaml
# GL Unified Naming Charter: gl-enterprise-architecture/governance/GL-UNIFIED-NAMING-CHARTER.yaml


apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sAllowedRepos
metadata:
  name: gl-quantum-naming-constraint
  namespace: governance
  labels:
    gl-version: v10.0.0
    tier: quantum-naming
spec:
  match:
    kinds:
      - apiGroups: ["apps"]
        kinds: ["Deployment"]
      - apiGroups: [""]
        kinds: ["Service"]
      - apiGroups: ["networking.k8s.io"]
        kinds: ["Ingress"]
  parameters:
    repos:
      - ".*"
    namingPattern: "^(dev|staging|prod)-[a-z0-9-]+-(deploy|svc|ing|cm|secret)-v[0-9]+\\.[0-9]+\\.[0-9]+"

---
apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: glnamingconvention
  namespace: governance
spec:
  crd:
    spec:
      names:
        kind: GLNamingConvention
      validation:
        openAPIV3Schema:
          type: object
          properties:
            namingPattern:
              type: string
            requiredLabels:
              type: array
              items:
                type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package glnamingconvention
        
        violation[{"msg": msg}] {
          input.review.kind.kind == "Deployment"
          not re_match(object.get(input.parameters, "namingPattern", ""), input.review.object.metadata.name)
          msg := sprintf("Deployment name %s does not match naming pattern", [input.review.object.metadata.name])
        }
        
        violation[{"msg": msg}] {
          input.review.kind.kind == "Service"
          not re_match(object.get(input.parameters, "namingPattern", ""), input.review.object.metadata.name)
          msg := sprintf("Service name %s does not match naming pattern", [input.review.object.metadata.name])
        }
        
        violation[{"msg": msg}] {
          required := object.get(input.parameters, "requiredLabels", [])
          missing_label(required[_])
          msg := sprintf("Missing required label: %s", [missing])
        }
        
        missing_label[label] {
          required := object.get(input.parameters, "requiredLabels", [])
          label := required[_]
          not input.review.object.metadata.labels[label]
        }