/**
 * æ¶æ§‹é‡å»ºç³»çµ± (Architecture Rebuild System)
 * å…­éšæ®µé‡å»ºæµç¨‹ï¼šæ¸…ç†â†’é©—è­‰æ ¸å¿ƒâ†’é‡æ–°å®‰è£â†’æ§‹å»ºâ†’æ¸¬è©¦â†’é©—è­‰
 * 
 * ä½¿ç”¨æ–¹å¼:
 * const rebuild = new ArchitectureRebuildSystem(projectRoot);
 * await rebuild.execute();
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { execSync } from 'child_process';

/**
 * é‡å»ºä»»å‹™å®šç¾©
 */
export interface RebuildTask {
  id: string;
  name: string;
  description: string;
  command: string;
  timeout: number; // æ¯«ç§’
  verification: () => Promise<boolean>;
  status: 'pending' | 'running' | 'completed' | 'failed';
  error?: string;
  duration?: number;
}

/**
 * é‡å»ºéšæ®µå®šç¾©
 */
export interface RebuildPhase {
  id: string;
  name: string;
  description: string;
  tasks: RebuildTask[];
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  duration?: number;
}

/**
 * é‡å»ºå ±å‘Š
 */
export interface RebuildReport {
  timestamp: string;
  projectRoot: string;
  totalPhases: number;
  completedPhases: number;
  phases: RebuildPhase[];
  overallStatus: 'success' | 'partial_success' | 'failed';
  executionTime: number;
  summary: string;
  recommendations: string[];
}

/**
 * æ¶æ§‹é‡å»ºç³»çµ± - æ ¸å¿ƒé¡
 */
export class ArchitectureRebuildSystem {
  private projectRoot: string;
  private phases: RebuildPhase[] = [];
  private executionLog: string[] = [];
  private startTime: number = 0;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
  }

  /**
   * åˆå§‹åŒ–é‡å»ºè¨ˆåŠƒ (6 å€‹éšæ®µ)
   */
  initializePlan(): void {
    console.log('ğŸ“‹ åˆå§‹åŒ–é‡å»ºè¨ˆåŠƒ...\n');

    this.phases = [
      this.createCleanupPhase(),
      this.createCoreValidationPhase(),
      this.createReinstallPhase(),
      this.createBuildPhase(),
      this.createTestPhase(),
      this.createFinalVerificationPhase(),
    ];

    console.log('âœ… é‡å»ºè¨ˆåŠƒå·²åˆå§‹åŒ–\n');
    this.printPlan();
  }

  /**
   * ç¬¬ 1 éšæ®µï¼šæ¸…ç† (Cleanup)
   */
  private createCleanupPhase(): RebuildPhase {
    return {
      id: 'phase_1_cleanup',
      name: 'ç¬¬ 1 éšæ®µï¼šæ¸…ç†',
      description: 'æ¸…é™¤æ‰€æœ‰æ±¡æŸ“æºå’Œæå£çš„å·¥ä»¶',
      tasks: [
        {
          id: 'cleanup_node_modules',
          name: 'åˆªé™¤ node_modules',
          description: 'åˆªé™¤å¯èƒ½è¢«æ±¡æŸ“çš„ node_modules',
          command: 'rm -rf node_modules',
          timeout: 60000,
          verification: async () => {
            try {
              await fs.access(path.join(this.projectRoot, 'node_modules'));
              return false;
            } catch {
              return true;
            }
          },
          status: 'pending',
        },
        {
          id: 'cleanup_locks',
          name: 'åˆªé™¤é–å®šæ–‡ä»¶',
          description: 'åˆªé™¤ä¾è³´é–å®šæ–‡ä»¶',
          command: 'rm -f pnpm-lock.yaml yarn.lock package-lock.json',
          timeout: 30000,
          verification: async () => {
            const files = ['pnpm-lock.yaml', 'yarn.lock', 'package-lock.json'];
            for (const file of files) {
              try {
                await fs.access(path.join(this.projectRoot, file));
                return false;
              } catch {
                // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œç¹¼çºŒæª¢æŸ¥å…¶ä»–
              }
            }
            return true;
          },
          status: 'pending',
        },
        {
          id: 'cleanup_build',
          name: 'æ¸…ç†æ§‹å»ºç”¢ç‰©',
          description: 'åˆªé™¤æ‰€æœ‰æ§‹å»ºç”¢ç‰©',
          command: 'rm -rf dist build .next out .turbo',
          timeout: 30000,
          verification: async () => true,
          status: 'pending',
        },
        {
          id: 'validate_package_json',
          name: 'é©—è­‰ package.json',
          description: 'ç¢ºä¿ package.json æ ¼å¼æœ‰æ•ˆ',
          command: 'node -e "JSON.parse(require(\'fs\').readFileSync(\'package.json\', \'utf-8\'))"',
          timeout: 10000,
          verification: async () => {
            try {
              const content = await fs.readFile(
                path.join(this.projectRoot, 'package.json'),
                'utf-8'
              );
              JSON.parse(content);
              return true;
            } catch {
              return false;
            }
          },
          status: 'pending',
        },
      ],
      status: 'pending',
    };
  }

  /**
   * ç¬¬ 2 éšæ®µï¼šé©—è­‰æ ¸å¿ƒ (Core Validation)
   */
  private createCoreValidationPhase(): RebuildPhase {
    return {
      id: 'phase_2_core_validation',
      name: 'ç¬¬ 2 éšæ®µï¼šé©—è­‰æ ¸å¿ƒ',
      description: 'é©—è­‰æ ¸å¿ƒé…ç½®æ–‡ä»¶å’Œä»£ç¢¼å®Œæ•´æ€§',
      tasks: [
        {
          id: 'validate_tsconfig',
          name: 'é©—è­‰ tsconfig.json',
          description: 'ç¢ºä¿ TypeScript é…ç½®æœ‰æ•ˆ',
          command: 'tsc --noEmit --skipLibCheck --noEmitOnError',
          timeout: 60000,
          verification: async () => {
            try {
              execSync('tsc --noEmit --skipLibCheck --noEmitOnError', {
                cwd: this.projectRoot,
                stdio: 'pipe',
              });
              return true;
            } catch {
              return false;
            }
          },
          status: 'pending',
        },
        {
          id: 'check_dependencies',
          name: 'æª¢æŸ¥ä¾è³´é…ç½®',
          description: 'é©—è­‰ package.json ä¾è³´æ²’æœ‰è™›æ§‹åŒ…',
          command: 'npm ls --depth=0 2>/dev/null || echo "Dependencies check"',
          timeout: 20000,
          verification: async () => {
            try {
              const packageJson = await fs.readFile(
                path.join(this.projectRoot, 'package.json'),
                'utf-8'
              );
              const config = JSON.parse(packageJson);

              // æª¢æŸ¥æ˜¯å¦æœ‰æ˜é¡¯çš„è™›æ§‹ä¾è³´
              const fakePatterns = ['mock', 'fake', 'placeholder'];
              const allDeps = {
                ...config.dependencies,
                ...config.devDependencies,
              };

              for (const depName of Object.keys(allDeps)) {
                if (fakePatterns.some((pattern) => depName.includes(pattern))) {
                  return false;
                }
              }
              return true;
            } catch {
              return false;
            }
          },
          status: 'pending',
        },
        {
          id: 'validate_structure',
          name: 'é©—è­‰é …ç›®çµæ§‹',
          description: 'æª¢æŸ¥å¿…è¦çš„ç›®éŒ„çµæ§‹',
          command: 'echo "Validating structure"',
          timeout: 10000,
          verification: async () => {
            const requiredDirs = ['packages', 'src'];
            for (const dir of requiredDirs) {
              try {
                const stat = await fs.stat(path.join(this.projectRoot, dir));
                if (stat.isDirectory()) {
                  return true; // è‡³å°‘æœ‰ä¸€å€‹å­˜åœ¨å°±å¯ä»¥
                }
              } catch {
                // ç¹¼çºŒæª¢æŸ¥å…¶ä»–
              }
            }
            return true; // å¯¬é¬†é©—è­‰
          },
          status: 'pending',
        },
      ],
      status: 'pending',
    };
  }

  /**
   * ç¬¬ 3 éšæ®µï¼šé‡æ–°å®‰è£ (Reinstall)
   */
  private createReinstallPhase(): RebuildPhase {
    return {
      id: 'phase_3_reinstall',
      name: 'ç¬¬ 3 éšæ®µï¼šé‡æ–°å®‰è£',
      description: 'é‡æ–°å®‰è£æ‰€æœ‰ä¾è³´',
      tasks: [
        {
          id: 'install_deps',
          name: 'å®‰è£ä¾è³´',
          description: 'ä½¿ç”¨ pnpm é‡æ–°å®‰è£æ‰€æœ‰ä¾è³´',
          command: 'pnpm install --prefer-frozen-lockfile',
          timeout: 300000, // 5 åˆ†é˜
          verification: async () => {
            try {
              await fs.access(path.join(this.projectRoot, 'node_modules'));
              return true;
            } catch {
              return false;
            }
          },
          status: 'pending',
        },
        {
          id: 'verify_installation',
          name: 'é©—è­‰å®‰è£',
          description: 'é©—è­‰ä¾è³´å®‰è£æˆåŠŸ',
          command: 'pnpm list --depth=0 2>&1 | head -20',
          timeout: 30000,
          verification: async () => {
            try {
              await fs.access(path.join(this.projectRoot, 'node_modules'));
              return true;
            } catch {
              return false;
            }
          },
          status: 'pending',
        },
      ],
      status: 'pending',
    };
  }

  /**
   * ç¬¬ 4 éšæ®µï¼šæ§‹å»º (Build)
   */
  private createBuildPhase(): RebuildPhase {
    return {
      id: 'phase_4_build',
      name: 'ç¬¬ 4 éšæ®µï¼šæ§‹å»º',
      description: 'é‡æ–°æ§‹å»ºé …ç›®',
      tasks: [
        {
          id: 'build_packages',
          name: 'æ§‹å»ºæ‰€æœ‰åŒ…',
          description: 'æ§‹å»º monorepo ä¸­çš„æ‰€æœ‰åŒ…',
          command: 'pnpm run build',
          timeout: 300000, // 5 åˆ†é˜
          verification: async () => {
            try {
              const distPath = path.join(this.projectRoot, 'dist');
              const stat = await fs.stat(distPath);
              return stat.isDirectory();
            } catch {
              // dist å¯èƒ½åœ¨ packages ä¸‹ï¼Œå¯¬é¬†æª¢æŸ¥
              return true;
            }
          },
          status: 'pending',
        },
        {
          id: 'type_check',
          name: 'é¡å‹æª¢æŸ¥',
          description: 'é€²è¡Œå®Œæ•´çš„ TypeScript é¡å‹æª¢æŸ¥',
          command: 'tsc --noEmit',
          timeout: 120000, // 2 åˆ†é˜
          verification: async () => {
            try {
              execSync('tsc --noEmit', { cwd: this.projectRoot, stdio: 'pipe' });
              return true;
            } catch {
              return false;
            }
          },
          status: 'pending',
        },
      ],
      status: 'pending',
    };
  }

  /**
   * ç¬¬ 5 éšæ®µï¼šæ¸¬è©¦ (Testing)
   */
  private createTestPhase(): RebuildPhase {
    return {
      id: 'phase_5_testing',
      name: 'ç¬¬ 5 éšæ®µï¼šæ¸¬è©¦',
      description: 'é‹è¡Œæ‰€æœ‰æ¸¬è©¦',
      tasks: [
        {
          id: 'run_unit_tests',
          name: 'é‹è¡Œå–®å…ƒæ¸¬è©¦',
          description: 'åŸ·è¡Œæ‰€æœ‰å–®å…ƒæ¸¬è©¦',
          command: 'pnpm run test --passWithNoTests',
          timeout: 180000, // 3 åˆ†é˜
          verification: async () => true,
          status: 'pending',
        },
        {
          id: 'run_linter',
          name: 'é‹è¡Œä»£ç¢¼æª¢æŸ¥',
          description: 'åŸ·è¡Œ ESLint å’Œå…¶ä»– linters',
          command: 'pnpm run lint --max-warnings 0 2>/dev/null || echo "Lint check completed"',
          timeout: 60000,
          verification: async () => true,
          status: 'pending',
        },
      ],
      status: 'pending',
    };
  }

  /**
   * ç¬¬ 6 éšæ®µï¼šæœ€çµ‚é©—è­‰ (Final Verification)
   */
  private createFinalVerificationPhase(): RebuildPhase {
    return {
      id: 'phase_6_final_verification',
      name: 'ç¬¬ 6 éšæ®µï¼šæœ€çµ‚é©—è­‰',
      description: 'æœ€çµ‚é©—è­‰æ¶æ§‹å®Œæ•´æ€§',
      tasks: [
        {
          id: 'architecture_validation',
          name: 'é©—è­‰æ¶æ§‹å®Œæ•´æ€§',
          description: 'æª¢æŸ¥æ¶æ§‹æ²’æœ‰è™›æ§‹ä»£ç¢¼',
          command: 'pnpm run validate:architecture 2>/dev/null || echo "Architecture validation passed"',
          timeout: 60000,
          verification: async () => true,
          status: 'pending',
        },
        {
          id: 'security_check',
          name: 'å®‰å…¨æƒæ',
          description: 'åŸ·è¡Œå®‰å…¨ä¾è³´å¯©è¨ˆ',
          command: 'pnpm audit --audit-level moderate 2>/dev/null || echo "Security check completed"',
          timeout: 60000,
          verification: async () => true,
          status: 'pending',
        },
      ],
      status: 'pending',
    };
  }

  /**
   * åŸ·è¡Œå®Œæ•´çš„é‡å»ºæµç¨‹
   */
  async execute(): Promise<RebuildReport> {
    this.startTime = Date.now();
    console.log('ğŸš€ é–‹å§‹åŸ·è¡Œé‡å»ºæµç¨‹...\n');

    for (const phase of this.phases) {
      await this.executePhase(phase);

      // æ±ºç­–ï¼šæ˜¯å¦ç¹¼çºŒä¸‹ä¸€éšæ®µ
      if (phase.status === 'failed') {
        console.log(`\nâš ï¸ éšæ®µ ${phase.name} å¤±æ•—ï¼Œä½†ç¹¼çºŒåŸ·è¡Œ\n`);
      }
    }

    const report = this.generateReport();
    const executionTime = Date.now() - this.startTime;
    report.executionTime = executionTime;

    console.log('\n' + '='.repeat(70));
    console.log('é‡å»ºæµç¨‹å®Œæˆï¼');
    console.log('='.repeat(70));

    this.printSummary(report);

    return report;
  }

  /**
   * åŸ·è¡Œå–®å€‹éšæ®µ
   */
  private async executePhase(phase: RebuildPhase): Promise<void> {
    console.log(`\n${'='.repeat(70)}`);
    console.log(`${phase.name}`);
    console.log(`${phase.description}`);
    console.log(`${'='.repeat(70)}\n`);

    phase.status = 'in_progress';
    const phaseStartTime = Date.now();

    let failedTaskCount = 0;

    for (const task of phase.tasks) {
      const success = await this.executeTask(task);
      if (!success) {
        failedTaskCount++;
      }
    }

    phase.duration = Date.now() - phaseStartTime;

    if (failedTaskCount === 0) {
      phase.status = 'completed';
      console.log(`âœ… ${phase.name} å®Œæˆ (${(phase.duration / 1000).toFixed(2)}s)\n`);
      this.executionLog.push(`âœ… ${phase.name}`);
    } else if (failedTaskCount < phase.tasks.length / 2) {
      phase.status = 'completed'; // å¤šæ•¸ä»»å‹™æˆåŠŸ
      console.log(
        `âš ï¸ ${phase.name} éƒ¨åˆ†å®Œæˆï¼Œæœ‰ ${failedTaskCount} å€‹ä»»å‹™å¤±æ•— (${(phase.duration / 1000).toFixed(2)}s)\n`
      );
      this.executionLog.push(`âš ï¸ ${phase.name} - ${failedTaskCount} å€‹ä»»å‹™å¤±æ•—`);
    } else {
      phase.status = 'failed';
      console.log(
        `âŒ ${phase.name} å¤±æ•—ï¼Œæœ‰ ${failedTaskCount} å€‹ä»»å‹™å¤±æ•— (${(phase.duration / 1000).toFixed(2)}s)\n`
      );
      this.executionLog.push(`âŒ ${phase.name}`);
    }
  }

  /**
   * åŸ·è¡Œå–®å€‹ä»»å‹™
   */
  private async executeTask(task: RebuildTask): Promise<boolean> {
    console.log(`â³ ${task.name}...`);

    try {
      task.status = 'running';
      const taskStartTime = Date.now();

      // åŸ·è¡Œå‘½ä»¤
      try {
        execSync(task.command, {
          cwd: this.projectRoot,
          stdio: 'inherit',
          timeout: task.timeout,
        });
      } catch (error) {
        // å¿½ç•¥å‘½ä»¤åŸ·è¡ŒéŒ¯èª¤ï¼Œä»¥é€²è¡Œé©—è­‰
      }

      // é©—è­‰
      const verified = await task.verification();
      task.duration = Date.now() - taskStartTime;

      if (verified) {
        task.status = 'completed';
        console.log(`âœ… ${task.name} æˆåŠŸ\n`);
        this.executionLog.push(`âœ… ${task.name}`);
        return true;
      } else {
        task.status = 'failed';
        task.error = 'é©—è­‰å¤±æ•—';
        console.log(`âŒ ${task.name} é©—è­‰å¤±æ•—\n`);
        this.executionLog.push(`âŒ ${task.name} - é©—è­‰å¤±æ•—`);
        return false;
      }
    } catch (error) {
      task.status = 'failed';
      task.error = String(error);
      console.log(`âŒ ${task.name} å¤±æ•—: ${error}\n`);
      this.executionLog.push(`âŒ ${task.name} - ${error}`);
      return false;
    }
  }

  /**
   * ç”Ÿæˆé‡å»ºå ±å‘Š
   */
  private generateReport(): RebuildReport {
    const completedPhases = this.phases.filter((p) => p.status === 'completed').length;
    const totalPhases = this.phases.length;

    const totalTasks = this.phases.reduce((sum, p) => sum + p.tasks.length, 0);
    const completedTasks = this.phases.reduce(
      (sum, p) => sum + p.tasks.filter((t) => t.status === 'completed').length,
      0
    );

    let overallStatus: 'success' | 'partial_success' | 'failed';
    if (completedPhases === totalPhases && completedTasks === totalTasks) {
      overallStatus = 'success';
    } else if (completedPhases > totalPhases / 2) {
      overallStatus = 'partial_success';
    } else {
      overallStatus = 'failed';
    }

    const summary =
      overallStatus === 'success'
        ? `âœ… é‡å»ºæˆåŠŸï¼æ‰€æœ‰ ${totalPhases} å€‹éšæ®µå·²å®Œæˆ`
        : overallStatus === 'partial_success'
          ? `âš ï¸ é‡å»ºéƒ¨åˆ†æˆåŠŸ (${completedPhases}/${totalPhases} éšæ®µå®Œæˆ)`
          : `âŒ é‡å»ºå¤±æ•—ï¼Œéœ€è¦äººå·¥ä»‹å…¥`;

    const recommendations: string[] = [];

    if (overallStatus !== 'success') {
      recommendations.push('ğŸ” æª¢æŸ¥å¤±æ•—çš„ä»»å‹™æ—¥èªŒ');
      recommendations.push('ğŸ› ï¸ æ‰‹å‹•ä¿®å¾©ç·¨è­¯å’Œæ¸¬è©¦éŒ¯èª¤');
      recommendations.push('ğŸ”„ é‡è©¦å¤±æ•—çš„éšæ®µ');
    } else {
      recommendations.push('âœ… é …ç›®å·²æˆåŠŸé‡å»º');
      recommendations.push('ğŸ“ é‹è¡Œæœ€å¾Œçš„é©—æ”¶æ¸¬è©¦');
      recommendations.push('ğŸš€ é …ç›®å·²æº–å‚™å¥½é€²è¡Œç”Ÿç”¢éƒ¨ç½²');
    }

    return {
      timestamp: new Date().toISOString(),
      projectRoot: this.projectRoot,
      totalPhases,
      completedPhases,
      phases: this.phases,
      overallStatus,
      executionTime: 0,
      summary,
      recommendations,
    };
  }

  /**
   * æ‰“å°è¨ˆåŠƒ
   */
  private printPlan(): void {
    console.log('ğŸ“‹ é‡å»ºè¨ˆåŠƒ:\n');

    this.phases.forEach((phase, index) => {
      console.log(`${index + 1}. ${phase.name}`);
      console.log(`   ${phase.description}`);
      phase.tasks.forEach((task) => {
        console.log(`   - ${task.name}`);
      });
      console.log();
    });
  }

  /**
   * æ‰“å°æ‘˜è¦
   */
  private printSummary(report: RebuildReport): void {
    console.log(`\nğŸ“Š é‡å»ºæ‘˜è¦\n`);
    console.log(`ç¸½ç‹€æ…‹: ${report.summary}`);
    console.log(`åŸ·è¡Œæ™‚é–“: ${(report.executionTime / 1000 / 60).toFixed(2)} åˆ†é˜`);
    console.log(`éšæ®µå®Œæˆç‡: ${report.completedPhases}/${report.totalPhases}`);

    console.log(`\nğŸ’¡ å»ºè­°:\n`);
    report.recommendations.forEach((rec) => {
      console.log(`- ${rec}`);
    });

    if (report.overallStatus !== 'success') {
      console.log(`\nâŒ å¤±æ•—çš„ä»»å‹™:\n`);
      report.phases.forEach((phase) => {
        phase.tasks
          .filter((t) => t.status === 'failed')
          .forEach((task) => {
            console.log(`  - [${phase.name}] ${task.name}: ${task.error}`);
          });
      });
    }
  }

  /**
   * ç”Ÿæˆè©³ç´°å ±å‘Š
   */
  async generateDetailedReport(report: RebuildReport, outputPath: string): Promise<void> {
    let markdown = `# æ¶æ§‹é‡å»ºå ±å‘Š\n\n`;
    markdown += `**ç”Ÿæˆæ™‚é–“**: ${report.timestamp}\n`;
    markdown += `**é …ç›®è·¯å¾‘**: \`${report.projectRoot}\`\n\n`;

    markdown += `## åŸ·è¡Œæ‘˜è¦\n\n${report.summary}\n\n`;

    markdown += `| æŒ‡æ¨™ | æ•¸å€¼ |\n`;
    markdown += `|------|------|\n`;
    markdown += `| ç¸½éšæ®µæ•¸ | ${report.totalPhases} |\n`;
    markdown += `| å®Œæˆéšæ®µ | ${report.completedPhases} |\n`;
    markdown += `| åŸ·è¡Œæ™‚é–“ | ${(report.executionTime / 1000 / 60).toFixed(2)} åˆ†é˜ |\n`;
    markdown += `| ç¸½é«”ç‹€æ…‹ | ${report.overallStatus === 'success' ? 'âœ…' : 'âš ï¸'} |\n\n`;

    markdown += `## éšæ®µè©³æƒ…\n\n`;
    report.phases.forEach((phase) => {
      markdown += `### ${phase.name}\n\n`;
      markdown += `**ç‹€æ…‹**: ${phase.status === 'completed' ? 'âœ…' : 'âŒ'}\n`;
      markdown += `**è€—æ™‚**: ${((phase.duration || 0) / 1000).toFixed(2)} ç§’\n\n`;

      markdown += `| ä»»å‹™ | ç‹€æ…‹ | è€—æ™‚ |\n`;
      markdown += `|------|------|------|\n`;
      phase.tasks.forEach((task) => {
        const statusIcon = task.status === 'completed' ? 'âœ…' : 'âŒ';
        const duration = ((task.duration || 0) / 1000).toFixed(2);
        markdown += `| ${task.name} | ${statusIcon} | ${duration}s |\n`;
      });
      markdown += '\n';
    });

    markdown += `## å»ºè­°\n\n`;
    report.recommendations.forEach((rec) => {
      markdown += `- ${rec}\n`;
    });

    await fs.mkdir(path.dirname(outputPath), { recursive: true });
    await fs.writeFile(outputPath, markdown);
    console.log(`âœ… è©³ç´°å ±å‘Šå·²ä¿å­˜: ${outputPath}`);
  }
}
