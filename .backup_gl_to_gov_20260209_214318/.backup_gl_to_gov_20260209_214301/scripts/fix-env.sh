#!/usr/bin/env bash
#
# @GL-governed
# @GL-layer: GL30-49
# @GL-semantic: environment-fix
# @GL-audit-trail: ./governance/GL_SEMANTIC_ANCHOR.json
#
# ═══════════════════════════════════════════════════════════════════════════════
#                    Machine Native Ops - Environment Fix Script
#                    GL Layer: GL30-49 Execution Layer
#                    Purpose: Fix environment configuration with audit logging
# ═══════════════════════════════════════════════════════════════════════════════
#
# This script fixes environment configuration with:
# - Missing .env file generation
# - Placeholder value generation
# - Environment variable validation
# - Audit trail logging
#
# Usage:
#   ./scripts/fix-env.sh [--generate-secrets] [--validate-only] [--force]
#
# ═══════════════════════════════════════════════════════════════════════════════

set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
LOGS_DIR="${PROJECT_ROOT}/ecosystem/logs"
AUDIT_LOGS_DIR="${LOGS_DIR}/audit-logs"
ENV_FILE="${PROJECT_ROOT}/.env"
ENV_EXAMPLE="${PROJECT_ROOT}/.env.example"

# Audit fields
ACTOR="${USER:-system}"
ACTION="fix-env"
REQUEST_ID="$(date +%Y%m%d%H%M%S)-$$-$(head -c 8 /dev/urandom | od -An -tx1 | tr -d ' \n')"
CORRELATION_ID="${CORRELATION_ID:-${REQUEST_ID}}"
IP_ADDRESS="${SSH_CLIENT:-}"
IP_ADDRESS="${IP_ADDRESS%% *}"
IP_ADDRESS="${IP_ADDRESS:-127.0.0.1}"
USER_AGENT="fix-env-script/1.0.0"
VERSION="1.0.0"

# Flags
GENERATE_SECRETS=false
VALIDATE_ONLY=false
FORCE=false

# ─────────────────────────────────────────────────────────────────────────────
# Functions
# ─────────────────────────────────────────────────────────────────────────────

# RFC3339 UTC timestamp
get_timestamp() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# Calculate SHA256 hash
calculate_hash() {
    local content="$1"
    echo -n "$content" | sha256sum | cut -d' ' -f1
}

# Generate random secure string
generate_secure_string() {
    local length="${1:-32}"
    head -c "$length" /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c "$length"
}

# Emit audit log in JSONL format
emit_audit_log() {
    local resource="$1"
    local result="$2"
    local details="${3:-}"
    local timestamp
    timestamp=$(get_timestamp)
    
    local content="${timestamp}|${ACTOR}|${ACTION}|${resource}|${result}"
    local hash
    hash=$(calculate_hash "$content")
    
    mkdir -p "$AUDIT_LOGS_DIR"
    
    local audit_entry
    audit_entry=$(cat <<EOF
{"timestamp":"${timestamp}","actor":"${ACTOR}","action":"${ACTION}","resource":"${resource}","result":"${result}","hash":"${hash}","version":"${VERSION}","requestId":"${REQUEST_ID}","correlationId":"${CORRELATION_ID}","ip":"${IP_ADDRESS}","userAgent":"${USER_AGENT}","details":"${details}","traceId":"$(head -c 16 /dev/urandom | od -An -tx1 | tr -d ' \n')","spanId":"$(head -c 8 /dev/urandom | od -An -tx1 | tr -d ' \n')"}
EOF
)
    
    echo "$audit_entry" >> "${AUDIT_LOGS_DIR}/fix-env-audit.jsonl"
}

print_header() {
    echo ""
    echo "═══════════════════════════════════════════════════════════════════════════════"
    echo "  $1"
    echo "═══════════════════════════════════════════════════════════════════════════════"
}

print_success() {
    echo "  ✅ $1"
}

print_warning() {
    echo "  ⚠️  $1"
}

print_error() {
    echo "  ❌ $1"
}

print_info() {
    echo "  ℹ️  $1"
}

# Check if .env exists
check_env_exists() {
    if [[ -f "$ENV_FILE" ]]; then
        return 0
    fi
    return 1
}

# Create .env from .env.example
create_env_from_example() {
    if [[ -f "$ENV_EXAMPLE" ]]; then
        if [[ "$FORCE" == "true" ]] || [[ ! -f "$ENV_FILE" ]]; then
            cp "$ENV_EXAMPLE" "$ENV_FILE"
            print_success "Created .env from .env.example"
            emit_audit_log "env-file" "created" "from .env.example"
            return 0
        else
            print_warning ".env already exists (use --force to overwrite)"
            return 1
        fi
    else
        print_error ".env.example not found"
        emit_audit_log "env-file" "failed" ".env.example not found"
        return 1
    fi
}

# Generate placeholder .env file
generate_placeholder_env() {
    print_info "Generating placeholder .env file..."
    
    if [[ -f "$ENV_FILE" ]] && [[ "$FORCE" != "true" ]]; then
        print_warning ".env already exists (use --force to overwrite)"
        return 1
    fi
    
    local env_content
    env_content=$(cat <<EOF
# Environment Configuration
# Generated by fix-env.sh at $(get_timestamp)
# GL Layer: Environment (GL90-99 Meta-Specification)
# IMPORTANT: Replace placeholder values with actual secrets in production

# ============================================================================
# Application Settings (GL10-29 Operational)
# ============================================================================
APP_ENV=development
APP_DEBUG=true
APP_LOG_LEVEL=INFO

# ============================================================================
# Database Configuration (GL10-29 Operational)
# ============================================================================
DATABASE_HOST=localhost
DATABASE_PORT=5432
DATABASE_NAME=machine_native_ops_dev
DATABASE_USER=dev_user
DATABASE_PASSWORD=PLACEHOLDER_CHANGE_ME

# ============================================================================
# API Configuration (GL10-29 Operational)
# ============================================================================
API_SECRET_KEY=PLACEHOLDER_$(generate_secure_string 24)
API_ENCRYPTION_KEY=PLACEHOLDER_$(generate_secure_string 24)

# ============================================================================
# Authentication (GL10-29 Operational)
# ============================================================================
AUTH_TOKEN=PLACEHOLDER_$(generate_secure_string 16)
JWT_SECRET=PLACEHOLDER_$(generate_secure_string 32)
JWT_EXPIRATION_HOURS=24

# ============================================================================
# Governance Configuration (GL10-29 Operational)
# ============================================================================
GOVERNANCE_POLICY_ENFORCEMENT=true
GOVERNANCE_AUDIT_LOGGING=true

# ============================================================================
# Development Tools (GL30-49 Execution)
# ============================================================================
DEV_HOT_RELOAD=true
DEV_MOCK_EXTERNAL_SERVICES=true

# ============================================================================
# Security Notes
# ============================================================================
# 1. Replace all PLACEHOLDER_* values before production deployment
# 2. Use a secret management system for production
# 3. Never commit real secrets to version control

EOF
)
    
    echo "$env_content" > "$ENV_FILE"
    print_success "Generated placeholder .env file"
    emit_audit_log "env-file" "generated" "placeholder values"
    
    return 0
}

# Generate secure secrets
generate_secrets() {
    print_info "Generating secure secrets..."
    
    if [[ ! -f "$ENV_FILE" ]]; then
        print_error ".env file not found. Run without --generate-secrets first."
        return 1
    fi
    
    # Read current .env
    local temp_file
    temp_file=$(mktemp)
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^([A-Z_]+)=PLACEHOLDER_.*$ ]]; then
            local var_name="${BASH_REMATCH[1]}"
            local new_value
            
            case "$var_name" in
                *PASSWORD*|*SECRET*|*KEY*|*TOKEN*)
                    new_value=$(generate_secure_string 32)
                    echo "${var_name}=${new_value}" >> "$temp_file"
                    print_info "Generated secure value for $var_name"
                    ;;
                *)
                    echo "$line" >> "$temp_file"
                    ;;
            esac
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$ENV_FILE"
    
    mv "$temp_file" "$ENV_FILE"
    print_success "Secrets generated"
    emit_audit_log "secrets" "generated"
    
    return 0
}

# Validate environment variables
validate_env() {
    print_info "Validating environment variables..."
    
    if [[ ! -f "$ENV_FILE" ]]; then
        print_error ".env file not found"
        emit_audit_log "validate" "failed" ".env not found"
        return 1
    fi
    
    local issues=0
    local warnings=0
    
    # Load .env
    set -a
    # shellcheck source=/dev/null
    source "$ENV_FILE" 2>/dev/null || true
    set +a
    
    # Check for placeholder values
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^([A-Z_]+)=PLACEHOLDER.*$ ]]; then
            local var_name="${BASH_REMATCH[1]}"
            print_warning "$var_name contains placeholder value"
            ((warnings++))
        fi
        
        if [[ "$line" =~ ^([A-Z_]+)=$ ]]; then
            local var_name="${BASH_REMATCH[1]}"
            print_warning "$var_name is empty"
            ((warnings++))
        fi
    done < "$ENV_FILE"
    
    # Check required variables
    local required_vars=()
    for var in "${required_vars[@]}"; do
        if [[ -z "${!var:-}" ]]; then
            print_error "Required variable $var is missing"
            ((issues++))
        fi
    done
    
    if [[ $issues -gt 0 ]]; then
        print_error "Validation failed with $issues issues"
        emit_audit_log "validate" "failed" "$issues issues"
        return 1
    fi
    
    if [[ $warnings -gt 0 ]]; then
        print_warning "Validation passed with $warnings warnings"
        print_info "Replace placeholder values before production deployment"
        emit_audit_log "validate" "warning" "$warnings warnings"
    else
        print_success "Validation passed"
        emit_audit_log "validate" "passed"
    fi
    
    return 0
}

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --generate-secrets)
                GENERATE_SECRETS=true
                shift
                ;;
            --validate-only)
                VALIDATE_ONLY=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --help|-h)
                cat <<EOF
Usage: $(basename "$0") [OPTIONS]

Fix environment configuration for Machine Native Ops.

Options:
    --generate-secrets  Generate secure random values for secrets
    --validate-only     Only validate existing .env, don't modify
    --force             Overwrite existing .env file
    --help              Show this help message

Examples:
    $(basename "$0")                    # Create .env with placeholders
    $(basename "$0") --generate-secrets # Replace placeholders with secure values
    $(basename "$0") --validate-only    # Validate existing .env
    $(basename "$0") --force            # Force overwrite existing .env

EOF
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
}

# ─────────────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────────────

main() {
    parse_args "$@"
    
    print_header "Machine Native Ops - Environment Fix"
    
    echo ""
    echo "  Request ID: $REQUEST_ID"
    echo "  Timestamp: $(get_timestamp)"
    echo ""
    
    emit_audit_log "fix-env" "started"
    
    # Validate only mode
    if [[ "$VALIDATE_ONLY" == "true" ]]; then
        validate_env
        emit_audit_log "fix-env" "completed" "validate-only"
        return $?
    fi
    
    # Check if .env exists
    if check_env_exists; then
        if [[ "$FORCE" == "true" ]]; then
            print_info ".env exists, will be overwritten (--force)"
        else
            print_info ".env already exists"
            
            if [[ "$GENERATE_SECRETS" == "true" ]]; then
                generate_secrets
            else
                validate_env
            fi
            
            emit_audit_log "fix-env" "completed"
            return 0
        fi
    fi
    
    # Try to create from example first
    if [[ -f "$ENV_EXAMPLE" ]]; then
        create_env_from_example
    else
        generate_placeholder_env
    fi
    
    # Generate secrets if requested
    if [[ "$GENERATE_SECRETS" == "true" ]]; then
        generate_secrets
    fi
    
    # Validate the result
    validate_env
    
    print_header "Environment Fix Complete"
    
    echo ""
    echo "  .env file is ready at: $ENV_FILE"
    echo ""
    echo "  ⚠️  IMPORTANT:"
    echo "     1. Review and update placeholder values"
    echo "     2. Never commit .env with real secrets"
    echo "     3. Use --generate-secrets for secure values"
    echo ""
    
    emit_audit_log "fix-env" "completed"
    return 0
}

main "$@"
