/**
 * @GL-governed
 * @GL-layer: governance
 * @GL-semantic: engine-core
 * @GL-audit-trail: GL_SEMANTIC_ANCHOR.json
 * 
 * GL Unified Charter Activated - Governance Engine Core
 * Enforces strict governance validation and event stream generation
 */

import { promises as fs } from 'fs';
import path from 'path';
import { GovernanceEventWriter } from './events_writer';
import { RuleEvaluator } from './rule_evaluator';
import { AnchorResolver } from './anchor_resolver';

export interface GovernanceResult {
  success: boolean;
  violations: GovernanceViolation[];
  events: GovernanceEvent[];
  auditTrail: string[];
}

export interface GovernanceViolation {
  code: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  message: string;
  file: string;
  line?: number;
  fixRequired: boolean;
}

export interface GovernanceEvent {
  id: string;
  type: 'validation' | 'compliance' | 'enforcement' | 'audit';
  timestamp: string;
  source: string;
  data: any;
}

export class GLEngine {
  private eventWriter: GovernanceEventWriter;
  private ruleEvaluator: RuleEvaluator;
  private anchorResolver: AnchorResolver;
  private auditTrail: string[] = [];

  constructor(private workspace: string = process.cwd()) {
    this.eventWriter = new GovernanceEventWriter(workspace);
    this.ruleEvaluator = new RuleEvaluator(workspace);
    this.anchorResolver = new AnchorResolver(workspace);
  }

  async validate(options: { strict?: boolean } = {}): Promise<GovernanceResult> {
    const result: GovernanceResult = {
      success: true,
      violations: [],
      events: [],
      auditTrail: []
    };

    this.auditTrail.push(`GL Validation Started at ${new Date().toISOString()}`);
    this.auditTrail.push(`Workspace: ${this.workspace}`);
    this.auditTrail.push(`Strict Mode: ${options.strict ?? true}`);

    try {
      // Load semantic anchor
      const anchorLoaded = await this.anchorResolver.loadAnchor();
      if (!anchorLoaded) {
        result.success = false;
        result.violations.push({
          code: 'GL-ANCHOR-MISSING',
          severity: 'critical',
          message: 'GL Semantic Anchor not found or invalid',
          file: 'governance/GL_SEMANTIC_ANCHOR.json',
          fixRequired: true
        });
      }

      // Scan and validate all files
      const violations = await this.scanAndValidate();
      result.violations.push(...violations);

      // Check if critical violations exist
      const criticalViolations = result.violations.filter(v => v.severity === 'critical');
      if (criticalViolations.length > 0) {
        result.success = false;
        if (options.strict !== false) {
          throw new Error(`Critical GL violations detected: ${criticalViolations.length}`);
        }
      }

      // Generate governance events
      const events = await this.generateGovernanceEvents(result);
      result.events.push(...events);

      // Write event stream
      await this.eventWriter.writeEvents(events);

    } catch (error) {
      result.success = false;
